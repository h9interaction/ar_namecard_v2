This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  test/
    avatar_new.html
    avatar.html
    cors-test.html
    customize.html
    item.html
    login.html
    user.html
scripts/
  generate-ssl-cert-fixed.js
  generate-ssl-cert.js
  migrate-avatar-colors.js
  migrate-uploads-to-firebase.ts
  setup-mkcert.js
  update-db-urls-to-firebase.ts
src/
  config/
    cors.ts
    database.ts
    firebase-storage.ts
    swagger.ts
  controllers/
    adminAvatarController.ts
    adminController.ts
    adminItemController.ts
    authController.ts
    avatarController.ts
    firebaseAuthController.ts
    itemController.ts
    userController.ts
  middleware/
    auth.ts
    upload.ts
  models/
    AvatarCategory.ts
    index.ts
    ItemCategory.ts
    User.ts
    UserCustomization.ts
  routes/
    adminAvatarRoutes.ts
    adminItemRoutes.ts
    adminRoutes.ts
    authRoutes.ts
    avatarRoutes.ts
    charactersRoutes.ts
    firebaseAuthRoutes.ts
    itemRoutes.ts
    userRoutes.ts
  scripts/
    config/
      firebase-admin.ts
    types/
      firebase-user.ts
    utils/
      arId-generator.ts
      data-mapper.ts
    create-admin.ts
    firebase-migration.ts
    update-admin-permissions.ts
  utils/
    paletteImageProcessor.ts
    thumbnailGenerator.ts
  index.ts
ssl/
  server.crt
  server.crt.backup
.gitignore
backup.sh
CORS_SETUP.md
deploy.sh
DEPLOYMENT_CHECKLIST.md
docker-compose.yml
Dockerfile
HTTPS_SETUP.md
Readme.md
simple-compose.yml
SYNOLOGY_DEPLOYMENT.md
test-firebase-upload.js
test-image.txt
test-upload.js
test.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/test/avatar_new.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캐릭터 옵션 관리 테스트 - AR 명함 (새 컬러 옵션)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input,
        select,
        textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        input[type="color"],
        textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: '▶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-options {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .option-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .option-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        .option-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .option-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        /* 컬러 옵션 관련 스타일 */
        .color-option-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #f9f9f9;
        }

        .color-option-preview {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            margin-top: 10px;
        }

        .palette-preview {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            margin-top: 5px;
        }

        .color-options-display {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .color-option-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 15px;
            font-size: 12px;
        }

        .color-option-display img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
        }

        .color-option-display .palette-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎨 캐릭터 옵션 관리 테스트 페이지 (새 컬러 옵션)</h1>

        <!-- 인증 섹션 -->
        <div class="section auth-section">
            <h3>🔐 관리자 인증</h3>
            <p>캐릭터 옵션 관리 기능을 사용하려면 관리자 권한이 필요합니다.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="관리자 JWT 토큰 입력" style="width: 400px;">
                <button onclick="setAuthToken()">토큰 설정</button>
                <button onclick="getAdminToken()" class="btn-success">관리자 토큰 생성</button>
                <button onclick="clearAuthToken()" class="btn-secondary">토큰 초기화</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- 카테고리 관리 섹션 -->
        <div class="section">
            <h3>📁 캐릭터 옵션 카테고리 관리</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">새 카테고리 추가</button>
                <button onclick="loadCategories()" class="btn-secondary">새로고침</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- 카테고리 생성/수정 모달 -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">📁 새 카테고리 추가</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">

                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">카테고리 이름 *</label>
                        <input type="text" id="categoryName" required placeholder="예: 얼굴형, 눈, 코, 입">
                    </div>

                    <div class="form-group">
                        <label for="categoryType">카테고리 타입 *</label>
                        <input type="text" id="categoryType" required placeholder="예: face, eyes, nose, mouth">
                    </div>
                </div>

                <div class="form-group">
                    <label for="categoryOrder">순서</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>

                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success">저장</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 캐릭터 옵션 생성/수정 모달 -->
    <div id="optionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeOptionModal()">&times;</span>
            <h3 id="optionModalTitle">🎭 새 캐릭터 옵션 추가</h3>
            <form id="optionForm" enctype="multipart/form-data">
                <input type="hidden" id="optionCategoryId">
                <input type="hidden" id="optionId">

                <div class="form-row">
                    <div class="form-group">
                        <label for="optionName">옵션 이름 *</label>
                        <input type="text" id="optionName" required placeholder="예: 둥근 얼굴, 날카로운 눈">
                    </div>

                    <div class="form-group">
                        <label for="optionOrder">순서</label>
                        <input type="number" id="optionOrder" min="0" value="0">
                    </div>
                </div>

                <!-- 컬러 옵션 관리 섹션 -->
                <div class="form-group">
                    <label>컬러 옵션 관리 *</label>
                    <small>첫 번째 컬러 옵션의 이미지가 메인 이미지로 사용됩니다.</small>
                    <div id="colorOptionsContainer">
                        <!-- 컬러 옵션들이 여기에 동적으로 추가됩니다 -->
                    </div>
                    <button type="button" onclick="addColorOption()" class="btn-success" style="margin-top: 10px;">컬러 옵션
                        추가</button>
                </div>

                <div class="form-group">
                    <label for="optionThumbnail">썸네일 이미지 (300x300px 권장)</label>
                    <input type="file" id="optionThumbnail" accept="image/*">
                    <small>썸네일을 제공하지 않으면 첫 번째 리소스 이미지에서 자동 생성됩니다.</small>
                    <div id="thumbnailPreview"></div>
                </div>

                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeOptionModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success" id="submitOptionBtn">저장</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let expandedCategories = new Set();
        let colorOptionIndex = 0;

        // 인증 토큰 설정
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', '토큰을 입력해주세요.');
                return;
            }

            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', '✅ 관리자 토큰이 설정되었습니다.');

            loadCategories();
        }

        // 관리자 토큰 생성
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', '관리자 토큰을 생성하는 중...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);

                    showStatus('authStatus', 'success', `✅ 관리자 토큰이 생성되었습니다. (사용자: ${data.user.nameKr})`);

                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `❌ 토큰 생성 실패: ${data.message || '관리자 사용자를 찾을 수 없습니다.'}`);
                }

            } catch (error) {
                console.error('토큰 생성 오류:', error);
                showStatus('authStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 토큰 초기화
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', '🔄 토큰이 초기화되었습니다.');

            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // 페이지 로드 시 저장된 토큰 복원
        window.addEventListener('load', function () {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', '✅ 저장된 토큰을 불러왔습니다.');
                loadCategories();
            }
        });

        // 상태 메시지 표시
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // 카테고리 목록 로드
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', '❌ 먼저 관리자 토큰을 설정해주세요.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', '카테고리 목록을 불러오는 중...');

                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `✅ ${categories.length}개의 카테고리를 불러왔습니다.`);
                } else {
                    showStatus('categoryStatus', 'error', `❌ ${data.message || '카테고리 목록 로드 실패'}`);
                }

            } catch (error) {
                console.error('카테고리 목록 로드 오류:', error);
                showStatus('categoryStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 카테고리 렌더링
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>등록된 카테고리가 없습니다.</p>';
                return;
            }

            categories.forEach(category => {
                const categoryId = category._id || category.id;
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateOptionModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">옵션 추가</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">수정</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">삭제</button>
                        </div>
                    </div>
                    <div class="category-options">
                        <p><strong>옵션 수:</strong> ${category.options ? category.options.length : 0}개</p>
                        <div class="options-grid" id="options-${categoryId}">
                            ${renderOptions(category.options || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');

            card.classList.toggle('collapsed');

            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // 옵션 렌더링
        function renderOptions(options, categoryId) {
            if (!options || options.length === 0) {
                return '<p>등록된 옵션이 없습니다.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                const colorOptionsDisplay = option.color && Array.isArray(option.color) ?
                    `<div class="color-options-display">
                        ${option.color.map(colorOpt => {
                        const imageUrl = colorOpt.paletteImageUrl || colorOpt.imageUrl;
                        return `<div class="color-option-display">
                                <img src="${imageUrl}" alt="${colorOpt.colorName}" class="palette-circle">
                            </div>`;
                    }).join('')}
                    </div>` :
                    '<div style="font-size: 12px; color: #666;">컬러 옵션 없음</div>';

                return `
                    <div class="option-card">
                        <div class="option-image-container">
                            ${option.thumbnailUrl ? `<img src="${option.thumbnailUrl}" alt="${option.name}" class="option-image">` : '<div class="option-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">썸네일 없음</div>'}
                        </div>
                        <div class="option-name">${option.name}</div>
                        ${colorOptionsDisplay}
                        <div class="thumbnail-source">썸네일: ${option.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'}</div>
                        <div class="option-actions">
                            <button onclick="openEditOptionModal('${categoryId}', '${optionId}', '${option.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">수정</button>
                            <button onclick="deleteOption('${categoryId}', '${optionId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">삭제</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${optionId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">썸네일 재생성</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 컬러 옵션 추가
        function addColorOption() {
            colorOptionIndex++;
            const container = document.getElementById('colorOptionsContainer');
            const colorOptionDiv = document.createElement('div');
            colorOptionDiv.className = 'color-option-item';
            colorOptionDiv.setAttribute('data-index', colorOptionIndex);
            
            // 현재 카테고리 확인
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';
            
            // hair 카테고리용 추가 필드
            const hairFields = isHairCategory ? `
                <div class="form-group hair-resource-group" style="border: 2px dashed #e74c3c; padding: 15px; border-radius: 5px; background: #fef5f5;">
                    <label>💇‍♀️ 중간머리 이미지 (필수) *</label>
                    <input type="file" class="hair-middle-image" accept="image/*" onchange="previewHairResourceImage(this, 'middle')">
                    <div class="hair-middle-preview"></div>
                </div>
                <div class="form-group hair-resource-group" style="border: 2px dashed #3498db; padding: 15px; border-radius: 5px; background: #f0f8ff;">
                    <label>💇‍♀️ 뒷머리 이미지 (선택)</label>
                    <input type="file" class="hair-back-image" accept="image/*" onchange="previewHairResourceImage(this, 'back')">
                    <div class="hair-back-preview"></div>
                    <small style="color: #666;">없으면 중간머리만 사용됩니다</small>
                </div>
            ` : '';

            colorOptionDiv.innerHTML = `
                <div class="form-row">
                    <div class="form-group">
                        <label>컬러 이름 *</label>
                        <input type="text" class="color-name" placeholder="예: 빨강, 파랑" required>
                    </div>
                    <div class="form-group">
                        <label>컬러 팔레트 (128x128)</label>
                        <input type="file" class="palette-image" accept="image/*" onchange="previewPaletteImage(this)">
                        <small>팔레트 이미지를 설정하지 않으면 기본 이미지를 동그랗게 표시합니다.</small>
                        <div class="palette-preview-container"></div>
                    </div>
                    ${!isHairCategory ? `
                    <div class="form-group">
                        <label>리소스 이미지 파일 *</label>
                        <input type="file" class="color-image" accept="image/*" required onchange="previewColorImage(this)">
                        <div class="color-preview"></div>
                    </div>
                    ` : `
                    <div class="form-group" style="background: #fff3cd; padding: 10px; border-radius: 5px; border: 1px solid #ffeaa7;">
                        <div style="color: #856404; font-size: 14px;">
                            💡 <strong>Hair 카테고리 안내:</strong><br>
                            중간머리 이미지가 기본 이미지로 자동 설정됩니다.<br>
                            별도의 기본 이미지 업로드는 불필요합니다.
                        </div>
                    </div>
                    `}
                    
                    ${hairFields}
                    
                    <div class="form-group" style="width: auto;">
                        <button type="button" onclick="removeColorOption(${colorOptionIndex})" class="btn-danger" style="margin-top: 24px;">삭제</button>
                    </div>
                </div>
            `;
            container.appendChild(colorOptionDiv);
        }

        // 컬러 옵션 삭제
        function removeColorOption(index) {
            const colorOption = document.querySelector(`[data-index="${index}"]`);
            if (colorOption) {
                colorOption.remove();
            }

            // 최소 하나의 컬러 옵션은 유지
            const remainingOptions = document.querySelectorAll('.color-option-item');
            if (remainingOptions.length === 0) {
                addColorOption();
            }
        }

        // 컬러 이미지 미리보기
        function previewColorImage(input) {
            const previewDiv = input.parentNode.querySelector('.color-preview');
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    previewDiv.innerHTML = `<img src="${e.target.result}" alt="미리보기" class="color-option-preview">`;
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                previewDiv.innerHTML = '';
            }
        }

        // Hair 리소스 이미지 미리보기
        function previewHairResourceImage(input, type) {
            const file = input.files[0];
            const colorOption = input.closest('.color-option-item');
            const preview = colorOption.querySelector(`.hair-${type}-preview`);
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `
                        <img src="${e.target.result}" alt="${type === 'middle' ? '중간머리' : '뒷머리'} 미리보기" 
                             style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                        <br><small style="color: #666;">${file.name}</small>
                    `;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        }

        // 팔레트 이미지 미리보기
        function previewPaletteImage(input) {
            const previewContainer = input.parentNode.querySelector('.palette-preview-container');
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    previewContainer.innerHTML = `<img src="${e.target.result}" alt="팔레트 미리보기" class="palette-circle" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-top: 5px;">`;
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                previewContainer.innerHTML = '';
            }
        }

        // 컬러 옵션 데이터 수집
        function collectColorOptions() {
            const colorOptions = [];
            const colorOptionItems = document.querySelectorAll('.color-option-item');
            
            console.log(`🔍 collectColorOptions 시작 - 총 ${colorOptionItems.length}개 옵션 아이템 발견`);
            
            // 카테고리 타입 확인
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            colorOptionItems.forEach((item, index) => {
                const colorName = item.querySelector('.color-name').value.trim();
                // Hair 카테고리가 아닌 경우만 기본 이미지 파일 수집
                const imageFile = !isHairCategory ? item.querySelector('.color-image')?.files[0] : null;
                const paletteFile = item.querySelector('.palette-image').files[0];
                const existingImageUrl = item.getAttribute('data-image-url'); // 수정 모드용
                const existingPaletteUrl = item.getAttribute('data-palette-url'); // 수정 모드용
                
                // 기존 resourceImages 데이터 확인 (수정 모드용)
                let existingResourceImages = null;
                if (isHairCategory) {
                    const middlePreview = item.querySelector('.hair-middle-preview img');
                    const backPreview = item.querySelector('.hair-back-preview img');
                    if (middlePreview || backPreview) {
                        existingResourceImages = {};
                        if (middlePreview) existingResourceImages.hairMiddleImageUrl = middlePreview.src;
                        if (backPreview) existingResourceImages.hairBackImageUrl = backPreview.src;
                    }
                }

                // hair 카테고리인 경우 추가 검증 및 데이터 수집
                let hairMiddleFile = null;
                let hairBackFile = null;
                
                if (isHairCategory) {
                    const middleInput = item.querySelector('.hair-middle-image');
                    const backInput = item.querySelector('.hair-back-image');
                    
                    console.log(`🔍 Hair 디버깅 - 컬러 ${index}:`, {
                        colorName,
                        middleInput: middleInput ? 'found' : 'not found',
                        backInput: backInput ? 'found' : 'not found',
                        middleFiles: middleInput?.files?.length || 0,
                        backFiles: backInput?.files?.length || 0
                    });
                    
                    hairMiddleFile = middleInput?.files[0];
                    hairBackFile = backInput?.files[0];
                    
                    // 중간머리 필수 검증 (새로 추가하는 경우만)
                    if (!hairMiddleFile && !existingResourceImages) {
                        throw new Error(`컬러 옵션 "${colorName}"에 중간머리 이미지가 필요합니다.`);
                    }
                }

                // Hair 카테고리: colorName + 중간머리 파일이 있으면 됨
                // 일반 카테고리: colorName + (imageFile || existingImageUrl) 필요
                const isValidColorOption = colorName && (
                    isHairCategory ? (hairMiddleFile || existingResourceImages) : (imageFile || existingImageUrl)
                );
                
                // 디버깅 로그
                if (isHairCategory) {
                    console.log(`🔍 Hair 옵션 검증 - 컬러 ${index}:`, {
                        colorName,
                        hasMiddleFile: !!hairMiddleFile,
                        hasExistingData: !!existingResourceImages,
                        isValid: isValidColorOption
                    });
                }
                
                if (isValidColorOption) {
                    const colorOption = {
                        colorName: colorName,
                        imageFile: imageFile,
                        paletteFile: paletteFile,
                        imageUrl: existingImageUrl,
                        paletteImageUrl: existingPaletteUrl
                    };
                    
                    // hair 카테고리인 경우 hair 파일들 및 기존 데이터 추가
                    if (isHairCategory) {
                        colorOption.hairMiddleFile = hairMiddleFile;
                        colorOption.hairBackFile = hairBackFile;
                        if (existingResourceImages) {
                            colorOption.resourceImages = existingResourceImages;
                        }
                    }
                    
                    colorOptions.push(colorOption);
                } else {
                    console.log(`❌ 유효하지 않은 컬러 옵션 - 컬러 ${index}:`, {
                        colorName,
                        hasImageFile: !!imageFile,
                        hasExistingImageUrl: !!existingImageUrl,
                        hasMiddleFile: !!hairMiddleFile,
                        hasExistingResourceImages: !!existingResourceImages,
                        isHairCategory
                    });
                }
            });

            console.log(`🔍 collectColorOptions 완료 - 수집된 유효한 옵션: ${colorOptions.length}개`);
            return colorOptions;
        }

        // 컬러 옵션 로드 (수정 모드용)
        function loadColorOptions(colorOptions) {
            const container = document.getElementById('colorOptionsContainer');
            container.innerHTML = '';
            colorOptionIndex = 0;

            if (!colorOptions || colorOptions.length === 0) {
                addColorOption();
                return;
            }

            // 카테고리 타입 확인
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            colorOptions.forEach((colorOption, index) => {
                console.log(`🔍 loadColorOptions - 컬러 옵션 ${index}:`, {
                    colorName: colorOption.colorName,
                    imageUrl: colorOption.imageUrl,
                    resourceImages: colorOption.resourceImages,
                    isHairCategory
                });
                
                colorOptionIndex++;
                const colorOptionDiv = document.createElement('div');
                colorOptionDiv.className = 'color-option-item';
                colorOptionDiv.setAttribute('data-index', colorOptionIndex);
                colorOptionDiv.setAttribute('data-image-url', colorOption.imageUrl);
                if (colorOption.paletteImageUrl) {
                    colorOptionDiv.setAttribute('data-palette-url', colorOption.paletteImageUrl);
                }

                const palettePreview = colorOption.paletteImageUrl ?
                    `<img src="${colorOption.paletteImageUrl}" alt="현재 팔레트" class="palette-circle" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-top: 5px;" onerror="this.style.display='none'; this.nextElementSibling.textContent='팔레트 이미지 로드 실패';">
                     <div style="font-size: 12px; color: #666; margin-top: 5px;">현재 팔레트 이미지</div>` : '';

                // hair 카테고리용 기존 데이터 미리보기
                const resourceImages = colorOption.resourceImages || {};
                const backHair = resourceImages.hairBackImageUrl || null;      // 뒷머리
                const middleHair = resourceImages.hairMiddleImageUrl || null;  // 중간머리

                const hairFields = isHairCategory ? `
                    <div class="form-group hair-resource-group" style="border: 2px dashed #e74c3c; padding: 15px; border-radius: 5px; background: #fef5f5;">
                        <label>💇‍♀️ 중간머리 이미지 (필수) *</label>
                        <input type="file" class="hair-middle-image" accept="image/*" onchange="previewHairResourceImage(this, 'middle')">
                        <div class="hair-middle-preview">
                            ${middleHair ? `
                                <img src="${middleHair}" alt="현재 중간머리" 
                                     style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                                <br><small style="color: #666;">현재 중간머리</small>
                                <br><small style="color: #999;">새 파일 선택 시 교체됩니다</small>
                            ` : ''}
                        </div>
                    </div>
                    <div class="form-group hair-resource-group" style="border: 2px dashed #3498db; padding: 15px; border-radius: 5px; background: #f0f8ff;">
                        <label>💇‍♀️ 뒷머리 이미지 (선택)</label>
                        <input type="file" class="hair-back-image" accept="image/*" onchange="previewHairResourceImage(this, 'back')">
                        <div class="hair-back-preview">
                            ${backHair ? `
                                <img src="${backHair}" alt="현재 뒷머리" 
                                     style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                                <br><small style="color: #666;">현재 뒷머리</small>
                                <br><small style="color: #999;">새 파일 선택 시 교체됩니다</small>
                            ` : '<div style="color: #999; text-align: center; padding: 10px;"><div>현재 뒷머리 없음</div><small>파일 선택 시 추가됩니다</small></div>'}
                        </div>
                        <small style="color: #666;">없으면 중간머리만 사용됩니다</small>
                    </div>
                ` : '';

                colorOptionDiv.innerHTML = `
                    <div class="form-row">
                        <div class="form-group">
                            <label>컬러 이름 *</label>
                            <input type="text" class="color-name" placeholder="예: 빨강, 파랑" value="${colorOption.colorName}" required>
                        </div>
                        ${!isHairCategory ? `
                        <div class="form-group">
                            <label>리소스 이미지 파일</label>
                            <input type="file" class="color-image" accept="image/*" onchange="previewColorImage(this)">
                            <div class="color-preview">
                                <img src="${colorOption.imageUrl}" alt="현재 이미지" class="color-option-preview">
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">현재 이미지 (새 파일을 선택하면 교체됩니다)</div>
                            </div>
                        </div>
                        ` : `
                        <div class="form-group" style="background: #fff3cd; padding: 10px; border-radius: 5px; border: 1px solid #ffeaa7;">
                            <div style="color: #856404; font-size: 14px;">
                                💡 <strong>Hair 카테고리 안내:</strong><br>
                                중간머리 이미지가 기본 이미지로 자동 설정됩니다.<br>
                                별도의 기본 이미지 업로드는 불필요합니다.
                            </div>
                        </div>
                        `}
                        <div class="form-group">
                            <label>컬러 팔레트 (128x128)</label>
                            <input type="file" class="palette-image" accept="image/*" onchange="previewPaletteImage(this)">
                            <small>팔레트 이미지를 설정하지 않으면 기본 이미지를 동그랗게 표시합니다.</small>
                            <div class="palette-preview-container">${palettePreview}</div>
                        </div>
                        
                        ${hairFields}
                        
                        <div class="form-group" style="width: auto;">
                            <button type="button" onclick="removeColorOption(${colorOptionIndex})" class="btn-danger" style="margin-top: 24px;">삭제</button>
                        </div>
                    </div>
                `;
                container.appendChild(colorOptionDiv);
            });
        }

        // 카테고리 생성 모달 열기
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = '📁 새 카테고리 추가';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';

            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 모달 닫기
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 옵션 생성 모달 열기
        function openCreateOptionModal(categoryId) {
            document.getElementById('optionModalTitle').textContent = '🎭 새 캐릭터 옵션 추가';
            document.getElementById('optionForm').reset();
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = '';
            document.getElementById('thumbnailPreview').innerHTML = '';

            // 컬러 옵션 초기화
            const container = document.getElementById('colorOptionsContainer');
            container.innerHTML = '';
            colorOptionIndex = 0;
            addColorOption(); // 첫 번째 컬러 옵션 추가

            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 옵션 수정 모달 열기
        function openEditOptionModal(categoryId, optionId, optionName) {
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.options) {
                alert('카테고리 또는 옵션을 찾을 수 없습니다.');
                return;
            }

            const option = category.options.find(opt => (opt._id || opt.id) === optionId);
            if (!option) {
                alert('옵션을 찾을 수 없습니다.');
                return;
            }

            console.log(`🔍 openEditOptionModal - 옵션 데이터:`, {
                optionName: option.name,
                categoryType: category.type,
                colorOptions: option.color,
                hasResourceImages: option.color?.some(c => c.resourceImages)
            });

            document.getElementById('optionModalTitle').textContent = `🎭 캐릭터 옵션 수정: ${optionName}`;
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = optionId;
            document.getElementById('optionName').value = option.name;
            document.getElementById('optionOrder').value = option.order || 0;

            // 컬러 옵션 로드
            loadColorOptions(option.color || []);

            // 썸네일 미리보기
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            thumbnailPreview.innerHTML = option.thumbnailUrl ?
                `<img src="${option.thumbnailUrl}" alt="현재 썸네일" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>현재 썸네일 (${option.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'})</small>` :
                '<p>현재 썸네일 없음</p>';

            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 옵션 모달 닫기
        function closeOptionModal() {
            const modal = document.getElementById('optionModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 썸네일 미리보기 처리
        document.getElementById('optionThumbnail').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');

            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="썸네일 미리보기" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // 카테고리 폼 제출
        document.getElementById('categoryForm').addEventListener('submit', async function (e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;

            // 제출 버튼 찾기 및 비활성화
            const submitBtn = e.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? '수정 중...' : '저장 중...';

            try {
                const formData = {
                    name: document.getElementById('categoryName').value,
                    type: document.getElementById('categoryType').value,
                    order: parseInt(document.getElementById('categoryOrder').value) || 0
                };

                const url = isEdit ?
                    `/api/admin/characters/categories/${categoryId}` :
                    '/api/admin/characters/categories';

                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 카테고리가 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            } finally {
                // 버튼 상태 복원
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // 옵션 폼 제출
        document.getElementById('optionForm').addEventListener('submit', async function (e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('optionCategoryId').value;
            const optionId = document.getElementById('optionId').value;
            const isEdit = !!optionId;
            const optionName = document.getElementById('optionName').value;

            // 카테고리 타입 확인
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            if (!optionName || optionName.trim() === '') {
                alert('옵션 이름을 입력해주세요.');
                return;
            }

            // 컬러 옵션 수집 및 검증
            let colorOptions;
            try {
                colorOptions = collectColorOptions();
                if (colorOptions.length === 0) {
                    alert('최소 하나의 컬러 옵션이 필요합니다.');
                    return;
                }
            } catch (error) {
                alert(error.message);
                return;
            }

            // 제출 버튼 찾기 및 비활성화
            const submitBtn = document.getElementById('submitOptionBtn');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? '수정 중...' : '저장 중...';

            try {
                // 이미지 업로드 및 컬러 옵션 준비
                const uploadedColorOptions = [];
                for (let colorOption of colorOptions) {
                    if (isHairCategory && colorOption.hairMiddleFile) {
                        // Hair 카테고리: 중간머리 이미지 업로드
                        const imageFormData = new FormData();
                        imageFormData.append('file', colorOption.hairMiddleFile);

                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: imageFormData
                        });

                        if (uploadResponse.ok) {
                            const uploadData = await uploadResponse.json();
                            uploadedColorOptions.push({
                                colorName: colorOption.colorName,
                                imageUrl: uploadData.url, // 중간머리를 기본 이미지로 사용
                                paletteImageUrl: colorOption.paletteImageUrl || ''
                            });
                        } else {
                            throw new Error(`중간머리 이미지 업로드 실패: ${colorOption.colorName}`);
                        }
                    } else if (colorOption.imageFile) {
                        // 일반 카테고리: 새 이미지 업로드
                        const imageFormData = new FormData();
                        imageFormData.append('file', colorOption.imageFile);

                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: imageFormData
                        });

                        if (uploadResponse.ok) {
                            const uploadData = await uploadResponse.json();
                            uploadedColorOptions.push({
                                colorName: colorOption.colorName,
                                imageUrl: uploadData.url,
                                paletteImageUrl: colorOption.paletteImageUrl || ''
                            });
                        } else {
                            throw new Error(`이미지 업로드 실패: ${colorOption.colorName}`);
                        }
                    } else if (colorOption.imageUrl) {
                        // 기존 이미지 유지
                        uploadedColorOptions.push({
                            colorName: colorOption.colorName,
                            imageUrl: colorOption.imageUrl,
                            paletteImageUrl: colorOption.paletteImageUrl || ''
                        });
                    }
                }

                console.log(`🔍 uploadedColorOptions 생성 완료:`, uploadedColorOptions);

                // 옵션 데이터 준비
                const formData = new FormData();
                formData.append('name', optionName);
                formData.append('colorOptions', JSON.stringify(uploadedColorOptions));
                formData.append('order', document.getElementById('optionOrder').value);

                const thumbnailFile = document.getElementById('optionThumbnail').files[0];
                if (thumbnailFile) {
                    formData.append('thumbnail', thumbnailFile);
                }

                // 팔레트 이미지들 및 hair 파일들 추가
                colorOptions.forEach((colorOption, index) => {
                    if (colorOption.paletteFile) {
                        formData.append('palette', colorOption.paletteFile);
                    }
                    
                    // Hair 카테고리인 경우 각 컬러별 hair 파일들 추가
                    if (isHairCategory) {
                        console.log(`📤 FormData 추가 - 컬러 ${index}:`, {
                            colorName: colorOption.colorName,
                            hasMiddleFile: !!colorOption.hairMiddleFile,
                            hasBackFile: !!colorOption.hairBackFile,
                            middleFileName: colorOption.hairMiddleFile?.name,
                            backFileName: colorOption.hairBackFile?.name
                        });
                        
                        if (colorOption.hairMiddleFile) {
                            formData.append(`hair_${index}_middle`, colorOption.hairMiddleFile);
                            console.log(`✅ 중간머리 파일 추가: hair_${index}_middle`);
                        }
                        if (colorOption.hairBackFile) {
                            formData.append(`hair_${index}_back`, colorOption.hairBackFile);
                            console.log(`✅ 뒷머리 파일 추가: hair_${index}_back`);
                        }
                    }
                });

                const url = isEdit ?
                    `/api/admin/characters/categories/${categoryId}/options/${optionId}` :
                    `/api/admin/characters/categories/${categoryId}/options`;

                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 옵션이 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeOptionModal();
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('옵션 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            } finally {
                // 버튼 상태 복원
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // 카테고리 수정
        function editCategory(categoryId) {
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);

            if (!category) {
                alert('카테고리를 찾을 수 없습니다.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = '📁 카테고리 수정';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;

            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 삭제
        async function deleteCategory(categoryId) {
            if (!confirm('정말로 이 카테고리를 삭제하시겠습니까? 모든 옵션도 함께 삭제됩니다.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 카테고리가 성공적으로 삭제되었습니다.');
                    loadCategories();
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 옵션 삭제
        async function deleteOption(categoryId, optionId) {
            if (!confirm('정말로 이 옵션을 삭제하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 옵션이 성공적으로 삭제되었습니다.');
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('옵션 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 특정 카테고리의 옵션만 업데이트
        async function updateCategoryOptions(categoryId) {
            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        categories[categoryIndex] = data;

                        const optionsGrid = document.getElementById(`options-${categoryId}`);
                        if (optionsGrid) {
                            optionsGrid.innerHTML = renderOptions(data.options || [], categoryId);
                        }
                    }
                } else {
                    console.error('카테고리 업데이트 실패:', data.message);
                }

            } catch (error) {
                console.error('카테고리 업데이트 오류:', error);
            }
        }

        // 썸네일 재생성
        async function regenerateThumbnail(categoryId, optionId) {
            if (!confirm('이 옵션의 썸네일을 재생성하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}/thumbnail/regenerate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 썸네일이 성공적으로 재생성되었습니다.');
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ 썸네일 재생성 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('썸네일 재생성 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function (event) {
            const categoryModal = document.getElementById('categoryModal');
            const optionModal = document.getElementById('optionModal');

            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === optionModal) {
                closeOptionModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/avatar.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>아바타 관리 테스트 - AR 명함</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], input[type="color"], textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: '▶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-options {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .option-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .option-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        .option-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .option-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .multi-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background-color: #fafafa;
        }

        .multi-upload-container.dragover {
            border-color: #007bff;
            background-color: #e3f2fd;
        }

        .file-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .file-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: white;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .file-preview {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-info {
            flex: 1;
        }

        .file-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .remove-file {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-file:hover {
            background-color: #c82333;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .batch-input {
            flex: 1;
            min-width: 150px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #28a745;
            transition: width 0.3s ease;
        }

        .upload-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎨 아바타 관리 테스트 페이지</h1>

        <!-- 인증 섹션 -->
        <div class="section auth-section">
            <h3>🔐 관리자 인증</h3>
            <p>아바타 관리 기능을 사용하려면 관리자 권한이 필요합니다.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="관리자 JWT 토큰 입력" style="width: 400px;">
                <button onclick="setAuthToken()">토큰 설정</button>
                <button onclick="getAdminToken()" class="btn-success">관리자 토큰 생성</button>
                <button onclick="clearAuthToken()" class="btn-secondary">토큰 초기화</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- 카테고리 관리 섹션 -->
        <div class="section">
            <h3>📁 아바타 카테고리 관리</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">새 카테고리 추가</button>
                <button onclick="loadCategories()" class="btn-secondary">새로고침</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- 카테고리 생성/수정 모달 -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">📁 새 카테고리 추가</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">카테고리 이름 *</label>
                        <input type="text" id="categoryName" required placeholder="예: 얼굴형, 눈, 코, 입">
                    </div>
                    
                    <div class="form-group">
                        <label for="categoryType">카테고리 타입 *</label>
                        <input type="text" id="categoryType" required placeholder="예: face, eyes, nose, mouth">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="categoryOrder">순서</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success">저장</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 아바타 옵션 생성/수정 모달 -->
    <div id="optionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeOptionModal()">&times;</span>
            <h3 id="optionModalTitle">🎭 새 아바타 옵션 추가</h3>
            <form id="optionForm" enctype="multipart/form-data">
                <input type="hidden" id="optionCategoryId">
                <input type="hidden" id="optionId">
                
                <!-- 단일 옵션 추가 모드 -->
                <div id="singleOptionMode">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="optionName">옵션 이름 *</label>
                            <input type="text" id="optionName" required placeholder="예: 둥근 얼굴, 날카로운 눈">
                        </div>
                        
                        <div class="form-group">
                            <label for="optionColor">색상</label>
                            <input type="color" id="optionColor" value="#000000">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="optionOrder">순서</label>
                        <input type="number" id="optionOrder" min="0" value="0">
                    </div>
                    
                    <div class="form-group">
                        <label for="optionImage">아바타 이미지 * (512x512px 권장)</label>
                        <input type="file" id="optionImage" accept="image/*">
                        <div id="imagePreview"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="optionThumbnail">썸네일 이미지 (300x300px 권장)</label>
                        <input type="file" id="optionThumbnail" accept="image/*">
                        <small>썸네일을 제공하지 않으면 원본 이미지에서 자동 생성됩니다.</small>
                        <div id="thumbnailPreview"></div>
                    </div>
                </div>

                <!-- 다중 옵션 추가 모드 -->
                <div id="multiOptionMode" style="display: none;">
                    <div class="form-group">
                        <label>이미지 파일 선택 (여러 개 선택 가능)</label>
                        <div class="multi-upload-container" id="multiUploadContainer">
                            <p>여기에 파일을 드래그하거나 클릭하여 선택하세요</p>
                            <input type="file" id="multiOptionImages" accept="image/*" multiple style="display: none;">
                            <button type="button" onclick="document.getElementById('multiOptionImages').click()" class="btn-success">파일 선택</button>
                        </div>
                    </div>

                    <!-- 일괄 설정 -->
                    <div class="form-group">
                        <label>일괄 설정</label>
                        <div class="batch-controls">
                            <input type="color" id="batchColor" value="#000000" class="batch-input" placeholder="공통 색상">
                            <input type="number" id="batchOrderStart" min="0" value="0" class="batch-input" placeholder="시작 순서">
                            <button type="button" onclick="applyBatchSettings()" class="btn-secondary">일괄 적용</button>
                        </div>
                    </div>

                    <!-- 파일 목록 -->
                    <div id="fileItemsContainer" class="file-items"></div>

                    <!-- 업로드 진행률 -->
                    <div id="uploadProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="upload-status" id="uploadStatus"></div>
                    </div>
                </div>
                
                <!-- 모드 전환 버튼 -->
                <div style="text-align: center; margin: 20px 0;">
                    <button type="button" id="toggleModeBtn" onclick="toggleUploadMode()" class="btn-secondary">다중 업로드 모드</button>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeOptionModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success" id="submitOptionBtn">저장</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let isMultiMode = false;
        let selectedFiles = [];
        let uploadProgress = 0;
        let expandedCategories = new Set(); // 열린 카테고리 상태 추적

        // 인증 토큰 설정
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', '토큰을 입력해주세요.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', '✅ 관리자 토큰이 설정되었습니다.');
            
            // 토큰 설정 후 카테고리 목록 자동 로드
            loadCategories();
        }

        // 관리자 토큰 생성
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', '관리자 토큰을 생성하는 중...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `✅ 관리자 토큰이 생성되었습니다. (사용자: ${data.user.nameKr})`);
                    
                    // 토큰 생성 후 카테고리 목록 자동 로드
                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `❌ 토큰 생성 실패: ${data.message || '관리자 사용자를 찾을 수 없습니다.'}`);
                }

            } catch (error) {
                console.error('토큰 생성 오류:', error);
                showStatus('authStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 토큰 초기화
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', '🔄 토큰이 초기화되었습니다.');
            
            // 카테고리 목록 숨기기
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // 페이지 로드 시 저장된 토큰 복원
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', '✅ 저장된 토큰을 불러왔습니다.');
                loadCategories();
            }

            // 드래그 앤 드롭 이벤트 설정
            setupDragAndDrop();
        });

        // 상태 메시지 표시
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // 카테고리 목록 로드
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', '❌ 먼저 관리자 토큰을 설정해주세요.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', '카테고리 목록을 불러오는 중...');

                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `✅ ${categories.length}개의 카테고리를 불러왔습니다.`);
                } else {
                    showStatus('categoryStatus', 'error', `❌ ${data.message || '카테고리 목록 로드 실패'}`);
                }

            } catch (error) {
                console.error('카테고리 목록 로드 오류:', error);
                showStatus('categoryStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 카테고리 렌더링
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>등록된 카테고리가 없습니다.</p>';
                return;
            }

            categories.forEach(category => {
                // ID 필드 확인 - _id 또는 id 사용
                const categoryId = category._id || category.id;
                console.log('Category object:', category);
                console.log('Category ID:', categoryId);
                
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateOptionModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">옵션 추가</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">수정</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">삭제</button>
                        </div>
                    </div>
                    <div class="category-options">
                        <p><strong>옵션 수:</strong> ${category.options ? category.options.length : 0}개</p>
                        <div class="options-grid" id="options-${categoryId}">
                            ${renderOptions(category.options || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');
            
            card.classList.toggle('collapsed');
            
            // 상태 추적
            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // 옵션 렌더링
        function renderOptions(options, categoryId) {
            if (!options || options.length === 0) {
                return '<p>등록된 옵션이 없습니다.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                return `
                    <div class="option-card">
                        <div class="option-image-container">
                            ${option.thumbnailUrl ? `<img src="${option.thumbnailUrl}" alt="${option.name}" class="option-image">` : '<div class="option-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">썸네일 없음</div>'}
                        </div>
                        <div class="option-name">${option.name}</div>
                        <div class="thumbnail-source">썸네일: ${option.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'}</div>
                        <div class="option-actions">
                            <button onclick="openEditOptionModal('${categoryId}', '${optionId}', '${option.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">수정</button>
                            <button onclick="deleteOption('${categoryId}', '${optionId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">삭제</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${optionId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">썸네일 재생성</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 업로드 모드 전환
        function toggleUploadMode() {
            isMultiMode = !isMultiMode;
            const singleMode = document.getElementById('singleOptionMode');
            const multiMode = document.getElementById('multiOptionMode');
            const toggleBtn = document.getElementById('toggleModeBtn');
            const submitBtn = document.getElementById('submitOptionBtn');

            // 단일 모드의 필수 입력 필드들
            const singleModeRequiredFields = [
                document.getElementById('optionName'),
                document.getElementById('optionImage')
            ];

            if (isMultiMode) {
                singleMode.style.display = 'none';
                multiMode.style.display = 'block';
                toggleBtn.textContent = '단일 업로드 모드';
                submitBtn.textContent = '일괄 업로드';
                
                // 단일 모드 필드들의 required 속성 제거
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.removeAttribute('required');
                    }
                });
            } else {
                singleMode.style.display = 'block';
                multiMode.style.display = 'none';
                toggleBtn.textContent = '다중 업로드 모드';
                submitBtn.textContent = '저장';
                
                // 단일 모드 필드들의 required 속성 복원
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.setAttribute('required', 'required');
                    }
                });
                
                // 선택된 파일들 초기화
                selectedFiles = [];
                document.getElementById('fileItemsContainer').innerHTML = '';
            }
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const container = document.getElementById('multiUploadContainer');
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.classList.add('dragover');
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                addFiles(files);
            });

            container.addEventListener('click', () => {
                document.getElementById('multiOptionImages').click();
            });

            document.getElementById('multiOptionImages').addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                addFiles(files);
            });
        }

        // 파일 추가
        function addFiles(files) {
            files.forEach(file => {
                const fileId = Date.now() + Math.random();
                const fileData = {
                    id: fileId,
                    file: file,
                    name: file.name.replace(/\.[^/.]+$/, ""), // 확장자 제거
                    color: '#000000',
                    order: selectedFiles.length,
                    thumbnailFile: null
                };
                
                selectedFiles.push(fileData);
            });
            
            renderFileItems();
        }

        // 파일 아이템 렌더링
        function renderFileItems() {
            const container = document.getElementById('fileItemsContainer');
            container.innerHTML = '';

            selectedFiles.forEach(fileData => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <img src="${URL.createObjectURL(fileData.file)}" alt="미리보기" class="file-preview">
                    <div class="file-info">
                        <div class="form-group">
                            <label>옵션 이름</label>
                            <input type="text" value="${fileData.name}" onchange="updateFileName(${fileData.id}, this.value)">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>색상</label>
                                <input type="color" value="${fileData.color}" onchange="updateFileColor(${fileData.id}, this.value)">
                            </div>
                            <div class="form-group">
                                <label>순서</label>
                                <input type="number" value="${fileData.order}" min="0" onchange="updateFileOrder(${fileData.id}, this.value)">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>썸네일 (선택사항)</label>
                            <input type="file" accept="image/*" onchange="updateFileThumbnail(${fileData.id}, this.files[0])">
                        </div>
                    </div>
                    <div class="file-actions">
                        <button type="button" class="remove-file" onclick="removeFile(${fileData.id})">삭제</button>
                    </div>
                `;
                container.appendChild(fileItem);
            });
        }

        // 파일 정보 업데이트 함수들
        function updateFileName(fileId, name) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.name = name;
        }

        function updateFileColor(fileId, color) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.color = color;
        }

        function updateFileOrder(fileId, order) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.order = parseInt(order);
        }

        function updateFileThumbnail(fileId, thumbnailFile) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.thumbnailFile = thumbnailFile;
        }

        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(f => f.id !== fileId);
            renderFileItems();
        }

        // 일괄 설정 적용
        function applyBatchSettings() {
            const batchColor = document.getElementById('batchColor').value;
            const batchOrderStart = parseInt(document.getElementById('batchOrderStart').value) || 0;

            selectedFiles.forEach((fileData, index) => {
                fileData.color = batchColor;
                fileData.order = batchOrderStart + index;
            });

            renderFileItems();
        }

        // 카테고리 생성 모달 열기
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = '📁 새 카테고리 추가';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 모달 닫기
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 옵션 생성 모달 열기
        function openCreateOptionModal(categoryId) {
            document.getElementById('optionModalTitle').textContent = '🎭 새 아바타 옵션 추가';
            document.getElementById('optionForm').reset();
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = '';
            document.getElementById('imagePreview').innerHTML = '';
            document.getElementById('thumbnailPreview').innerHTML = '';
            
            // 모드 초기화 - 단일 모드로 시작
            isMultiMode = false;
            document.getElementById('singleOptionMode').style.display = 'block';
            document.getElementById('multiOptionMode').style.display = 'none';
            document.getElementById('toggleModeBtn').textContent = '다중 업로드 모드';
            document.getElementById('submitOptionBtn').textContent = '저장';
            
            // 단일 모드 필드들의 required 속성 복원
            const optionNameField = document.getElementById('optionName');
            const optionImageField = document.getElementById('optionImage');
            if (optionNameField) optionNameField.setAttribute('required', 'required');
            if (optionImageField) optionImageField.setAttribute('required', 'required');
            
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
            
            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 옵션 수정 모달 열기
        function openEditOptionModal(categoryId, optionId, optionName) {
            // 옵션 정보를 찾기 위해 카테고리에서 옵션 찾기
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.options) {
                alert('카테고리 또는 옵션을 찾을 수 없습니다.');
                return;
            }

            const option = category.options.find(opt => (opt._id || opt.id) === optionId);
            if (!option) {
                alert('옵션을 찾을 수 없습니다.');
                return;
            }

            document.getElementById('optionModalTitle').textContent = `🎭 아바타 옵션 수정: ${optionName}`;
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = optionId;
            document.getElementById('optionName').value = option.name;
            document.getElementById('optionColor').value = option.color || '#000000';
            document.getElementById('optionOrder').value = option.order || 0;
            
            // 수정 모드에서는 단일 모드만 사용
            isMultiMode = false;
            document.getElementById('singleOptionMode').style.display = 'block';
            document.getElementById('multiOptionMode').style.display = 'none';
            document.getElementById('toggleModeBtn').style.display = 'none'; // 수정 모드에서는 모드 전환 숨김
            document.getElementById('submitOptionBtn').textContent = '저장';
            
            // 수정 모드에서는 이미지가 필수가 아님 (기존 이미지 유지 가능)
            const optionNameField = document.getElementById('optionName');
            const optionImageField = document.getElementById('optionImage');
            if (optionNameField) optionNameField.setAttribute('required', 'required');
            if (optionImageField) optionImageField.removeAttribute('required');
            
            // 이미지 미리보기
            const imagePreview = document.getElementById('imagePreview');
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            
            imagePreview.innerHTML = option.imageUrl ? 
                `<img src="${option.imageUrl}" alt="현재 이미지" class="image-preview">` : 
                '<p>현재 이미지 없음</p>';
                
            thumbnailPreview.innerHTML = option.thumbnailUrl ? 
                `<img src="${option.thumbnailUrl}" alt="현재 썸네일" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>현재 썸네일 (${option.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'})</small>` : 
                '<p>현재 썸네일 없음</p>';
            
            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 옵션 모달 닫기
        function closeOptionModal() {
            const modal = document.getElementById('optionModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            
            // 모드 전환 버튼 다시 표시
            document.getElementById('toggleModeBtn').style.display = 'inline-block';
            
            // 선택된 파일들 초기화
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
        }

        // 이미지 미리보기 처리
        document.getElementById('optionImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('imagePreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="이미지 미리보기" class="image-preview">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        document.getElementById('optionThumbnail').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="썸네일 미리보기" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // 진행률 업데이트
        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('uploadStatus').textContent = `${current}/${total} 업로드 중...`;
        }

        // 카테고리 폼 제출
        document.getElementById('categoryForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;
            
            const formData = {
                name: document.getElementById('categoryName').value,
                type: document.getElementById('categoryType').value,
                order: parseInt(document.getElementById('categoryOrder').value) || 0
            };

            try {
                const url = isEdit ? 
                    `/api/admin/characters/categories/${categoryId}` : 
                    '/api/admin/characters/categories';
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 카테고리가 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        });

        // 옵션 폼 제출
        document.getElementById('optionForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('optionCategoryId').value;
            const optionId = document.getElementById('optionId').value;
            const isEdit = !!optionId;

            if (isMultiMode && !isEdit) {
                // 다중 업로드 모드 - 파일 선택 검증
                if (selectedFiles.length === 0) {
                    alert('업로드할 파일을 선택해주세요.');
                    return;
                }
                
                // 파일별 이름 검증
                for (let fileData of selectedFiles) {
                    if (!fileData.name || fileData.name.trim() === '') {
                        alert('모든 파일의 옵션 이름을 입력해주세요.');
                        return;
                    }
                }
                
                await handleMultipleUpload(categoryId);
            } else {
                // 단일 업로드 모드 - 기존 검증 로직
                const optionName = document.getElementById('optionName').value;
                const imageFile = document.getElementById('optionImage').files[0];
                
                if (!optionName || optionName.trim() === '') {
                    alert('옵션 이름을 입력해주세요.');
                    return;
                }
                
                if (!isEdit && !imageFile) {
                    alert('새 옵션을 추가할 때는 이미지가 필요합니다.');
                    return;
                }
                
                await handleSingleUpload(categoryId, optionId, isEdit);
            }
        });

        // 단일 업로드 처리
        async function handleSingleUpload(categoryId, optionId, isEdit) {
            const formData = new FormData();
            formData.append('name', document.getElementById('optionName').value);
            formData.append('color', document.getElementById('optionColor').value);
            formData.append('order', document.getElementById('optionOrder').value);

            const imageFile = document.getElementById('optionImage').files[0];
            const thumbnailFile = document.getElementById('optionThumbnail').files[0];

            if (!isEdit && !imageFile) {
                alert('새 옵션을 추가할 때는 이미지가 필요합니다.');
                return;
            }

            if (imageFile) {
                formData.append('image', imageFile);
            }

            if (thumbnailFile) {
                formData.append('thumbnail', thumbnailFile);
            }

            try {
                const url = isEdit ? 
                    `/api/admin/characters/categories/${categoryId}/options/${optionId}` : 
                    `/api/admin/characters/categories/${categoryId}/options`;
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 옵션이 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeOptionModal();
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('옵션 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 다중 업로드 처리
        async function handleMultipleUpload(categoryId) {
            if (selectedFiles.length === 0) {
                alert('업로드할 파일을 선택해주세요.');
                return;
            }

            const progressContainer = document.getElementById('uploadProgress');
            progressContainer.style.display = 'block';
            
            let successCount = 0;
            let failCount = 0;

            for (let i = 0; i < selectedFiles.length; i++) {
                const fileData = selectedFiles[i];
                updateProgress(i + 1, selectedFiles.length);

                const formData = new FormData();
                formData.append('name', fileData.name);
                formData.append('color', fileData.color);
                formData.append('order', fileData.order.toString());
                formData.append('image', fileData.file);
                
                if (fileData.thumbnailFile) {
                    formData.append('thumbnail', fileData.thumbnailFile);
                }

                try {
                    const response = await fetch(`/api/admin/characters/categories/${categoryId}/options`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${currentToken}`
                        },
                        body: formData
                    });

                    if (response.ok) {
                        successCount++;
                    } else {
                        failCount++;
                        console.error(`파일 업로드 실패: ${fileData.name}`);
                    }

                } catch (error) {
                    failCount++;
                    console.error(`파일 업로드 오류: ${fileData.name}`, error);
                }
            }

            progressContainer.style.display = 'none';
            
            if (successCount > 0) {
                alert(`✅ ${successCount}개의 옵션이 성공적으로 추가되었습니다.${failCount > 0 ? ` (실패: ${failCount}개)` : ''}`);
                closeOptionModal();
                // 전체 새로고침 대신 해당 카테고리만 업데이트
                await updateCategoryOptions(categoryId);
            } else {
                alert(`❌ 모든 업로드가 실패했습니다.`);
            }
        }

        // 카테고리 수정
        function editCategory(categoryId) {
            console.log('editCategory called with categoryId:', categoryId);
            console.log('Available categories:', categories);
            
            // _id 또는 id 필드로 카테고리 찾기
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);
            console.log('Found category:', category);
            
            if (!category) {
                console.error('Category not found with ID:', categoryId);
                console.error('Available category IDs:', categories.map(c => c._id || c.id));
                alert('카테고리를 찾을 수 없습니다.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = '📁 카테고리 수정';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 삭제
        async function deleteCategory(categoryId) {
            console.log('deleteCategory called with categoryId:', categoryId);
            
            if (!confirm('정말로 이 카테고리를 삭제하시겠습니까? 모든 옵션도 함께 삭제됩니다.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 카테고리가 성공적으로 삭제되었습니다.');
                    loadCategories();
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 옵션 삭제
        async function deleteOption(categoryId, optionId) {
            if (!confirm('정말로 이 옵션을 삭제하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 옵션이 성공적으로 삭제되었습니다.');
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('옵션 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 특정 카테고리의 옵션만 업데이트
        async function updateCategoryOptions(categoryId) {
            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    // 전체 categories 배열에서 해당 카테고리 업데이트
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        // API 응답이 직접 카테고리 객체를 반환하므로 data를 사용
                        categories[categoryIndex] = data;
                        
                        // 해당 카테고리의 옵션 그리드만 업데이트
                        const optionsGrid = document.getElementById(`options-${categoryId}`);
                        if (optionsGrid) {
                            optionsGrid.innerHTML = renderOptions(data.options || [], categoryId);
                        }
                    }
                } else {
                    console.error('카테고리 업데이트 실패:', data.message);
                }

            } catch (error) {
                console.error('카테고리 업데이트 오류:', error);
            }
        }

        // 썸네일 재생성
        async function regenerateThumbnail(categoryId, optionId) {
            if (!confirm('이 옵션의 썸네일을 재생성하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}/thumbnail/regenerate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 썸네일이 성공적으로 재생성되었습니다.');
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`❌ 썸네일 재생성 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('썸네일 재생성 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const categoryModal = document.getElementById('categoryModal');
            const optionModal = document.getElementById('optionModal');
            
            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === optionModal) {
                closeOptionModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/cors-test.html">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS 테스트 페이지</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #007bff;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        input[type="text"] {
            width: 300px;
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .network-info {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌐 CORS 테스트 페이지</h1>
        
        <div class="network-info">
            <h3>📍 현재 접속 정보</h3>
            <p><strong>현재 URL:</strong> <span id="currentUrl"></span></p>
            <p><strong>User Agent:</strong> <span id="userAgent"></span></p>
        </div>

        <div class="test-section">
            <h3>🔧 서버 설정</h3>
            <label>API 서버 주소:</label>
            <input type="text" id="serverUrl" value="http://192.168.2.20:3000" placeholder="http://ip:port">
            <button onclick="updateServerUrl()">설정 적용</button>
        </div>

        <div class="test-section">
            <h3>🏥 기본 연결 테스트</h3>
            <button onclick="testBasicConnection()">연결 테스트</button>
            <div id="connectionResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>🔐 인증 테스트</h3>
            <button onclick="testAuthEndpoint()">인증 엔드포인트 테스트</button>
            <div id="authResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>👤 사용자 API 테스트</h3>
            <button onclick="testUserAPI()">사용자 목록 조회</button>
            <div id="userResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>🎭 아바타 API 테스트</h3>
            <button onclick="testAvatarAPI()">아바타 카테고리 조회</button>
            <div id="avatarResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>🎯 아이템 API 테스트</h3>
            <button onclick="testItemAPI()">아이템 카테고리 조회</button>
            <div id="itemResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>📊 전체 테스트</h3>
            <button onclick="runAllTests()">모든 테스트 실행</button>
            <div id="allTestsResult" class="result"></div>
        </div>
    </div>

    <script>
        let serverUrl = 'http://192.168.2.20:3000';

        // 페이지 로드 시 현재 정보 표시
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('currentUrl').textContent = window.location.href;
            document.getElementById('userAgent').textContent = navigator.userAgent;
        });

        function updateServerUrl() {
            const input = document.getElementById('serverUrl');
            serverUrl = input.value.replace(/\/$/, ''); // 끝의 슬래시 제거
            showResult('connectionResult', `서버 주소가 ${serverUrl}로 설정되었습니다.`, 'info');
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${type}`;
        }

        async function testBasicConnection() {
            showResult('connectionResult', '연결 테스트 중...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/health`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('connectionResult', 
                        `✅ 연결 성공!\n상태: ${response.status}\n응답: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    showResult('connectionResult', 
                        `⚠️ 서버 응답 오류\n상태: ${response.status}\n메시지: ${response.statusText}`, 
                        'error');
                }
            } catch (error) {
                showResult('connectionResult', 
                    `❌ 연결 실패\n오류: ${error.message}\n\n가능한 원인:\n- 서버가 실행되지 않음\n- 네트워크 연결 문제\n- CORS 정책 차단`, 
                    'error');
            }
        }

        async function testAuthEndpoint() {
            showResult('authResult', '인증 테스트 중...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/auth/test`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.text();
                showResult('authResult', 
                    `상태: ${response.status}\n응답: ${data}`, 
                    response.ok ? 'success' : 'error');
            } catch (error) {
                showResult('authResult', 
                    `❌ 인증 테스트 실패\n오류: ${error.message}`, 
                    'error');
            }
        }

        async function testUserAPI() {
            showResult('userResult', '사용자 API 테스트 중...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/users`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('userResult', 
                        `✅ 사용자 API 성공!\n사용자 수: ${data.length || 0}\n응답: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('userResult', 
                        `⚠️ 사용자 API 오류\n상태: ${response.status}\n응답: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('userResult', 
                    `❌ 사용자 API 실패\n오류: ${error.message}`, 
                    'error');
            }
        }

        async function testAvatarAPI() {
            showResult('avatarResult', '아바타 API 테스트 중...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/avatars/categories`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('avatarResult', 
                        `✅ 아바타 API 성공!\n카테고리 수: ${data.length || 0}\n응답: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('avatarResult', 
                        `⚠️ 아바타 API 오류\n상태: ${response.status}\n응답: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('avatarResult', 
                    `❌ 아바타 API 실패\n오류: ${error.message}`, 
                    'error');
            }
        }

        async function testItemAPI() {
            showResult('itemResult', '아이템 API 테스트 중...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/stickers`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('itemResult', 
                        `✅ 아이템 API 성공!\n카테고리 수: ${data.length || 0}\n응답: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('itemResult', 
                        `⚠️ 아이템 API 오류\n상태: ${response.status}\n응답: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('itemResult', 
                    `❌ 아이템 API 실패\n오류: ${error.message}`, 
                    'error');
            }
        }

        async function runAllTests() {
            showResult('allTestsResult', '전체 테스트 실행 중...', 'info');
            
            const tests = [
                { name: '기본 연결', func: testBasicConnection },
                { name: '인증', func: testAuthEndpoint },
                { name: '사용자 API', func: testUserAPI },
                { name: '아바타 API', func: testAvatarAPI },
                { name: '아이템 API', func: testItemAPI }
            ];
            
            let results = [];
            
            for (const test of tests) {
                try {
                    await test.func();
                    results.push(`✅ ${test.name}: 성공`);
                } catch (error) {
                    results.push(`❌ ${test.name}: 실패 - ${error.message}`);
                }
                
                // 각 테스트 간 잠시 대기
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            showResult('allTestsResult', 
                `전체 테스트 완료\n\n${results.join('\n')}`, 
                'info');
        }
    </script>
</body>
</html>
</file>

<file path="public/test/customize.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>아바타 커스터마이징 - AR 명함</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: block;
            padding: 30px;
            padding-right: 430px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .right-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 380px;
            height: fit-content;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 1000;
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
        }

        /* 인증 섹션 */
        .auth-section {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        .auth-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .auth-controls input {
            flex: 1;
            min-width: 300px;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .auth-controls input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .status {
            padding: 12px 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        /* 버튼 스타일 */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e17055 0%, #d63031 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #636e72 0%, #2d3436 100%);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* 아바타 선택 영역 */
        .avatar-categories {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .avatar-category {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .avatar-category.selected {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #495057;
        }

        .category-selection {
            font-size: 0.9em;
            color: #667eea;
            font-weight: 500;
        }

        .avatar-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
        }

        .avatar-option {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 12px;
            overflow: hidden;
        }

        .avatar-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .avatar-option.selected {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .avatar-option.selected::after {
            content: '✓';
            position: absolute;
            top: 5px;
            right: 5px;
            background: #667eea;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .avatar-option img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 12px;
        }

        .avatar-option-name {
            text-align: center;
            font-size: 0.8em;
            margin-top: 5px;
            color: #495057;
            font-weight: 500;
        }

        /* 아이템 선택 영역 */
        .item-categories {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .item-category {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .item-category.role-category {
            border-color: #e17055;
            background: #fff8f6;
        }

        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
        }

        .item-card {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .item-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .item-card img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .item-card-name {
            padding: 8px;
            text-align: center;
            font-size: 0.8em;
            color: #495057;
            font-weight: 500;
        }

        /* 슬롯 시스템 */
        .item-slots {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .item-slot {
            width: 100px;
            height: 100px;
            border: 3px dashed #dee2e6;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
            background: #f8f9fa;
        }

        .item-slot.role-slot {
            border-color: #e17055;
            background: #fff8f6;
        }

        .item-slot.dragover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: scale(1.05);
        }

        .item-slot.filled {
            border-color: #00b894;
            border-style: solid;
            background: white;
        }

        .item-slot-label {
            font-size: 0.7em;
            color: #6c757d;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .item-slot-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .item-slot img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
        }

        .item-slot-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e17055;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
        }

        .item-slot.filled:hover .item-slot-remove {
            display: block;
        }

        /* 메시지 입력 */
        .message-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            resize: none;
            font-family: inherit;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .message-counter {
            text-align: right;
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        /* 미리보기 영역 */
        .preview-section {
            text-align: center;
        }

        .preview-canvas {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            background: #f8f9fa;
            margin-bottom: 20px;
            max-width: 100%;
        }

        .preview-placeholder {
            width: 350px;
            height: 350px;
            border: 3px dashed #dee2e6;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 1.1em;
            margin: 0 auto 20px;
        }

        .selected-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .selected-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .selected-item img {
            width: 30px;
            height: 30px;
            object-fit: cover;
            border-radius: 4px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 반응형 디자인 */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .right-panel {
                position: static;
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
                padding-right: 20px;
            }
            
            .right-panel {
                position: static;
                width: 100%;
                max-height: none;
                margin-top: 30px;
                right: auto;
                top: auto;
            }
            
            .auth-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .auth-controls input {
                min-width: auto;
            }
            
            .item-slots {
                flex-wrap: wrap;
            }
            
            .avatar-options {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            }
            
            .item-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🎨 아바타 커스터마이징</h1>
            <p>나만의 아바타와 아이템을 선택하여 개성 넘치는 명함을 만들어보세요</p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <!-- 인증 섹션 -->
                <div class="section auth-section">
                    <div class="section-title">🔐 사용자 인증</div>
                    <p style="margin-bottom: 15px;">커스터마이징 기능을 사용하려면 로그인이 필요합니다.</p>
                    <div class="auth-controls">
                        <input type="text" id="userToken" placeholder="사용자 JWT 토큰 입력">
                        <button class="btn btn-primary" onclick="setUserToken()">토큰 설정</button>
                        <button class="btn btn-success" onclick="getUserToken()">테스트 토큰 생성</button>
                        <button class="btn btn-secondary" onclick="clearUserToken()">토큰 초기화</button>
                    </div>
                    <div id="authStatus"></div>
                </div>

                <!-- 아바타 선택 섹션 -->
                <div class="section">
                    <div class="section-title">👤 아바타 선택</div>
                    <div id="avatarStatus"></div>
                    <div id="avatarCategories" class="avatar-categories"></div>
                </div>

                <!-- 역할 아이템 선택 섹션 -->
                <div class="section">
                    <div class="section-title">💼 역할 선택</div>
                    <div id="roleStatus"></div>
                    <div id="roleSlot" class="item-slots">
                        <div class="item-slot role-slot" data-slot="role">
                            <div class="item-slot-label">역할</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">역할을 선택하세요</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('role')">×</button>
                        </div>
                    </div>
                    <div id="roleCategory" class="item-category role-category"></div>
                </div>

                <!-- 일반 아이템 선택 섹션 -->
                <div class="section">
                    <div class="section-title">🎮 아이템 선택</div>
                    <div id="itemStatus"></div>
                    <div class="item-slots">
                        <div class="item-slot" data-slot="item1">
                            <div class="item-slot-label">아이템 1</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">아이템을 선택하세요</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item1')">×</button>
                        </div>
                        <div class="item-slot" data-slot="item2">
                            <div class="item-slot-label">아이템 2</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">아이템을 선택하세요</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item2')">×</button>
                        </div>
                        <div class="item-slot" data-slot="item3">
                            <div class="item-slot-label">아이템 3</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">아이템을 선택하세요</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item3')">×</button>
                        </div>
                    </div>
                    <div id="itemCategories" class="item-categories"></div>
                </div>

                <!-- 메시지 입력 섹션 -->
                <div class="section">
                    <div class="section-title">💬 한줄 메시지</div>
                    <textarea id="userMessage" class="message-input" placeholder="하고 싶은 말을 한 줄로 적어주세요..." maxlength="100" rows="3"></textarea>
                    <div class="message-counter">
                        <span id="messageCount">0</span> / 100
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <!-- 미리보기 섹션 -->
                <div class="preview-section">
                    <h3 style="margin-bottom: 20px; color: #495057;">🖼️ 미리보기</h3>
                    <div id="previewContainer">
                        <div class="preview-placeholder">
                            아바타를 선택하면<br>여기에 미리보기가 표시됩니다
                        </div>
                    </div>
                    <canvas id="avatarCanvas" class="preview-canvas" width="350" height="350" style="display: none;"></canvas>
                    
                    <div class="selected-items">
                        <div id="selectedAvatarInfo"></div>
                        <div id="selectedItemsInfo"></div>
                    </div>
                    
                    <button class="btn btn-success" id="saveCustomization" onclick="saveCustomization()" style="width: 100%; margin-top: 20px;" disabled>
                        💾 저장하기
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let currentUserToken = '';
        let avatarCategories = [];
        let itemCategories = [];
        let avatarSelections = {}; // { categoryType: optionId }
        let roleSelection = ''; // role 아이템 ID
        let itemSelections = { item1: '', item2: '', item3: '' }; // 슬롯별 아이템 ID
        let userMessage = '';
        let isLoading = false;

        // 페이지 로드 시 초기화
        window.addEventListener('load', function() {
            initializeApp();
        });

        // 앱 초기화
        function initializeApp() {
            // 저장된 토큰 복원
            const savedToken = localStorage.getItem('userToken');
            if (savedToken) {
                document.getElementById('userToken').value = savedToken;
                currentUserToken = savedToken;
                showStatus('authStatus', 'success', '✅ 저장된 토큰을 불러왔습니다.');
                loadData();
            }

            // 메시지 카운터 설정
            const messageInput = document.getElementById('userMessage');
            messageInput.addEventListener('input', function() {
                const count = this.value.length;
                document.getElementById('messageCount').textContent = count;
                userMessage = this.value;
                updateSaveButton();
            });

            // 드래그 앤 드롭 설정
            setupDragAndDrop();
        }

        // 상태 메시지 표시
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // 토큰 설정
        function setUserToken() {
            const token = document.getElementById('userToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', '토큰을 입력해주세요.');
                return;
            }
            
            const setButton = document.querySelector('button[onclick="setUserToken()"]');
            const originalText = setButton.textContent;
            
            try {
                // 버튼 비활성화 및 로딩 상태 표시
                setButton.disabled = true;
                setButton.textContent = '설정 중...';
                
                currentUserToken = token;
                localStorage.setItem('userToken', token);
                showStatus('authStatus', 'success', '✅ 사용자 토큰이 설정되었습니다.');
                loadData();
            } finally {
                // 버튼 상태 복원 (loadData가 완료된 후)
                setTimeout(() => {
                    setButton.disabled = false;
                    setButton.textContent = originalText;
                }, 1000);
            }
        }

        // 테스트 토큰 생성
        async function getUserToken() {
            const tokenButton = document.querySelector('button[onclick="getUserToken()"]');
            const originalText = tokenButton.textContent;
            
            try {
                // 버튼 비활성화 및 로딩 상태 표시
                tokenButton.disabled = true;
                tokenButton.textContent = '토큰 생성 중...';
                
                showStatus('authStatus', 'loading', '테스트 토큰을 생성하는 중...');

                const response = await fetch('/api/auth/test-token/002', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('userToken').value = token;
                    currentUserToken = token;
                    localStorage.setItem('userToken', token);
                    
                    showStatus('authStatus', 'success', `✅ 테스트 토큰이 생성되었습니다. (사용자: ${data.user.nameKr})`);
                    loadData();
                } else {
                    showStatus('authStatus', 'error', `❌ 토큰 생성 실패: ${data.message}`);
                }
            } catch (error) {
                console.error('토큰 생성 오류:', error);
                showStatus('authStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            } finally {
                // 버튼 상태 복원
                tokenButton.disabled = false;
                tokenButton.textContent = originalText;
            }
        }

        // 토큰 초기화
        function clearUserToken() {
            currentUserToken = '';
            localStorage.removeItem('userToken');
            document.getElementById('userToken').value = '';
            showStatus('authStatus', 'success', '🔄 토큰이 초기화되었습니다.');
            
            // 데이터 초기화
            avatarCategories = [];
            itemCategories = [];
            avatarSelections = {};
            roleSelection = '';
            itemSelections = { item1: '', item2: '', item3: '' };
            
            // UI 초기화
            document.getElementById('avatarCategories').innerHTML = '';
            document.getElementById('roleCategory').innerHTML = '';
            document.getElementById('itemCategories').innerHTML = '';
            updatePreview();
            updateSaveButton();
        }

        // 데이터 로드
        async function loadData() {
            if (!currentUserToken) {
                showStatus('authStatus', 'error', '❌ 먼저 사용자 토큰을 설정해주세요.');
                return;
            }

            try {
                console.log('🔍 데이터 로드 시작');
                
                // 1. 아바타 및 아이템 카테고리 로드
                console.log('🔍 카테고리 데이터 로드 시작');
                await Promise.all([
                    loadAvatarCategories(),
                    loadItemCategories()
                ]);
                console.log('✅ 카테고리 데이터 로드 완료');

                // 2. 기존 사용자 데이터 로드 (카테고리 로드 완료 후)
                console.log('🔍 사용자 데이터 로드 시작');
                await loadUserCustomization();
                console.log('✅ 모든 데이터 로드 완료');
            } catch (error) {
                console.error('데이터 로드 오류:', error);
            }
        }

        // 저장 버튼 상태 업데이트
        function updateSaveButton() {
            const saveButton = document.getElementById('saveCustomization');
            const hasAvatarSelection = Object.keys(avatarSelections).length > 0;
            const hasToken = !!currentUserToken;
            
            saveButton.disabled = !hasAvatarSelection || !hasToken || isLoading;
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const slots = document.querySelectorAll('.item-slot');
            
            slots.forEach(slot => {
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragleave', handleDragLeave);
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const itemId = e.dataTransfer.getData('text/plain');
            const slotType = e.currentTarget.getAttribute('data-slot');
            
            if (itemId && slotType) {
                // 드래그된 아이템의 타입 확인
                const draggedItemData = e.dataTransfer.getData('application/json');
                if (draggedItemData) {
                    try {
                        const itemData = JSON.parse(draggedItemData);
                        
                        // Role 아이템은 Role 슬롯에만, 일반 아이템은 일반 슬롯에만
                        if (itemData.slotType === 'role' && slotType !== 'role') {
                            alert('❌ 역할 아이템은 역할 슬롯에만 배치할 수 있습니다.');
                            return;
                        }
                        
                        if (itemData.slotType !== 'role' && slotType === 'role') {
                            alert('❌ 일반 아이템은 역할 슬롯에 배치할 수 없습니다.');
                            return;
                        }
                    } catch (error) {
                        console.error('드래그 데이터 파싱 오류:', error);
                    }
                }
                
                addToSlot(slotType, itemId);
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        // 아바타 카테고리 로드
        async function loadAvatarCategories() {
            showStatus('avatarStatus', 'loading', '아바타 카테고리를 불러오는 중...');
            
            try {
                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    avatarCategories = data.categories.sort((a, b) => (a.order || 0) - (b.order || 0));
                    renderAvatarCategories();
                    showStatus('avatarStatus', 'success', `✅ ${avatarCategories.length}개의 아바타 카테고리를 불러왔습니다.`);
                } else {
                    let errorMessage = '아바타 카테고리 로드 실패';
                    if (response.status === 401) {
                        errorMessage = '인증이 만료되었습니다. 다시 로그인해주세요.';
                    } else if (response.status === 403) {
                        errorMessage = '접근 권한이 없습니다.';
                    }
                    showStatus('avatarStatus', 'error', `❌ ${data.message || errorMessage}`);
                }
            } catch (error) {
                console.error('아바타 카테고리 로드 오류:', error);
                showStatus('avatarStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 아바타 카테고리 렌더링
        function renderAvatarCategories() {
            const container = document.getElementById('avatarCategories');
            container.innerHTML = '';

            if (avatarCategories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">등록된 아바타 카테고리가 없습니다.</p>';
                return;
            }

            avatarCategories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'avatar-category';
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <div class="category-name">${category.name}</div>
                        <div class="category-selection" id="selection-${category.type}">선택 안함</div>
                    </div>
                    <div class="avatar-options" id="options-${category.type}">
                        ${renderAvatarOptions(category.options || [], category.type)}
                    </div>
                `;
                container.appendChild(categoryDiv);
            });
        }

        // 아바타 옵션 렌더링
        function renderAvatarOptions(options, categoryType) {
            if (!options || options.length === 0) {
                return '<p style="text-align: center; color: #6c757d; padding: 20px;">등록된 옵션이 없습니다.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                const isSelected = avatarSelections[categoryType] === optionId;
                
                return `
                    <div class="avatar-option ${isSelected ? 'selected' : ''}" 
                         data-category="${categoryType}" 
                         data-option="${optionId}"
                         onclick="selectAvatarOption('${categoryType}', '${optionId}')">
                        ${option.thumbnailUrl || option.imageUrl ? 
                            `<img src="${option.thumbnailUrl || option.imageUrl}" alt="${option.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjRjNGNEY2Ii8+CjxwYXRoIGQ9Ik0yOCAzMkM5LjUgMzIgMzIgMTggNDAgMThTNTcuNSAzMiA0MCAzMlMxOC41IDMyIDI4IDMyWiIgZmlsbD0iI0Q1RDhEQyIvPgo8cGF0aCBkPSJNMTYgNjRDMTYgNDkuNSAyNi41IDQwIDQwIDQwUzY0IDQ5LjUgNjQgNjRWNjRIMTZWNjRaIiBmaWxsPSIjRDVEOERDIi8+Cjwvc3ZnPg=='">`
                            : `<div style="width: 100%; height: 80px; background: #f8f9fa; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;">이미지 없음</div>`
                        }
                        <div class="avatar-option-name">${option.name}</div>
                    </div>
                `;
            }).join('');
        }

        // 아이템 카테고리 로드
        async function loadItemCategories() {
            showStatus('itemStatus', 'loading', '아이템 카테고리를 불러오는 중...');
            showStatus('roleStatus', 'loading', '역할 아이템을 불러오는 중...');
            
            try {
                const response = await fetch('/api/admin/stickers/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    itemCategories = data.categories.sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    // Role 카테고리와 일반 카테고리 분리
                    const roleCategories = itemCategories.filter(cat => cat.type === 'role');
                    const generalCategories = itemCategories.filter(cat => cat.type !== 'role');
                    
                    renderRoleCategory(roleCategories[0]); // Role 카테고리는 하나만 있다고 가정
                    renderItemCategories(generalCategories);
                    
                    showStatus('itemStatus', 'success', `✅ ${generalCategories.length}개의 아이템 카테고리를 불러왔습니다.`);
                    showStatus('roleStatus', 'success', `✅ 역할 아이템을 불러왔습니다.`);
                } else {
                    let errorMessage = '아이템 카테고리 로드 실패';
                    if (response.status === 401) {
                        errorMessage = '인증이 만료되었습니다. 다시 로그인해주세요.';
                    } else if (response.status === 403) {
                        errorMessage = '접근 권한이 없습니다.';
                    }
                    showStatus('itemStatus', 'error', `❌ ${data.message || errorMessage}`);
                    showStatus('roleStatus', 'error', `❌ ${data.message || errorMessage}`);
                }
            } catch (error) {
                console.error('아이템 카테고리 로드 오류:', error);
                showStatus('itemStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
                showStatus('roleStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // Role 카테고리 렌더링
        function renderRoleCategory(category) {
            const container = document.getElementById('roleCategory');
            container.innerHTML = '';

            if (!category || !category.items || category.items.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">등록된 역할 아이템이 없습니다.</p>';
                return;
            }

            container.innerHTML = `
                <div class="category-header">
                    <div class="category-name">${category.name}</div>
                </div>
                <div class="item-grid">
                    ${renderItemCards(category.items, 'role')}
                </div>
            `;
        }

        // 일반 아이템 카테고리 렌더링
        function renderItemCategories(categories) {
            const container = document.getElementById('itemCategories');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">등록된 아이템 카테고리가 없습니다.</p>';
                return;
            }

            categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'item-category';
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <div class="category-name">${category.name}</div>
                    </div>
                    <div class="item-grid">
                        ${renderItemCards(category.items || [], 'item')}
                    </div>
                `;
                container.appendChild(categoryDiv);
            });
        }

        // 아이템 카드 렌더링
        function renderItemCards(items, slotType) {
            if (!items || items.length === 0) {
                return '<p style="text-align: center; color: #6c757d; padding: 20px;">등록된 아이템이 없습니다.</p>';
            }

            return items.map(item => {
                const itemId = item._id || item.id;
                const imageUrl = item.thumbnailUrl || item.imageUrl;
                
                return `
                    <div class="item-card" 
                         data-item-id="${itemId}" 
                         data-slot-type="${slotType}"
                         draggable="true"
                         ondragstart="handleItemDragStart(event)"
                         onclick="handleItemClick(event, '${itemId}', '${slotType}')">
                        ${imageUrl ? 
                            `<img src="${imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTAwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNDAiIHI9IjE1IiBmaWxsPSIjRDVEOERDIi8+Cjx0ZXh0IHg9IjUwIiB5PSI2NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjNkM3NTdEIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5JVEVNPC90ZXh0Pgo8L3N2Zz4K'">`
                            : `<div style="width: 100%; height: 80px; background: #f8f9fa; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;">이미지 없음</div>`
                        }
                        <div class="item-card-name">${item.name}</div>
                    </div>
                `;
            }).join('');
        }

        // 아이템 드래그 시작
        function handleItemDragStart(event) {
            const itemId = event.currentTarget.getAttribute('data-item-id');
            const slotType = event.currentTarget.getAttribute('data-slot-type');
            
            event.dataTransfer.setData('text/plain', itemId);
            event.dataTransfer.setData('application/json', JSON.stringify({
                itemId: itemId,
                slotType: slotType
            }));
        }

        // 아이템 클릭 처리 (모바일 대응)
        function handleItemClick(event, itemId, slotType) {
            // 빈 슬롯 찾기
            let targetSlot = null;
            
            if (slotType === 'role') {
                targetSlot = 'role';
            } else {
                // 일반 아이템의 경우 빈 슬롯 찾기
                for (let i = 1; i <= 3; i++) {
                    if (!itemSelections[`item${i}`]) {
                        targetSlot = `item${i}`;
                        break;
                    }
                }
            }
            
            if (targetSlot) {
                addToSlot(targetSlot, itemId);
            } else {
                alert('사용 가능한 슬롯이 없습니다. 기존 아이템을 제거한 후 다시 시도해주세요.');
            }
        }

        // 아바타 옵션 선택
        function selectAvatarOption(categoryType, optionId) {
            // 이전 선택 해제
            const prevOption = document.querySelector(`[data-category="${categoryType}"][data-option="${avatarSelections[categoryType]}"]`);
            if (prevOption) {
                prevOption.classList.remove('selected');
            }

            // 새로운 선택
            avatarSelections[categoryType] = optionId;
            
            // UI 업데이트
            const newOption = document.querySelector(`[data-category="${categoryType}"][data-option="${optionId}"]`);
            if (newOption) {
                newOption.classList.add('selected');
            }

            // 카테고리 선택 상태 업데이트
            const selectionElement = document.getElementById(`selection-${categoryType}`);
            if (selectionElement) {
                const category = avatarCategories.find(cat => cat.type === categoryType);
                const option = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                if (option) {
                    selectionElement.textContent = option.name;
                    selectionElement.parentElement.parentElement.classList.add('selected');
                }
            }

            // 미리보기 업데이트
            updatePreview();
            updateSaveButton();
        }

        // 슬롯에 아이템 추가
        function addToSlot(slotType, itemId) {
            // 해당 아이템 정보 찾기
            const item = findItemById(itemId);
            if (!item) {
                console.error('Item not found:', itemId);
                return;
            }

            // 슬롯에 아이템 설정
            if (slotType === 'role') {
                roleSelection = itemId;
            } else {
                itemSelections[slotType] = itemId;
            }

            // 슬롯 UI 업데이트
            updateSlotUI(slotType, item);
            
            // 미리보기 업데이트
            updateSelectedItemsInfo();
            updateSaveButton();
        }

        // 슬롯에서 아이템 제거
        function removeFromSlot(slotType) {
            if (slotType === 'role') {
                roleSelection = '';
            } else {
                itemSelections[slotType] = '';
            }

            // 슬롯 UI 업데이트
            clearSlotUI(slotType);
            
            // 미리보기 업데이트
            updateSelectedItemsInfo();
            updateSaveButton();
        }

        // 슬롯 UI 업데이트
        function updateSlotUI(slotType, item) {
            const slot = document.querySelector(`[data-slot="${slotType}"]`);
            if (!slot) return;

            const slotContent = slot.querySelector('.item-slot-content');
            if (!slotContent) return;

            const imageUrl = item.thumbnailUrl || item.imageUrl;
            
            slotContent.innerHTML = `
                <img src="${imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjMwIiBjeT0iMzAiIHI9IjEwIiBmaWxsPSIjRDVEOERDIi8+Cjx0ZXh0IHg9IjMwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjgiIGZpbGw9IiM2Qzc1N0QiIHRleHQtYW5jaG9yPSJtaWRkbGUiPklURU08L3RleHQ+Cjwvc3ZnPgo='">
                <div style="font-size: 0.7em; color: #495057; margin-top: 5px; text-align: center;">${item.name}</div>
            `;
            
            slot.classList.add('filled');
        }

        // 슬롯 UI 초기화
        function clearSlotUI(slotType) {
            const slot = document.querySelector(`[data-slot="${slotType}"]`);
            if (!slot) return;

            const slotContent = slot.querySelector('.item-slot-content');
            if (!slotContent) return;

            let defaultText = '';
            if (slotType === 'role') {
                defaultText = '역할을 선택하세요';
            } else {
                defaultText = '아이템을 선택하세요';
            }

            slotContent.innerHTML = `<span style="font-size: 0.8em; color: #6c757d;">${defaultText}</span>`;
            slot.classList.remove('filled');
        }

        // 아이템 ID로 아이템 찾기
        function findItemById(itemId) {
            for (const category of itemCategories) {
                if (category.items) {
                    for (const item of category.items) {
                        if ((item._id || item.id) === itemId) {
                            return item;
                        }
                    }
                }
            }
            return null;
        }

        // 선택된 아이템 정보 업데이트
        function updateSelectedItemsInfo() {
            const container = document.getElementById('selectedItemsInfo');
            if (!container) return;

            const selectedItems = [];
            
            // Role 아이템 추가
            if (roleSelection) {
                const roleItem = findItemById(roleSelection);
                if (roleItem) {
                    selectedItems.push({
                        type: 'role',
                        name: roleItem.name,
                        imageUrl: roleItem.thumbnailUrl || roleItem.imageUrl
                    });
                }
            }

            // 일반 아이템 추가
            for (const [slotType, itemId] of Object.entries(itemSelections)) {
                if (itemId) {
                    const item = findItemById(itemId);
                    if (item) {
                        selectedItems.push({
                            type: slotType,
                            name: item.name,
                            imageUrl: item.thumbnailUrl || item.imageUrl
                        });
                    }
                }
            }

            if (selectedItems.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-size: 0.9em;">선택된 아이템이 없습니다.</p>';
                return;
            }

            container.innerHTML = selectedItems.map(item => `
                <div class="selected-item">
                    <img src="${item.imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjE1IiBjeT0iMTUiIHI9IjUiIGZpbGw9IiNENUQ4REMiLz4KPC9zdmc+Cg=='">
                    <div>
                        <strong>${item.type === 'role' ? '역할' : item.type.toUpperCase()}:</strong> ${item.name}
                    </div>
                </div>
            `).join('');
        }

        // 미리보기 업데이트
        function updatePreview() {
            const canvas = document.getElementById('avatarCanvas');
            const previewContainer = document.getElementById('previewContainer');
            const placeholder = previewContainer.querySelector('.preview-placeholder');
            
            // 아바타 선택이 없으면 placeholder 표시
            if (Object.keys(avatarSelections).length === 0) {
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
                canvas.style.display = 'none';
                updateSelectedAvatarInfo();
                return;
            }
            
            // Canvas 표시, placeholder 숨김
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            canvas.style.display = 'block';
            
            // 아바타 합성
            composeAvatar();
        }

        // 아바타 합성
        async function composeAvatar() {
            const canvas = document.getElementById('avatarCanvas');
            const ctx = canvas.getContext('2d');
            
            // Canvas 초기화
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 배경 설정 (투명 배경)
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            try {
                // 아바타 카테고리를 order 순서대로 정렬
                const sortedCategories = avatarCategories
                    .filter(category => avatarSelections[category.type])
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
                
                // 순서대로 이미지 레이어링
                for (const category of sortedCategories) {
                    const optionId = avatarSelections[category.type];
                    const option = category.options?.find(opt => (opt._id || opt.id) === optionId);
                    
                    if (option && (option.imageUrl || option.thumbnailUrl)) {
                        const imageUrl = option.imageUrl || option.thumbnailUrl;
                        await drawImageOnCanvas(ctx, imageUrl, canvas.width, canvas.height);
                    }
                }
                
                // 선택된 아바타 정보 업데이트
                updateSelectedAvatarInfo();
                
            } catch (error) {
                console.error('아바타 합성 오류:', error);
                
                // 에러 발생 시 에러 메시지 표시
                ctx.fillStyle = '#f8d7da';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#721c24';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('이미지 로드 실패', canvas.width / 2, canvas.height / 2);
                ctx.fillText('다시 시도해주세요', canvas.width / 2, canvas.height / 2 + 25);
            }
        }

        // Canvas에 이미지 그리기
        function drawImageOnCanvas(ctx, imageUrl, canvasWidth, canvasHeight) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // CORS 문제 해결
                
                img.onload = function() {
                    try {
                        // 이미지를 Canvas 크기에 맞춰 그리기
                        const aspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvasWidth / canvasHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (aspectRatio > canvasAspectRatio) {
                            // 이미지가 Canvas보다 가로로 길 경우
                            drawWidth = canvasWidth;
                            drawHeight = canvasWidth / aspectRatio;
                            drawX = 0;
                            drawY = (canvasHeight - drawHeight) / 2;
                        } else {
                            // 이미지가 Canvas보다 세로로 길 경우
                            drawWidth = canvasHeight * aspectRatio;
                            drawHeight = canvasHeight;
                            drawX = (canvasWidth - drawWidth) / 2;
                            drawY = 0;
                        }
                        
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = function() {
                    reject(new Error(`이미지 로드 실패: ${imageUrl}`));
                };
                
                img.src = imageUrl;
            });
        }

        // 선택된 아바타 정보 업데이트
        function updateSelectedAvatarInfo() {
            const container = document.getElementById('selectedAvatarInfo');
            if (!container) return;

            const selectedAvatars = [];
            
            for (const [categoryType, optionId] of Object.entries(avatarSelections)) {
                const category = avatarCategories.find(cat => cat.type === categoryType);
                const option = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                
                if (option) {
                    selectedAvatars.push({
                        categoryName: category.name,
                        optionName: option.name,
                        imageUrl: option.thumbnailUrl || option.imageUrl
                    });
                }
            }

            if (selectedAvatars.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-size: 0.9em;">선택된 아바타가 없습니다.</p>';
                return;
            }

            container.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; font-size: 1em;">선택된 아바타</h4>
                    ${selectedAvatars.map(avatar => `
                        <div class="selected-item">
                            <img src="${avatar.imageUrl}" alt="${avatar.optionName}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjE1IiBjeT0iMTUiIHI9IjUiIGZpbGw9IiNENUQ4REMiLz4KPC9zdmc+Cg=='">
                            <div>
                                <strong>${avatar.categoryName}:</strong> ${avatar.optionName}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Canvas에서 Blob 생성
        function getCanvasBlob() {
            return new Promise((resolve, reject) => {
                const canvas = document.getElementById('avatarCanvas');
                
                canvas.toBlob(
                    (blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Canvas to Blob 변환 실패'));
                        }
                    },
                    'image/png',
                    0.9
                );
            });
        }

        // 커스터마이징 저장
        async function saveCustomization() {
            if (!currentUserToken) {
                alert('❌ 로그인이 필요합니다. 먼저 토큰을 설정해주세요.');
                return;
            }

            if (Object.keys(avatarSelections).length === 0) {
                alert('❌ 아바타를 선택해주세요.');
                return;
            }

            const saveButton = document.getElementById('saveCustomization');
            const originalText = saveButton.innerHTML;
            
            try {
                isLoading = true;
                saveButton.disabled = true;
                saveButton.innerHTML = '💾 저장 중...<div class="loading-spinner" style="width: 16px; height: 16px; margin-left: 8px; display: inline-block; vertical-align: middle;"></div>';

                // 1. 합성된 아바타 이미지 업로드
                let avatarImgUrl = '';
                if (Object.keys(avatarSelections).length > 0) {
                    const blob = await getCanvasBlob();
                    avatarImgUrl = await uploadAvatarImage(blob);
                }

                // 2. 사용자 커스터마이징 데이터 저장
                const customizationData = {
                    avatarSelections: avatarSelections,
                    avatarImgUrl: avatarImgUrl,
                    message: userMessage || '',
                    role: roleSelection || '',
                    item1: itemSelections.item1 || '',
                    item2: itemSelections.item2 || '',
                    item3: itemSelections.item3 || ''
                };

                await saveUserCustomization(customizationData);

                // 성공 메시지
                alert('✅ 커스터마이징이 성공적으로 저장되었습니다!');
                
            } catch (error) {
                console.error('저장 오류:', error);
                alert(`❌ 저장 중 오류가 발생했습니다: ${error.message}`);
            } finally {
                isLoading = false;
                saveButton.disabled = false;
                saveButton.innerHTML = originalText;
                updateSaveButton();
            }
        }

        // 아바타 이미지 업로드
        async function uploadAvatarImage(blob) {
            const formData = new FormData();
            formData.append('avatar', blob, 'avatar.png');
            
            // 사용자 ID 추출 (JWT 토큰에서 추출하거나 임시로 설정)
            const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';
            formData.append('userId', userId);

            const response = await fetch('/api/avatars/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`
                },
                body: formData
            });

            const data = await response.json();

            if (response.ok) {
                return data.avatarImgUrl;
            } else {
                throw new Error(data.error || '아바타 이미지 업로드 실패');
            }
        }

        // 사용자 커스터마이징 데이터 저장
        async function saveUserCustomization(customizationData) {
            // 사용자 ID 추출
            const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';

            const response = await fetch(`/api/avatars/${userId}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(customizationData)
            });

            const data = await response.json();

            if (!response.ok) {
                console.error('Server error response:', data);
                console.error('Request data:', customizationData);
                throw new Error(data.error || data.message || '사용자 데이터 저장 실패');
            }

            return data;
        }

        // JWT 토큰에서 사용자 ID 추출 (간단한 구현)
        function extractUserIdFromToken(token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                return payload.userId || payload.id || payload.sub;
            } catch (error) {
                console.error('토큰 파싱 오류:', error);
                return null;
            }
        }

        // 기존 사용자 데이터 로드
        async function loadUserCustomization() {
            if (!currentUserToken) return;

            try {
                const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';
                
                const response = await fetch(`/api/avatars/${userId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('🔍 로드된 사용자 데이터:', data);
                    
                    // 아바타 선택 데이터 변환
                    if (data.avatarSelections) {
                        avatarSelections = {};
                        for (const [categoryType, selectionData] of Object.entries(data.avatarSelections)) {
                            if (typeof selectionData === 'object' && selectionData.id) {
                                // 객체 형태인 경우 ID만 추출
                                avatarSelections[categoryType] = selectionData.id;
                            } else if (typeof selectionData === 'string') {
                                // 이미 ID 문자열인 경우 그대로 사용
                                avatarSelections[categoryType] = selectionData;
                            }
                        }
                        console.log('🔍 변환된 avatarSelections:', avatarSelections);
                    }
                    
                    // 메시지 데이터
                    if (data.message) {
                        userMessage = data.message;
                        document.getElementById('userMessage').value = data.message;
                        document.getElementById('messageCount').textContent = data.message.length;
                    }
                    
                    // 역할 데이터 변환
                    if (data.role) {
                        if (typeof data.role === 'object' && data.role.id) {
                            roleSelection = data.role.id;
                        } else if (typeof data.role === 'string') {
                            roleSelection = data.role;
                        }
                        console.log('🔍 변환된 roleSelection:', roleSelection);
                    }
                    
                    // 아이템 데이터 변환
                    for (let i = 1; i <= 3; i++) {
                        const itemKey = `item${i}`;
                        const itemData = data[itemKey];
                        if (itemData) {
                            if (typeof itemData === 'object' && itemData.id) {
                                itemSelections[itemKey] = itemData.id;
                            } else if (typeof itemData === 'string') {
                                itemSelections[itemKey] = itemData;
                            }
                        }
                    }
                    console.log('🔍 변환된 itemSelections:', itemSelections);

                    // UI 업데이트
                    updateUIFromLoadedData();
                    console.log('✅ 기존 사용자 데이터 로드 및 UI 업데이트 완료');
                } else if (response.status === 404) {
                    // 404는 정상적인 상황 - 사용자 데이터가 없음
                    console.log('새로운 사용자 - 기존 데이터 없음');
                } else {
                    // 다른 오류들만 로깅
                    console.warn('데이터 로드 실패:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('사용자 데이터 로드 오류:', error);
            }
        }

        // 로드된 데이터로 UI 업데이트
        function updateUIFromLoadedData() {
            console.log('🔍 updateUIFromLoadedData 시작');
            
            // 아바타 선택 상태 업데이트
            for (const [categoryType, optionId] of Object.entries(avatarSelections)) {
                console.log(`🔍 아바타 선택 업데이트: ${categoryType} = ${optionId}`);
                const option = document.querySelector(`[data-category="${categoryType}"][data-option="${optionId}"]`);
                if (option) {
                    option.classList.add('selected');
                    console.log(`✅ 아바타 선택 UI 업데이트 성공: ${categoryType}`);
                    
                    const selectionElement = document.getElementById(`selection-${categoryType}`);
                    if (selectionElement) {
                        const category = avatarCategories.find(cat => cat.type === categoryType);
                        const optionData = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                        if (optionData) {
                            selectionElement.textContent = optionData.name;
                            selectionElement.parentElement.parentElement.classList.add('selected');
                        }
                    }
                } else {
                    console.warn(`❌ 아바타 선택 요소를 찾을 수 없음: ${categoryType} = ${optionId}`);
                }
            }

            // 아이템 슬롯 업데이트
            if (roleSelection) {
                console.log(`🔍 역할 아이템 업데이트: ${roleSelection}`);
                const roleItem = findItemById(roleSelection);
                if (roleItem) {
                    updateSlotUI('role', roleItem);
                    console.log(`✅ 역할 아이템 UI 업데이트 성공`);
                } else {
                    console.warn(`❌ 역할 아이템을 찾을 수 없음: ${roleSelection}`);
                }
            }

            for (const [slotType, itemId] of Object.entries(itemSelections)) {
                if (itemId) {
                    console.log(`🔍 일반 아이템 업데이트: ${slotType} = ${itemId}`);
                    const item = findItemById(itemId);
                    if (item) {
                        updateSlotUI(slotType, item);
                        console.log(`✅ 일반 아이템 UI 업데이트 성공: ${slotType}`);
                    } else {
                        console.warn(`❌ 일반 아이템을 찾을 수 없음: ${slotType} = ${itemId}`);
                    }
                }
            }

            // 미리보기 업데이트
            updatePreview();
            updateSelectedItemsInfo();
            updateSaveButton();
            console.log('✅ updateUIFromLoadedData 완료');
        }
    </script>
</body>

</html>
</file>

<file path="public/test/item.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스티커 관리 테스트 - AR 명함</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], input[type="number"], textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: '▶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-items {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .item-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .item-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-items {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .multi-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background-color: #fafafa;
        }

        .multi-upload-container.dragover {
            border-color: #007bff;
            background-color: #e3f2fd;
        }

        .file-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .file-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: white;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .file-preview {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-info {
            flex: 1;
        }

        .file-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .remove-file {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-file:hover {
            background-color: #c82333;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .batch-input {
            flex: 1;
            min-width: 150px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #28a745;
            transition: width 0.3s ease;
        }

        .upload-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .animation-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .animation-preview {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px auto;
            background-size: cover;
            background-repeat: no-repeat;
        }

        .form-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            background-color: #f9f9f9;
        }

        .form-section h4 {
            margin-top: 0;
            color: #333;
        }

        input:disabled, select:disabled {
            background-color: #f5f5f5;
            color: #666;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎮 스티커 관리 테스트 페이지</h1>

        <!-- 인증 섹션 -->
        <div class="section auth-section">
            <h3>🔐 관리자 인증</h3>
            <p>스티커 관리 기능을 사용하려면 관리자 권한이 필요합니다.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="관리자 JWT 토큰 입력" style="width: 400px;">
                <button onclick="setAuthToken()">토큰 설정</button>
                <button onclick="getAdminToken()" class="btn-success">관리자 토큰 생성</button>
                <button onclick="clearAuthToken()" class="btn-secondary">토큰 초기화</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- 카테고리 관리 섹션 -->
        <div class="section">
            <h3>📁 스티커 카테고리 관리</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">새 카테고리 추가</button>
                <button onclick="loadCategories()" class="btn-secondary">새로고침</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- 카테고리 생성/수정 모달 -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">📁 새 카테고리 추가</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">카테고리 이름 *</label>
                        <input type="text" id="categoryName" required placeholder="예: 운동, 음료, 음식, 취미">
                    </div>
                    
                    <div class="form-group">
                        <label for="categoryType">카테고리 타입 *</label>
                        <input type="text" id="categoryType" required placeholder="예: exercise, drink, food, hobby">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="categoryOrder">순서</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success">저장</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 스티커 생성/수정 모달 -->
    <div id="itemModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeItemModal()">&times;</span>
            <h3 id="itemModalTitle">🎮 새 스티커 추가</h3>
            <form id="itemForm" enctype="multipart/form-data">
                <input type="hidden" id="itemCategoryId">
                <input type="hidden" id="itemId">
                
                <!-- 단일 스티커 추가 모드 -->
                <div id="singleItemMode">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemName">스티커 이름 *</label>
                            <input type="text" id="itemName" required placeholder="예: 달리기, 커피, 햄버거">
                        </div>
                        
                        <div class="form-group">
                            <label for="itemOrder">순서</label>
                            <input type="number" id="itemOrder" min="0" value="0">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="itemImage">스티커 이미지 * (스프라이트 시퀀스 또는 단일 이미지)</label>
                        <input type="file" id="itemImage" accept="image/*">
                        <div id="imagePreview"></div>
                    </div>
                    
                    <div class="form-section">
                        <h4>🎬 애니메이션 설정 (선택사항)</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="itemFrames">총 프레임 수</label>
                                <input type="number" id="itemFrames" min="1" placeholder="예: 16">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemColumns">컬럼 수</label>
                                <input type="number" id="itemColumns" min="1" max="64" value="16" placeholder="기본값: 16">
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="itemDuration">애니메이션 지속시간 (ms)</label>
                                <input type="number" id="itemDuration" min="1" placeholder="예: 1000">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemAnimationType">애니메이션 타입</label>
                                <select id="itemAnimationType" onchange="handleAnimationTypeChange()">
                                    <option value="">선택하세요</option>
                                    <option value="none">애니메이션 없음 (스틸 이미지)</option>
                                    <option value="loop">반복 (loop)</option>
                                    <option value="once">한 번 (once)</option>
                                    <option value="pingpong">왕복 (pingpong)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="itemThumbnail">썸네일 이미지 (300x300px 권장)</label>
                        <input type="file" id="itemThumbnail" accept="image/*">
                        <small>썸네일을 제공하지 않으면 원본 이미지에서 자동 생성됩니다.</small>
                        <div id="thumbnailPreview"></div>
                    </div>
                </div>

                <!-- 다중 스티커 추가 모드 -->
                <div id="multiItemMode" style="display: none;">
                    <div class="form-group">
                        <label>이미지 파일 선택 (여러 개 선택 가능)</label>
                        <div class="multi-upload-container" id="multiUploadContainer">
                            <p>여기에 파일을 드래그하거나 클릭하여 선택하세요</p>
                            <input type="file" id="multiItemImages" accept="image/*" multiple style="display: none;">
                            <button type="button" onclick="document.getElementById('multiItemImages').click()" class="btn-success">파일 선택</button>
                        </div>
                    </div>

                    <!-- 일괄 설정 -->
                    <div class="form-section">
                        <h4>🔧 일괄 설정</h4>
                        <div class="batch-controls">
                            <input type="number" id="batchOrderStart" min="0" value="0" class="batch-input" placeholder="시작 순서">
                            <input type="number" id="batchFrames" min="1" class="batch-input" placeholder="공통 프레임 수">
                            <input type="number" id="batchColumns" min="1" max="64" value="16" class="batch-input" placeholder="공통 컬럼 수">
                            <input type="number" id="batchDuration" min="1" class="batch-input" placeholder="공통 지속시간 (ms)">
                            <select id="batchAnimationType" class="batch-input" onchange="handleBatchAnimationTypeChange()">
                                <option value="">애니메이션 타입</option>
                                <option value="none">애니메이션 없음 (스틸 이미지)</option>
                                <option value="loop">반복 (loop)</option>
                                <option value="once">한 번 (once)</option>
                                <option value="pingpong">왕복 (pingpong)</option>
                            </select>
                            <button type="button" onclick="applyBatchSettings()" class="btn-secondary">일괄 적용</button>
                        </div>
                    </div>

                    <!-- 파일 목록 -->
                    <div id="fileItemsContainer" class="file-items"></div>

                    <!-- 업로드 진행률 -->
                    <div id="uploadProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="upload-status" id="uploadStatus"></div>
                    </div>
                </div>
                
                <!-- 모드 전환 버튼 -->
                <div style="text-align: center; margin: 20px 0;">
                    <button type="button" id="toggleModeBtn" onclick="toggleUploadMode()" class="btn-secondary">다중 업로드 모드</button>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeItemModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success" id="submitItemBtn">저장</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let isMultiMode = false;
        let selectedFiles = [];
        let uploadProgress = 0;
        let expandedCategories = new Set(); // 열린 카테고리 상태 추적

        // 인증 토큰 설정
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', '토큰을 입력해주세요.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', '✅ 관리자 토큰이 설정되었습니다.');
            
            // 토큰 설정 후 카테고리 목록 자동 로드
            loadCategories();
        }

        // 관리자 토큰 생성
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', '관리자 토큰을 생성하는 중...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `✅ 관리자 토큰이 생성되었습니다. (사용자: ${data.user.nameKr})`);
                    
                    // 토큰 생성 후 카테고리 목록 자동 로드
                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `❌ 토큰 생성 실패: ${data.message || '관리자 사용자를 찾을 수 없습니다.'}`);
                }

            } catch (error) {
                console.error('토큰 생성 오류:', error);
                showStatus('authStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 토큰 초기화
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', '🔄 토큰이 초기화되었습니다.');
            
            // 카테고리 목록 숨기기
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // 페이지 로드 시 저장된 토큰 복원
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', '✅ 저장된 토큰을 불러왔습니다.');
                loadCategories();
            }

            // 드래그 앤 드롭 이벤트 설정
            setupDragAndDrop();
        });

        // 상태 메시지 표시
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // 카테고리 목록 로드
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', '❌ 먼저 관리자 토큰을 설정해주세요.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', '카테고리 목록을 불러오는 중...');

                const response = await fetch('/api/admin/stickers/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `✅ ${categories.length}개의 카테고리를 불러왔습니다.`);
                } else {
                    showStatus('categoryStatus', 'error', `❌ ${data.message || '카테고리 목록 로드 실패'}`);
                }

            } catch (error) {
                console.error('카테고리 목록 로드 오류:', error);
                showStatus('categoryStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 카테고리 렌더링
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>등록된 카테고리가 없습니다.</p>';
                return;
            }

            categories.forEach(category => {
                // ID 필드 확인 - _id 또는 id 사용
                const categoryId = category._id || category.id;
                console.log('Category object:', category);
                console.log('Category ID:', categoryId);
                
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateItemModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">스티커 추가</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">수정</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">삭제</button>
                        </div>
                    </div>
                    <div class="category-items">
                        <p><strong>스티커 수:</strong> ${category.items ? category.items.length : 0}개</p>
                        <div class="items-grid" id="items-${categoryId}">
                            ${renderItems(category.items || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');
            
            card.classList.toggle('collapsed');
            
            // 상태 추적
            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // 스티커 렌더링
        function renderItems(items, categoryId) {
            if (!items || items.length === 0) {
                return '<p>등록된 스티커이 없습니다.</p>';
            }

            return items.map(item => {
                const itemId = item._id || item.id;
                const hasAnimation = item.animation && item.animation.frames > 1;
                
                return `
                    <div class="item-card">
                        <div class="item-image-container">
                            ${item.thumbnailUrl ? `<img src="${item.thumbnailUrl}" alt="${item.name}" class="item-image">` : '<div class="item-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">썸네일 없음</div>'}
                        </div>
                        <div class="item-name">${item.name}</div>
                        ${hasAnimation ? `<div class="animation-info">🎬 ${item.animation.frames}프레임 / ${item.animation.duration}ms</div>` : ''}
                        <div class="thumbnail-source">썸네일: ${item.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'}</div>
                        <div class="item-actions">
                            <button onclick="openEditItemModal('${categoryId}', '${itemId}', '${item.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">수정</button>
                            <button onclick="deleteItem('${categoryId}', '${itemId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">삭제</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${itemId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">썸네일 재생성</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 애니메이션 타입 변경 처리 (단일 모드)
        function handleAnimationTypeChange() {
            const animationType = document.getElementById('itemAnimationType').value;
            const framesField = document.getElementById('itemFrames');
            const columnsField = document.getElementById('itemColumns');
            const durationField = document.getElementById('itemDuration');
            
            if (animationType === 'none') {
                // 애니메이션 없음 - 스틸 이미지
                framesField.value = '1';
                columnsField.value = '1';
                durationField.value = '';
                
                // 필드 비활성화
                framesField.disabled = true;
                columnsField.disabled = true;
                durationField.disabled = true;
            } else if (animationType === '') {
                // 선택 안함 - 기본값으로 복원
                framesField.value = '';
                columnsField.value = '16';
                durationField.value = '';
                
                // 필드 활성화
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
            } else {
                // 애니메이션 있음 - 필드 활성화
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
                
                // 기본값 설정 (비어있는 경우)
                if (!framesField.value) framesField.value = '16';
                if (!columnsField.value) columnsField.value = '16';
                if (!durationField.value) durationField.value = '1000';
            }
        }

        // 일괄 애니메이션 타입 변경 처리
        function handleBatchAnimationTypeChange() {
            const animationType = document.getElementById('batchAnimationType').value;
            const framesField = document.getElementById('batchFrames');
            const columnsField = document.getElementById('batchColumns');
            const durationField = document.getElementById('batchDuration');
            
            if (animationType === 'none') {
                // 애니메이션 없음 - 스틸 이미지
                framesField.value = '1';
                columnsField.value = '1';
                durationField.value = '';
                
                // 필드 비활성화
                framesField.disabled = true;
                columnsField.disabled = true;
                durationField.disabled = true;
            } else if (animationType === '') {
                // 선택 안함 - 기본값으로 복원
                framesField.value = '';
                columnsField.value = '16';
                durationField.value = '';
                
                // 필드 활성화
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
            } else {
                // 애니메이션 있음 - 필드 활성화
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
                
                // 기본값 설정 (비어있는 경우)
                if (!framesField.value) framesField.value = '16';
                if (!columnsField.value) columnsField.value = '16';
                if (!durationField.value) durationField.value = '1000';
            }
        }

        // 특정 카테고리의 스티커만 업데이트
        async function updateCategoryItems(categoryId) {
            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    // 전체 categories 배열에서 해당 카테고리 업데이트
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        // API 응답이 직접 카테고리 객체를 반환하므로 data를 사용
                        categories[categoryIndex] = data;
                        
                        // 해당 카테고리의 스티커 그리드만 업데이트
                        const itemsGrid = document.getElementById(`items-${categoryId}`);
                        if (itemsGrid) {
                            itemsGrid.innerHTML = renderItems(data.items || [], categoryId);
                        }
                    }
                } else {
                    console.error('카테고리 업데이트 실패:', data.message);
                }

            } catch (error) {
                console.error('카테고리 업데이트 오류:', error);
            }
        }

        // 업로드 모드 전환
        function toggleUploadMode() {
            isMultiMode = !isMultiMode;
            const singleMode = document.getElementById('singleItemMode');
            const multiMode = document.getElementById('multiItemMode');
            const toggleBtn = document.getElementById('toggleModeBtn');
            const submitBtn = document.getElementById('submitItemBtn');

            // 단일 모드의 필수 입력 필드들
            const singleModeRequiredFields = [
                document.getElementById('itemName'),
                document.getElementById('itemImage')
            ];

            if (isMultiMode) {
                singleMode.style.display = 'none';
                multiMode.style.display = 'block';
                toggleBtn.textContent = '단일 업로드 모드';
                submitBtn.textContent = '일괄 업로드';
                
                // 단일 모드 필드들의 required 속성 제거
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.removeAttribute('required');
                    }
                });
            } else {
                singleMode.style.display = 'block';
                multiMode.style.display = 'none';
                toggleBtn.textContent = '다중 업로드 모드';
                submitBtn.textContent = '저장';
                
                // 단일 모드 필드들의 required 속성 복원
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.setAttribute('required', 'required');
                    }
                });
                
                // 선택된 파일들 초기화
                selectedFiles = [];
                document.getElementById('fileItemsContainer').innerHTML = '';
            }
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const container = document.getElementById('multiUploadContainer');
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.classList.add('dragover');
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                addFiles(files);
            });

            container.addEventListener('click', () => {
                document.getElementById('multiItemImages').click();
            });

            document.getElementById('multiItemImages').addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                addFiles(files);
            });
        }

        // 파일 추가
        function addFiles(files) {
            files.forEach(file => {
                const fileId = Date.now() + Math.random();
                const fileData = {
                    id: fileId,
                    file: file,
                    name: file.name.replace(/\.[^/.]+$/, ""), // 확장자 제거
                    order: selectedFiles.length,
                    thumbnailFile: null,
                    // 애니메이션 설정
                    frames: null,
                    columns: 16,
                    duration: null,
                    animationType: ''
                };
                
                selectedFiles.push(fileData);
            });
            
            renderFileItems();
        }

        // 파일 스티커 렌더링
        function renderFileItems() {
            const container = document.getElementById('fileItemsContainer');
            container.innerHTML = '';

            selectedFiles.forEach(fileData => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <img src="${URL.createObjectURL(fileData.file)}" alt="미리보기" class="file-preview">
                    <div class="file-info">
                        <div class="form-group">
                            <label>스티커 이름</label>
                            <input type="text" value="${fileData.name}" onchange="updateFileName(${fileData.id}, this.value)">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>순서</label>
                                <input type="number" value="${fileData.order}" min="0" onchange="updateFileOrder(${fileData.id}, this.value)">
                            </div>
                            <div class="form-group">
                                <label>프레임 수</label>
                                <input type="number" value="${fileData.frames || ''}" min="1" onchange="updateFileFrames(${fileData.id}, this.value)" placeholder="애니메이션인 경우" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>컬럼 수</label>
                                <input type="number" value="${fileData.columns}" min="1" max="64" onchange="updateFileColumns(${fileData.id}, this.value)" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                            <div class="form-group">
                                <label>지속시간 (ms)</label>
                                <input type="number" value="${fileData.duration || ''}" min="1" onchange="updateFileDuration(${fileData.id}, this.value)" placeholder="애니메이션인 경우" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>애니메이션 타입</label>
                                <select onchange="updateFileAnimationType(${fileData.id}, this.value)">
                                    <option value="">선택하세요</option>
                                    <option value="none" ${fileData.animationType === 'none' ? 'selected' : ''}>애니메이션 없음 (스틸 이미지)</option>
                                    <option value="loop" ${fileData.animationType === 'loop' ? 'selected' : ''}>반복 (loop)</option>
                                    <option value="once" ${fileData.animationType === 'once' ? 'selected' : ''}>한 번 (once)</option>
                                    <option value="pingpong" ${fileData.animationType === 'pingpong' ? 'selected' : ''}>왕복 (pingpong)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>썸네일 (선택사항)</label>
                                <input type="file" accept="image/*" onchange="updateFileThumbnail(${fileData.id}, this.files[0])">
                            </div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button type="button" class="remove-file" onclick="removeFile(${fileData.id})">삭제</button>
                    </div>
                `;
                container.appendChild(fileItem);
            });
        }

        // 파일 정보 업데이트 함수들
        function updateFileName(fileId, name) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.name = name;
        }

        function updateFileOrder(fileId, order) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.order = parseInt(order);
        }

        function updateFileFrames(fileId, frames) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.frames = frames ? parseInt(frames) : null;
        }

        function updateFileColumns(fileId, columns) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.columns = parseInt(columns);
        }

        function updateFileDuration(fileId, duration) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.duration = duration ? parseInt(duration) : null;
        }

        function updateFileAnimationType(fileId, animationType) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) {
                fileData.animationType = animationType;
                
                // 애니메이션 없음 선택 시 프레임 수와 컬럼 수 자동 설정
                if (animationType === 'none') {
                    fileData.frames = 1;
                    fileData.columns = 1;
                    fileData.duration = null;
                } else if (animationType !== '' && animationType !== 'none') {
                    // 애니메이션 있음 선택 시 기본값 설정
                    if (!fileData.frames) fileData.frames = 16;
                    if (!fileData.columns) fileData.columns = 16;
                    if (!fileData.duration) fileData.duration = 1000;
                }
                
                // 화면 다시 렌더링
                renderFileItems();
            }
        }

        function updateFileThumbnail(fileId, thumbnailFile) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.thumbnailFile = thumbnailFile;
        }

        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(f => f.id !== fileId);
            renderFileItems();
        }

        // 일괄 설정 적용
        function applyBatchSettings() {
            const batchOrderStart = parseInt(document.getElementById('batchOrderStart').value) || 0;
            const batchFrames = document.getElementById('batchFrames').value;
            const batchColumns = parseInt(document.getElementById('batchColumns').value) || 16;
            const batchDuration = document.getElementById('batchDuration').value;
            const batchAnimationType = document.getElementById('batchAnimationType').value;

            selectedFiles.forEach((fileData, index) => {
                fileData.order = batchOrderStart + index;
                fileData.columns = batchColumns;
                if (batchFrames) fileData.frames = parseInt(batchFrames);
                if (batchDuration) fileData.duration = parseInt(batchDuration);
                if (batchAnimationType) fileData.animationType = batchAnimationType;
            });

            renderFileItems();
        }

        // 카테고리 생성 모달 열기
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = '📁 새 카테고리 추가';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 모달 닫기
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 스티커 생성 모달 열기
        function openCreateItemModal(categoryId) {
            document.getElementById('itemModalTitle').textContent = '🎮 새 스티커 추가';
            document.getElementById('itemForm').reset();
            document.getElementById('itemCategoryId').value = categoryId;
            document.getElementById('itemId').value = '';
            document.getElementById('imagePreview').innerHTML = '';
            document.getElementById('thumbnailPreview').innerHTML = '';
            
            // 모드 초기화 - 단일 모드로 시작
            isMultiMode = false;
            document.getElementById('singleItemMode').style.display = 'block';
            document.getElementById('multiItemMode').style.display = 'none';
            document.getElementById('toggleModeBtn').textContent = '다중 업로드 모드';
            document.getElementById('submitItemBtn').textContent = '저장';
            
            // 단일 모드 필드들의 required 속성 복원
            const itemNameField = document.getElementById('itemName');
            const itemImageField = document.getElementById('itemImage');
            if (itemNameField) itemNameField.setAttribute('required', 'required');
            if (itemImageField) itemImageField.setAttribute('required', 'required');
            
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
            
            const modal = document.getElementById('itemModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 스티커 수정 모달 열기
        function openEditItemModal(categoryId, itemId, itemName) {
            // 스티커 정보를 찾기 위해 카테고리에서 스티커 찾기
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.items) {
                alert('카테고리 또는 스티커을 찾을 수 없습니다.');
                return;
            }

            const item = category.items.find(itm => (itm._id || itm.id) === itemId);
            if (!item) {
                alert('스티커을 찾을 수 없습니다.');
                return;
            }

            document.getElementById('itemModalTitle').textContent = `🎮 스티커 수정: ${itemName}`;
            document.getElementById('itemCategoryId').value = categoryId;
            document.getElementById('itemId').value = itemId;
            document.getElementById('itemName').value = item.name;
            document.getElementById('itemOrder').value = item.order || 0;
            
            // 애니메이션 정보 설정
            if (item.animation) {
                document.getElementById('itemFrames').value = item.animation.frames || '';
                document.getElementById('itemColumns').value = item.animation.columns || 16;
                document.getElementById('itemDuration').value = item.animation.duration || '';
                document.getElementById('itemAnimationType').value = item.animation.type || '';
            } else {
                document.getElementById('itemFrames').value = '';
                document.getElementById('itemColumns').value = 16;
                document.getElementById('itemDuration').value = '';
                document.getElementById('itemAnimationType').value = '';
            }
            
            // 애니메이션 타입에 따른 필드 상태 초기화
            setTimeout(() => {
                handleAnimationTypeChange();
            }, 100);
            
            // 수정 모드에서는 단일 모드만 사용
            isMultiMode = false;
            document.getElementById('singleItemMode').style.display = 'block';
            document.getElementById('multiItemMode').style.display = 'none';
            document.getElementById('toggleModeBtn').style.display = 'none'; // 수정 모드에서는 모드 전환 숨김
            document.getElementById('submitItemBtn').textContent = '저장';
            
            // 수정 모드에서는 이미지가 필수가 아님 (기존 이미지 유지 가능)
            const itemNameField = document.getElementById('itemName');
            const itemImageField = document.getElementById('itemImage');
            if (itemNameField) itemNameField.setAttribute('required', 'required');
            if (itemImageField) itemImageField.removeAttribute('required');
            
            // 이미지 미리보기
            const imagePreview = document.getElementById('imagePreview');
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            
            imagePreview.innerHTML = item.imageUrl ? 
                `<img src="${item.imageUrl}" alt="현재 이미지" class="image-preview">` : 
                '<p>현재 이미지 없음</p>';
                
            thumbnailPreview.innerHTML = item.thumbnailUrl ? 
                `<img src="${item.thumbnailUrl}" alt="현재 썸네일" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>현재 썸네일 (${item.thumbnailSource === 'user' ? '사용자 제공' : '자동 생성'})</small>` : 
                '<p>현재 썸네일 없음</p>';
            
            const modal = document.getElementById('itemModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 스티커 모달 닫기
        function closeItemModal() {
            const modal = document.getElementById('itemModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            
            // 모드 전환 버튼 다시 표시
            document.getElementById('toggleModeBtn').style.display = 'inline-block';
            
            // 선택된 파일들 초기화
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
        }

        // 이미지 미리보기 처리
        document.getElementById('itemImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('imagePreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="이미지 미리보기" class="image-preview">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        document.getElementById('itemThumbnail').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="썸네일 미리보기" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // 진행률 업데이트
        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('uploadStatus').textContent = `${current}/${total} 업로드 중...`;
        }

        // 카테고리 폼 제출
        document.getElementById('categoryForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;
            
            // 제출 버튼 찾기 및 비활성화
            const submitBtn = e.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? '수정 중...' : '저장 중...';
            
            try {
                const formData = {
                    name: document.getElementById('categoryName').value,
                    type: document.getElementById('categoryType').value,
                    order: parseInt(document.getElementById('categoryOrder').value) || 0
                };

                const url = isEdit ? 
                    `/api/admin/stickers/categories/${categoryId}` : 
                    '/api/admin/stickers/categories';
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 카테고리가 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            } finally {
                // 버튼 상태 복원
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // 스티커 폼 제출
        document.getElementById('itemForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const categoryId = document.getElementById('itemCategoryId').value;
            const itemId = document.getElementById('itemId').value;
            const isEdit = !!itemId;

            if (isMultiMode && !isEdit) {
                // 다중 업로드 모드 - 파일 선택 검증
                if (selectedFiles.length === 0) {
                    alert('업로드할 파일을 선택해주세요.');
                    return;
                }
                
                // 파일별 이름 검증
                for (let fileData of selectedFiles) {
                    if (!fileData.name || fileData.name.trim() === '') {
                        alert('모든 파일의 스티커 이름을 입력해주세요.');
                        return;
                    }
                }
                
                await handleMultipleUpload(categoryId);
            } else {
                // 단일 업로드 모드 - 기존 검증 로직
                const itemName = document.getElementById('itemName').value;
                const imageFile = document.getElementById('itemImage').files[0];
                
                if (!itemName || itemName.trim() === '') {
                    alert('스티커 이름을 입력해주세요.');
                    return;
                }
                
                if (!isEdit && !imageFile) {
                    alert('새 스티커을 추가할 때는 이미지가 필요합니다.');
                    return;
                }
                
                await handleSingleUpload(categoryId, itemId, isEdit);
            }
        });

        // 단일 업로드 처리
        async function handleSingleUpload(categoryId, itemId, isEdit) {
            const submitBtn = document.getElementById('submitItemBtn');
            const originalText = submitBtn.textContent;
            
            // 버튼 비활성화 및 로딩 상태 표시
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? '수정 중...' : '저장 중...';
            
            try {
                const formData = new FormData();
                formData.append('name', document.getElementById('itemName').value);
                formData.append('order', document.getElementById('itemOrder').value);

                // 애니메이션 정보 추가
                const frames = document.getElementById('itemFrames').value;
                const columns = document.getElementById('itemColumns').value;
                const duration = document.getElementById('itemDuration').value;
                const animationType = document.getElementById('itemAnimationType').value;

                if (frames) formData.append('frames', frames);
                if (columns) formData.append('columns', columns);
                if (duration) formData.append('duration', duration);
                if (animationType) formData.append('animationType', animationType);

                const imageFile = document.getElementById('itemImage').files[0];
                const thumbnailFile = document.getElementById('itemThumbnail').files[0];

                if (!isEdit && !imageFile) {
                    alert('새 스티커을 추가할 때는 이미지가 필요합니다.');
                    return;
                }

                if (imageFile) {
                    formData.append('image', imageFile);
                }

                if (thumbnailFile) {
                    formData.append('thumbnail', thumbnailFile);
                }

                const url = isEdit ? 
                    `/api/admin/stickers/categories/${categoryId}/items/${itemId}` : 
                    `/api/admin/stickers/categories/${categoryId}/items`;
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`✅ 스티커이 성공적으로 ${isEdit ? '수정' : '추가'}되었습니다.`);
                    closeItemModal();
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`❌ ${isEdit ? '수정' : '추가'} 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('스티커 저장 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            } finally {
                // 버튼 상태 복원
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // 다중 업로드 처리
        async function handleMultipleUpload(categoryId) {
            if (selectedFiles.length === 0) {
                alert('업로드할 파일을 선택해주세요.');
                return;
            }

            const submitBtn = document.getElementById('submitItemBtn');
            const originalText = submitBtn.textContent;
            
            // 버튼 비활성화
            submitBtn.disabled = true;
            submitBtn.textContent = '업로드 중...';

            const progressContainer = document.getElementById('uploadProgress');
            progressContainer.style.display = 'block';
            
            let successCount = 0;
            let failCount = 0;

            try {
                for (let i = 0; i < selectedFiles.length; i++) {
                    const fileData = selectedFiles[i];
                    updateProgress(i + 1, selectedFiles.length);

                    const formData = new FormData();
                    formData.append('name', fileData.name);
                    formData.append('order', fileData.order.toString());
                    formData.append('image', fileData.file);
                    
                    // 애니메이션 정보 추가
                    if (fileData.frames) formData.append('frames', fileData.frames.toString());
                    if (fileData.columns) formData.append('columns', fileData.columns.toString());
                    if (fileData.duration) formData.append('duration', fileData.duration.toString());
                    if (fileData.animationType) formData.append('animationType', fileData.animationType);
                    
                    if (fileData.thumbnailFile) {
                        formData.append('thumbnail', fileData.thumbnailFile);
                    }

                    try {
                        const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: formData
                        });

                        if (response.ok) {
                            successCount++;
                        } else {
                            failCount++;
                            console.error(`파일 업로드 실패: ${fileData.name}`);
                        }

                    } catch (error) {
                        failCount++;
                        console.error(`파일 업로드 오류: ${fileData.name}`, error);
                    }
                }

                if (successCount > 0) {
                    alert(`✅ ${successCount}개의 스티커이 성공적으로 추가되었습니다.${failCount > 0 ? ` (실패: ${failCount}개)` : ''}`);
                    closeItemModal();
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`❌ 모든 업로드가 실패했습니다.`);
                }
            } finally {
                // 진행률 숨기기 및 버튼 상태 복원
                progressContainer.style.display = 'none';
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // 카테고리 수정
        function editCategory(categoryId) {
            console.log('editCategory called with categoryId:', categoryId);
            console.log('Available categories:', categories);
            
            // _id 또는 id 필드로 카테고리 찾기
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);
            console.log('Found category:', category);
            
            if (!category) {
                console.error('Category not found with ID:', categoryId);
                console.error('Available category IDs:', categories.map(c => c._id || c.id));
                alert('카테고리를 찾을 수 없습니다.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = '📁 카테고리 수정';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // 카테고리 삭제
        async function deleteCategory(categoryId) {
            console.log('deleteCategory called with categoryId:', categoryId);
            
            if (!confirm('정말로 이 카테고리를 삭제하시겠습니까? 모든 스티커도 함께 삭제됩니다.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 카테고리가 성공적으로 삭제되었습니다.');
                    loadCategories();
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('카테고리 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 스티커 삭제
        async function deleteItem(categoryId, itemId) {
            if (!confirm('정말로 이 스티커을 삭제하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items/${itemId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 스티커이 성공적으로 삭제되었습니다.');
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`❌ 삭제 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('스티커 삭제 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 썸네일 재생성
        async function regenerateThumbnail(categoryId, itemId) {
            if (!confirm('이 스티커의 썸네일을 재생성하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items/${itemId}/regenerate-thumbnail`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 썸네일이 성공적으로 재생성되었습니다.');
                    // 전체 새로고침 대신 해당 카테고리만 업데이트
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`❌ 썸네일 재생성 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('썸네일 재생성 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const categoryModal = document.getElementById('categoryModal');
            const itemModal = document.getElementById('itemModal');
            
            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === itemModal) {
                closeItemModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/login.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase 로그인 테스트 - AR 명함</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .login-section,
        .result-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .login-section {
            background-color: #f9f9f9;
        }

        .result-section {
            background-color: #f0f8f0;
            display: none;
        }

        .error-section {
            background-color: #fff0f0;
            display: none;
        }

        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .logout-btn {
            background-color: #dc3545;
        }

        .logout-btn:hover {
            background-color: #c82333;
        }

        .test-btn {
            background-color: #28a745;
        }

        .test-btn:hover {
            background-color: #218838;
        }

        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .user-info {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            margin: 10px 0;
        }

        .user-info strong {
            color: #495057;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🔥 Firebase Authentication 테스트</h1>

        <div class="login-section" style="background-color: #fff3cd; border: 1px solid #ffeaa7;">
            <h3>⚠️ 설정 필요</h3>
            <p><strong>테스트하기 전에 Firebase 설정을 완료해야 합니다:</strong></p>
            <ol>
                <li>Firebase Console에서 프로젝트 설정 → 웹 앱 추가</li>
                <li>Authentication → 로그인 방법 → Google 사용 설정</li>
                <li>이 HTML 파일의 <code>firebaseConfig</code>를 실제 값으로 교체</li>
                <li>승인된 도메인에 <code>localhost</code> 추가 (개발용)</li>
            </ol>
        </div>

        <div class="login-section">
            <h3>1. Firebase 로그인</h3>
            <p>Google 계정으로 로그인하여 Firebase ID 토큰을 받아옵니다.</p>
            <button id="loginBtn" onclick="signInWithGoogle()">Google로 로그인</button>
            <button id="logoutBtn" onclick="signOut()" class="logout-btn" style="display: none;">로그아웃</button>
            <div id="firebaseStatus"></div>
        </div>

        <div class="login-section">
            <h3>2. 백엔드 인증 테스트</h3>
            <p>받아온 Firebase ID 토큰을 백엔드로 전송하여 AR 명함 시스템 JWT를 받아옵니다.</p>
            <button id="testBackendBtn" onclick="testBackendAuth()" class="test-btn" disabled>백엔드 인증 테스트</button>
            <div id="backendStatus"></div>
        </div>

        <div id="resultSection" class="result-section">
            <h3>✅ 인증 성공 결과</h3>
            <div id="resultContent"></div>
        </div>

        <div id="errorSection" class="error-section">
            <h3>❌ 오류 정보</h3>
            <div id="errorContent"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut as firebaseSignOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

        // Firebase 설정 - 실제 프로젝트 정보로 업데이트 필요
        // 주의: 실제 사용 시에는 Firebase Console에서 정확한 설정값을 확인하여 교체하세요
        const firebaseConfig = {
            apiKey: "AIzaSyCIzVh3sVKobi_lFm8dQbx1IgnTOwIe1fM",
            authDomain: "hninepeople.firebaseapp.com",
            projectId: "hninepeople",
            storageBucket: "hninepeople.firebasestorage.app",
            messagingSenderId: "666601587213",
            appId: "1:666601587213:web:1f407eaa9c915856050b44"
        };

        // Firebase 초기화
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();

        let currentUser = null;
        let currentIdToken = null;

        // 전역 함수들을 window에 등록
        window.signInWithGoogle = async function () {
            const loginBtn = document.getElementById('loginBtn');
            const status = document.getElementById('firebaseStatus');

            try {
                loginBtn.disabled = true;
                status.innerHTML = '<div class="status loading">Google 로그인 중...</div>';

                const result = await signInWithPopup(auth, provider);
                currentUser = result.user;
                currentIdToken = await currentUser.getIdToken();

                updateUIAfterLogin();
                status.innerHTML = '<div class="status success">✅ Firebase 로그인 성공!</div>';

            } catch (error) {
                console.error('로그인 실패:', error);
                status.innerHTML = `<div class="status error">❌ 로그인 실패: ${error.message}</div>`;
                loginBtn.disabled = false;
            }
        };

        window.signOut = async function () {
            try {
                await firebaseSignOut(auth);
                currentUser = null;
                currentIdToken = null;
                updateUIAfterLogout();
                document.getElementById('firebaseStatus').innerHTML = '<div class="status success">✅ 로그아웃 완료</div>';
            } catch (error) {
                console.error('로그아웃 실패:', error);
            }
        };

        window.testBackendAuth = async function () {
            const testBtn = document.getElementById('testBackendBtn');
            const status = document.getElementById('backendStatus');
            const resultSection = document.getElementById('resultSection');
            const errorSection = document.getElementById('errorSection');

            if (!currentIdToken) {
                status.innerHTML = '<div class="status error">❌ 먼저 Firebase 로그인을 해주세요.</div>';
                return;
            }

            try {
                testBtn.disabled = true;
                status.innerHTML = '<div class="status loading">백엔드 인증 테스트 중...</div>';

                const response = await fetch('/api/auth/firebase/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        idToken: currentIdToken
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // 성공
                    status.innerHTML = '<div class="status success">✅ 백엔드 인증 성공!</div>';
                    displaySuccessResult(data);
                    resultSection.style.display = 'block';
                    errorSection.style.display = 'none';
                } else {
                    // 실패
                    status.innerHTML = '<div class="status error">❌ 백엔드 인증 실패</div>';
                    displayErrorResult(data, response.status);
                    resultSection.style.display = 'none';
                    errorSection.style.display = 'block';
                }

            } catch (error) {
                console.error('백엔드 인증 오류:', error);
                status.innerHTML = '<div class="status error">❌ 네트워크 오류: ' + error.message + '</div>';
                errorSection.style.display = 'block';
                document.getElementById('errorContent').innerHTML = `<pre>${JSON.stringify({ error: error.message }, null, 2)}</pre>`;
            } finally {
                testBtn.disabled = false;
            }
        };

        function updateUIAfterLogin() {
            document.getElementById('loginBtn').style.display = 'none';
            document.getElementById('logoutBtn').style.display = 'inline-block';
            document.getElementById('testBackendBtn').disabled = false;

            // Firebase 사용자 정보 표시
            const firebaseInfo = `
                <div class="user-info">
                    <strong>이름:</strong> <span>${currentUser.displayName || 'N/A'}</span>
                    <strong>이메일:</strong> <span>${currentUser.email}</span>
                    <strong>UID:</strong> <span>${currentUser.uid}</span>
                    <strong>ID 토큰:</strong> <span style="font-size: 10px; word-break: break-all;">${currentIdToken.substring(0, 50)}...</span>
                </div>
            `;
            document.getElementById('firebaseStatus').innerHTML += firebaseInfo;
        }

        function updateUIAfterLogout() {
            document.getElementById('loginBtn').style.display = 'inline-block';
            document.getElementById('loginBtn').disabled = false;
            document.getElementById('logoutBtn').style.display = 'none';
            document.getElementById('testBackendBtn').disabled = true;
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('backendStatus').innerHTML = '';
        }

        function displaySuccessResult(data) {
            const content = `
                <h4>🎉 AR 명함 시스템 인증 성공!</h4>
                <div class="user-info">
                    <strong>메시지:</strong> <span>${data.message}</span>
                    <strong>사용자 이름:</strong> <span>${data.user.nameKr} (${data.user.nameEn})</span>
                    <strong>이메일:</strong> <span>${data.user.email}</span>
                    <strong>AR ID:</strong> <span>${data.user.arId}</span>
                    <strong>역할:</strong> <span>${data.user.role}</span>
                    <strong>부서:</strong> <span>${data.user.part}</span>
                    <strong>관리자:</strong> <span>${data.user.isAdmin ? '예' : '아니오'}</span>
                    <strong>명함 활성화:</strong> <span>${data.user.isNamecardActive ? '예' : '아니오'}</span>
                </div>
                <h5>JWT 토큰:</h5>
                <pre>${data.token}</pre>
                <h5>전체 응답 데이터:</h5>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            document.getElementById('resultContent').innerHTML = content;
        }

        function displayErrorResult(data, status) {
            const content = `
                <h4>HTTP Status: ${status}</h4>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            document.getElementById('errorContent').innerHTML = content;
        }

        // 인증 상태 변화 감지
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log('사용자 로그인됨:', user.email);
            } else {
                console.log('사용자 로그아웃됨');
            }
        });
    </script>
</body>

</html>
</file>

<file path="public/test/user.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사용자 관리 테스트 - AR 명함</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], textarea {
            width: 200px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .page-info {
            color: #666;
            font-size: 14px;
        }

        .admin-badge {
            background-color: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        .active-badge {
            background-color: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>👥 사용자 관리 테스트 페이지</h1>

        <!-- 인증 섹션 -->
        <div class="section auth-section">
            <h3>🔐 관리자 인증</h3>
            <p>사용자 관리 기능을 사용하려면 관리자 권한이 필요합니다.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="관리자 JWT 토큰 입력" style="width: 400px;">
                <button onclick="setAuthToken()">토큰 설정</button>
                <button onclick="getAdminToken()" class="btn-success">관리자 토큰 생성</button>
                <button onclick="clearAuthToken()" class="btn-secondary">토큰 초기화</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- 사용자 추가 섹션 -->
        <div class="section">
            <h3>➕ 새 사용자 추가</h3>
            <button onclick="openCreateUserModal()" class="btn-success">새 사용자 추가</button>
        </div>

        <!-- 사용자 목록 섹션 -->
        <div class="section">
            <h3>📋 사용자 목록</h3>
            
            <!-- 검색 및 필터 컨트롤 -->
            <div class="controls">
                <input type="text" id="searchInput" placeholder="이름, 이메일, AR ID 검색">
                <select id="roleFilter">
                    <option value="">전체 역할</option>
                    <option value="User">User</option>
                    <option value="Admin">Admin</option>
                    <option value="Manager">Manager</option>
                </select>
                <select id="adminFilter">
                    <option value="">전체</option>
                    <option value="true">관리자만</option>
                    <option value="false">일반 사용자만</option>
                </select>
                <select id="activeFilter">
                    <option value="">전체</option>
                    <option value="true">활성화된 명함만</option>
                    <option value="false">비활성화된 명함만</option>
                </select>
                <button onclick="loadUsers()" class="btn-success">검색</button>
                <button onclick="clearFilters()" class="btn-secondary">필터 초기화</button>
            </div>

            <div id="userListStatus"></div>
            
            <!-- 사용자 테이블 -->
            <div id="userTableContainer">
                <table id="userTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>AR ID</th>
                            <th>이름</th>
                            <th>이메일</th>
                            <th>역할</th>
                            <th>부서</th>
                            <th>전화번호</th>
                            <th>상태</th>
                            <th>작업</th>
                        </tr>
                    </thead>
                    <tbody id="userTableBody">
                    </tbody>
                </table>
            </div>

            <!-- 페이지네이션 -->
            <div class="pagination" id="pagination" style="display: none;">
                <button onclick="changePage(-1)" id="prevBtn">이전</button>
                <span class="page-info" id="pageInfo"></span>
                <button onclick="changePage(1)" id="nextBtn">다음</button>
            </div>
        </div>
    </div>

    <!-- 사용자 편집 모달 -->
    <div id="editUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h3>✏️ 사용자 정보 수정</h3>
            <form id="editUserForm">
                <input type="hidden" id="editUserId">
                
                <div class="form-group">
                    <label>이메일 (수정 불가)</label>
                    <input type="email" id="editEmail" disabled>
                </div>
                
                <div class="form-group">
                    <label>AR ID (수정 불가)</label>
                    <input type="text" id="editArId" disabled>
                </div>
                
                <div class="form-group">
                    <label for="editNameKr">한글명 *</label>
                    <input type="text" id="editNameKr" required>
                </div>
                
                <div class="form-group">
                    <label for="editNameEn">영문명</label>
                    <input type="text" id="editNameEn">
                </div>
                
                <div class="form-group">
                    <label for="editRole">역할</label>
                    <input type="text" id="editRole">
                </div>
                
                <div class="form-group">
                    <label for="editPart">부서</label>
                    <input type="text" id="editPart">
                </div>
                
                <div class="form-group">
                    <label for="editPhone">전화번호 *</label>
                    <input type="tel" id="editPhone" required>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="editIsAdmin">
                        <label for="editIsAdmin">관리자 권한</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="editIsNamecardActive">
                        <label for="editIsNamecardActive">명함 활성화</label>
                    </div>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeEditModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success">저장</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 사용자 생성 모달 -->
    <div id="createUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCreateModal()">&times;</span>
            <h3>➕ 새 사용자 추가</h3>
            <form id="createUserForm">
                <div class="form-group">
                    <label for="createEmail">이메일 *</label>
                    <input type="email" id="createEmail" required>
                </div>
                
                <div class="form-group">
                    <label for="createArId">AR ID * (3자리)</label>
                    <input type="text" id="createArId" maxlength="3" required>
                </div>
                
                <div class="form-group">
                    <label for="createNameKr">한글명 *</label>
                    <input type="text" id="createNameKr" required>
                </div>
                
                <div class="form-group">
                    <label for="createNameEn">영문명</label>
                    <input type="text" id="createNameEn">
                </div>
                
                <div class="form-group">
                    <label for="createRole">역할</label>
                    <input type="text" id="createRole" value="User">
                </div>
                
                <div class="form-group">
                    <label for="createPart">부서</label>
                    <input type="text" id="createPart">
                </div>
                
                <div class="form-group">
                    <label for="createPhone">전화번호 *</label>
                    <input type="tel" id="createPhone" required>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="createIsAdmin">
                        <label for="createIsAdmin">관리자 권한</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="createIsNamecardActive">
                        <label for="createIsNamecardActive">명함 활성화</label>
                    </div>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCreateModal()" class="btn-secondary">취소</button>
                    <button type="submit" class="btn-success">추가</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let currentPage = 1;
        let totalPages = 1;
        let users = [];

        // 인증 토큰 설정
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', '토큰을 입력해주세요.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', '✅ 관리자 토큰이 설정되었습니다.');
            
            // 토큰 설정 후 사용자 목록 자동 로드
            loadUsers();
        }

        // 관리자 토큰 생성
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', '관리자 토큰을 생성하는 중...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `✅ 관리자 토큰이 생성되었습니다. (사용자: ${data.user.nameKr})`);
                    
                    // 토큰 생성 후 사용자 목록 자동 로드
                    loadUsers();
                } else {
                    showStatus('authStatus', 'error', `❌ 토큰 생성 실패: ${data.message || '관리자 사용자를 찾을 수 없습니다.'}`);
                }

            } catch (error) {
                console.error('토큰 생성 오류:', error);
                showStatus('authStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 토큰 초기화
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', '🔄 토큰이 초기화되었습니다.');
            
            // 사용자 테이블 숨기기
            document.getElementById('userTable').style.display = 'none';
            document.getElementById('pagination').style.display = 'none';
        }

        // 페이지 로드 시 저장된 토큰 복원
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', '✅ 저장된 토큰을 불러왔습니다.');
                loadUsers();
            }
        });

        // 상태 메시지 표시
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // 사용자 목록 로드
        async function loadUsers(page = 1) {
            if (!currentToken) {
                showStatus('userListStatus', 'error', '❌ 먼저 관리자 토큰을 설정해주세요.');
                return;
            }

            const searchInput = document.getElementById('searchInput').value.trim();
            const roleFilter = document.getElementById('roleFilter').value;
            const adminFilter = document.getElementById('adminFilter').value;
            const activeFilter = document.getElementById('activeFilter').value;

            try {
                showStatus('userListStatus', 'loading', '사용자 목록을 불러오는 중...');

                const params = new URLSearchParams({
                    page: page.toString(),
                    limit: '10'
                });

                if (searchInput) params.append('search', searchInput);
                if (roleFilter) params.append('role', roleFilter);
                if (adminFilter) params.append('isAdmin', adminFilter);
                if (activeFilter) params.append('isNamecardActive', activeFilter);

                const response = await fetch(`/api/admin/users?${params}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    users = data.users;
                    currentPage = data.currentPage;
                    totalPages = data.totalPages;
                    
                    renderUserTable();
                    renderPagination();
                    
                    showStatus('userListStatus', 'success', `✅ ${data.total}명의 사용자를 찾았습니다.`);
                } else {
                    showStatus('userListStatus', 'error', `❌ ${data.message || '사용자 목록 로드 실패'}`);
                }

            } catch (error) {
                console.error('사용자 목록 로드 오류:', error);
                showStatus('userListStatus', 'error', `❌ 네트워크 오류: ${error.message}`);
            }
        }

        // 사용자 테이블 렌더링
        function renderUserTable() {
            const tbody = document.getElementById('userTableBody');
            tbody.innerHTML = '';

            users.forEach(user => {
                // ID 필드 확인 - _id 또는 id 사용
                const userId = user._id || user.id;
                console.log('User object:', user);
                console.log('User ID:', userId);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${user.arId}</td>
                    <td>${user.nameKr}${user.nameEn ? ' (' + user.nameEn + ')' : ''}</td>
                    <td>${user.email}</td>
                    <td>${user.role}</td>
                    <td>${user.part}</td>
                    <td>${user.phone}</td>
                    <td>
                        ${user.isAdmin ? '<span class="admin-badge">관리자</span>' : ''}
                        ${user.isNamecardActive ? '<span class="active-badge">활성</span>' : ''}
                    </td>
                    <td>
                        <button onclick="openEditModal('${userId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">수정</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('userTable').style.display = 'table';
        }

        // 페이지네이션 렌더링
        function renderPagination() {
            const pagination = document.getElementById('pagination');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            pageInfo.textContent = `${currentPage} / ${totalPages} 페이지`;
            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;

            pagination.style.display = 'flex';
        }

        // 페이지 변경
        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                loadUsers(newPage);
            }
        }

        // 필터 초기화
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('roleFilter').value = '';
            document.getElementById('adminFilter').value = '';
            document.getElementById('activeFilter').value = '';
            loadUsers(1);
        }

        // 사용자 편집 모달 열기
        function openEditModal(userId) {
            console.log('openEditModal called with userId:', userId);
            console.log('Available users:', users);
            
            // _id 또는 id 필드로 사용자 찾기
            const user = users.find(u => u._id === userId || u.id === userId);
            console.log('Found user:', user);
            
            if (!user) {
                console.error('User not found with ID:', userId);
                console.error('Available user IDs:', users.map(u => u._id || u.id));
                alert('사용자를 찾을 수 없습니다.');
                return;
            }

            // 모달 요소 확인
            const modal = document.getElementById('editUserModal');
            if (!modal) {
                console.error('Edit modal element not found');
                alert('편집 모달을 찾을 수 없습니다.');
                return;
            }

            try {
                document.getElementById('editUserId').value = user._id || user.id;
                document.getElementById('editEmail').value = user.email;
                document.getElementById('editArId').value = user.arId;
                document.getElementById('editNameKr').value = user.nameKr;
                document.getElementById('editNameEn').value = user.nameEn || '';
                document.getElementById('editRole').value = user.role;
                document.getElementById('editPart').value = user.part;
                document.getElementById('editPhone').value = user.phone;
                document.getElementById('editIsAdmin').checked = user.isAdmin;
                document.getElementById('editIsNamecardActive').checked = user.isNamecardActive;

                console.log('Modal display before:', modal.style.display);
                
                // CSS 클래스와 인라인 스타일 모두 적용
                modal.classList.add('show');
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.zIndex = '9999';
                
                console.log('Modal display after:', modal.style.display);
                console.log('Modal classList:', modal.classList.toString());
                
            } catch (error) {
                console.error('Error opening edit modal:', error);
                alert('모달을 여는 중 오류가 발생했습니다: ' + error.message);
            }
        }

        // 사용자 편집 모달 닫기
        function closeEditModal() {
            const modal = document.getElementById('editUserModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 사용자 생성 모달 열기
        function openCreateUserModal() {
            document.getElementById('createUserForm').reset();
            document.getElementById('createRole').value = 'User';
            
            const modal = document.getElementById('createUserModal');
            modal.classList.add('show');
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.zIndex = '9999';
        }

        // 사용자 생성 모달 닫기
        function closeCreateModal() {
            const modal = document.getElementById('createUserModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // 사용자 정보 수정
        document.getElementById('editUserForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('관리자 토큰이 설정되지 않았습니다.');
                return;
            }

            const userId = document.getElementById('editUserId').value;
            const updateData = {
                nameKr: document.getElementById('editNameKr').value,
                nameEn: document.getElementById('editNameEn').value,
                role: document.getElementById('editRole').value,
                part: document.getElementById('editPart').value,
                phone: document.getElementById('editPhone').value,
                isAdmin: document.getElementById('editIsAdmin').checked,
                isNamecardActive: document.getElementById('editIsNamecardActive').checked
            };

            try {
                const response = await fetch(`/api/admin/users/${userId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 사용자 정보가 성공적으로 수정되었습니다.');
                    closeEditModal();
                    loadUsers(currentPage);
                } else {
                    alert(`❌ 수정 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('사용자 수정 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        });

        // 새 사용자 생성
        document.getElementById('createUserForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const createData = {
                email: document.getElementById('createEmail').value,
                arId: document.getElementById('createArId').value,
                nameKr: document.getElementById('createNameKr').value,
                nameEn: document.getElementById('createNameEn').value,
                role: document.getElementById('createRole').value,
                part: document.getElementById('createPart').value,
                phone: document.getElementById('createPhone').value,
                isAdmin: document.getElementById('createIsAdmin').checked,
                isNamecardActive: document.getElementById('createIsNamecardActive').checked
            };

            try {
                const response = await fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(createData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert('✅ 새 사용자가 성공적으로 추가되었습니다.');
                    closeCreateModal();
                    loadUsers(currentPage);
                } else {
                    alert(`❌ 사용자 추가 실패: ${data.message}`);
                }

            } catch (error) {
                console.error('사용자 생성 오류:', error);
                alert(`❌ 네트워크 오류: ${error.message}`);
            }
        });

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const editModal = document.getElementById('editUserModal');
            const createModal = document.getElementById('createUserModal');
            
            if (event.target === editModal) {
                closeEditModal();
            }
            if (event.target === createModal) {
                closeCreateModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="scripts/generate-ssl-cert-fixed.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL 디렉토리 생성
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// 로컬 IP 주소 찾기
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`🔍 로컬 IP 주소: ${localIp}`);

// 개선된 OpenSSL 설정 파일 생성
const opensslConfig = `
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
C = KR
ST = Seoul
L = Seoul
O = AR Namecard Dev
OU = Development
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
DNS.3 = 127.0.0.1
DNS.4 = ${localIp}
IP.1 = 127.0.0.1
IP.2 = ::1
IP.3 = ${localIp}
IP.4 = 192.168.1.1
IP.5 = 10.0.0.1
`;

const configPath = path.join(sslDir, 'openssl.conf');
fs.writeFileSync(configPath, opensslConfig);

try {
  console.log('🔐 개선된 SSL 인증서 생성 중...');
  
  // 기존 인증서 백업
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath)) {
    fs.renameSync(keyPath, keyPath + '.backup');
    console.log('📦 기존 개인키 백업 완료');
  }
  
  if (fs.existsSync(certPath)) {
    fs.renameSync(certPath, certPath + '.backup');
    console.log('📦 기존 인증서 백업 완료');
  }
  
  // 개인키 생성 (RSA 2048비트)
  console.log('🔑 개인키 생성 중...');
  execSync(`openssl genrsa -out "${keyPath}" 2048`, { stdio: 'inherit' });
  
  // 인증서 생성 (365일 유효)
  console.log('📜 인증서 생성 중...');
  execSync(`openssl req -new -x509 -key "${keyPath}" -out "${certPath}" -days 365 -config "${configPath}"`, { stdio: 'inherit' });
  
  // 인증서 검증
  console.log('🔍 인증서 검증 중...');
  const certInfo = execSync(`openssl x509 -in "${certPath}" -text -noout`, { encoding: 'utf8' });
  
  console.log('✅ SSL 인증서 생성 완료!');
  console.log(`📁 인증서 위치: ${sslDir}`);
  console.log(`🔑 개인키: ${keyPath}`);
  console.log(`📜 인증서: ${certPath}`);
  
  // 설정 파일 삭제
  fs.unlinkSync(configPath);
  
  console.log('\n🚀 HTTPS 서버 설정:');
  console.log('1. .env 파일에 ENABLE_HTTPS=true 설정');
  console.log('2. npm run dev 또는 npm start로 서버 실행');
  console.log(`3. https://localhost:3443 또는 https://${localIp}:3443 접속`);
  
  console.log('\n⚠️  브라우저 경고 해결 방법:');
  console.log('- Chrome: "고급" → "localhost(안전하지 않음)로 이동" 클릭');
  console.log('- Firefox: "고급" → "위험을 감수하고 계속" 클릭');
  console.log('- Safari: "고급" → "웹사이트 방문" 클릭');
  
  console.log('\n🔒 인증서 정보:');
  console.log(`- 유효기간: 365일`);
  console.log(`- 지원 도메인: localhost, ${localIp}`);
  console.log(`- 키 사용: digitalSignature, keyEncipherment`);
  console.log(`- 확장 키 사용: serverAuth, clientAuth`);
  
} catch (error) {
  console.error('❌ SSL 인증서 생성 실패:', error.message);
  console.log('\n💡 OpenSSL이 설치되지 않은 경우:');
  console.log('- macOS: brew install openssl');
  console.log('- Ubuntu: sudo apt-get install openssl');
  console.log('- Windows: https://slproweb.com/products/Win32OpenSSL.html');
  
  // 백업 파일 복구
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath + '.backup')) {
    fs.renameSync(keyPath + '.backup', keyPath);
    console.log('🔄 기존 개인키 복구 완료');
  }
  
  if (fs.existsSync(certPath + '.backup')) {
    fs.renameSync(certPath + '.backup', certPath);
    console.log('🔄 기존 인증서 복구 완료');
  }
  
  process.exit(1);
}
</file>

<file path="scripts/generate-ssl-cert.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL 디렉토리 생성
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// 로컬 IP 주소 찾기
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`🔍 로컬 IP 주소: ${localIp}`);

// OpenSSL 설정 파일 생성
const opensslConfig = `
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
C = KR
ST = Seoul
L = Seoul
O = AR Namecard Dev
CN = localhost

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
IP.1 = 127.0.0.1
IP.2 = ::1
IP.3 = ${localIp}
`;

const configPath = path.join(sslDir, 'openssl.conf');
fs.writeFileSync(configPath, opensslConfig);

try {
  console.log('🔐 SSL 인증서 생성 중...');
  
  // 개인키 생성
  const keyPath = path.join(sslDir, 'server.key');
  execSync(`openssl genrsa -out "${keyPath}" 2048`, { stdio: 'inherit' });
  
  // 인증서 생성
  const certPath = path.join(sslDir, 'server.crt');
  execSync(`openssl req -new -x509 -key "${keyPath}" -out "${certPath}" -days 365 -config "${configPath}"`, { stdio: 'inherit' });
  
  console.log('✅ SSL 인증서 생성 완료!');
  console.log(`📁 인증서 위치: ${sslDir}`);
  console.log(`🔑 개인키: ${keyPath}`);
  console.log(`📜 인증서: ${certPath}`);
  
  // 설정 파일 삭제
  fs.unlinkSync(configPath);
  
  console.log('\n🚀 HTTPS 서버 설정:');
  console.log('1. .env 파일에 ENABLE_HTTPS=true 설정');
  console.log('2. npm run dev 또는 npm start로 서버 실행');
  console.log(`3. https://localhost:3443 또는 https://${localIp}:3443 접속`);
  
  console.log('\n⚠️  브라우저 경고 해결 방법:');
  console.log('- Chrome: "고급" → "localhost(안전하지 않음)로 이동" 클릭');
  console.log('- Firefox: "고급" → "위험을 감수하고 계속" 클릭');
  console.log('- 또는 로컬 CA 설정으로 신뢰할 수 있는 인증서 만들기');
  
} catch (error) {
  console.error('❌ SSL 인증서 생성 실패:', error.message);
  console.log('\n💡 OpenSSL이 설치되지 않은 경우:');
  console.log('- macOS: brew install openssl');
  console.log('- Ubuntu: sudo apt-get install openssl');
  console.log('- Windows: https://slproweb.com/products/Win32OpenSSL.html');
  process.exit(1);
}
</file>

<file path="scripts/migrate-avatar-colors.js">
const mongoose = require('mongoose');
const dotenv = require('dotenv');

// .env 파일 로드
dotenv.config();

// MongoDB 연결
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/ar_namecard');
    console.log('✅ MongoDB 연결 성공');
  } catch (error) {
    console.error('❌ MongoDB 연결 실패:', error);
    process.exit(1);
  }
};

// AvatarCategory 스키마 정의
const avatarOptionSchema = new mongoose.Schema({
  name: String,
  imageUrl: String,
  modelUrl: String,
  thumbnailUrl: String,
  thumbnailSource: String,
  color: mongoose.Schema.Types.Mixed, // 다양한 타입 허용
  order: Number
}, { timestamps: true });

const avatarCategorySchema = new mongoose.Schema({
  name: String,
  type: String,
  options: [avatarOptionSchema],
  order: Number
}, { timestamps: true });

const AvatarCategory = mongoose.model('AvatarCategory', avatarCategorySchema);

// 마이그레이션 함수
async function migrateAvatarColors() {
  try {
    console.log('🔄 아바타 컬러 데이터 마이그레이션 시작...');
    
    const categories = await AvatarCategory.find({});
    let totalUpdated = 0;
    
    for (const category of categories) {
      let categoryUpdated = false;
      
      for (const option of category.options) {
        // 잘못된 형태의 color 데이터 감지
        if (option.color && typeof option.color === 'object' && !Array.isArray(option.color)) {
          // 객체 형태로 저장된 경우 (예: {"0": "#", "1": "0", ...})
          if (option.color.hasOwnProperty('0') && option.color.hasOwnProperty('1')) {
            console.log(`🔧 잘못된 컬러 데이터 발견: ${category.name} - ${option.name}`);
            
            // 원본 색상 문자열 복원
            let colorString = '';
            for (let i = 0; option.color.hasOwnProperty(i.toString()); i++) {
              colorString += option.color[i.toString()];
            }
            
            console.log(`   복원된 컬러: ${colorString}`);
            
            // 새로운 형태로 변환
            if (colorString && option.imageUrl) {
              const colorName = colorString === '#000000' ? 'Black' : 
                              colorString === '#ffffff' ? 'White' : 
                              colorString.startsWith('#') ? colorString : 'Default';
              
              option.color = [{
                colorName: colorName,
                imageUrl: option.imageUrl
              }];
              
              categoryUpdated = true;
              totalUpdated++;
              console.log(`   ✅ 변환 완료: ${colorName}`);
            }
          }
        }
        // 문자열 형태의 color 데이터 변환
        else if (typeof option.color === 'string' && option.imageUrl) {
          console.log(`🔧 문자열 컬러 데이터 변환: ${category.name} - ${option.name} (${option.color})`);
          
          const colorName = option.color === '#000000' ? 'Black' : 
                          option.color === '#ffffff' ? 'White' : 
                          option.color;
          
          option.color = [{
            colorName: colorName,
            imageUrl: option.imageUrl
          }];
          
          categoryUpdated = true;
          totalUpdated++;
          console.log(`   ✅ 변환 완료: ${colorName}`);
        }
        // color가 없고 imageUrl만 있는 경우
        else if (!option.color && option.imageUrl) {
          console.log(`🔧 컬러 없는 옵션 처리: ${category.name} - ${option.name}`);
          
          option.color = [{
            colorName: 'Default',
            imageUrl: option.imageUrl
          }];
          
          categoryUpdated = true;
          totalUpdated++;
          console.log(`   ✅ 기본 컬러 옵션 생성`);
        }
      }
      
      if (categoryUpdated) {
        await category.save();
        console.log(`💾 카테고리 저장 완료: ${category.name}`);
      }
    }
    
    console.log(`\n🎉 마이그레이션 완료!`);
    console.log(`   - 총 ${totalUpdated}개의 옵션이 업데이트되었습니다.`);
    
  } catch (error) {
    console.error('❌ 마이그레이션 중 오류:', error);
  }
}

// 실행
async function main() {
  await connectDB();
  await migrateAvatarColors();
  
  console.log('\n🔍 마이그레이션 결과 확인...');
  
  // 결과 확인
  const categories = await AvatarCategory.find({}).limit(2);
  for (const category of categories) {
    console.log(`\n📂 ${category.name}:`);
    for (const option of category.options.slice(0, 2)) {
      console.log(`   - ${option.name}: ${JSON.stringify(option.color, null, 2)}`);
    }
  }
  
  console.log('\n✨ 작업 완료! MongoDB 연결을 종료합니다.');
  await mongoose.connection.close();
}

main().catch(console.error);
</file>

<file path="scripts/migrate-uploads-to-firebase.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import { uploadToFirebase } from '../src/config/firebase-storage';

// 환경변수 로드
dotenv.config({ path: '.env.local' });

interface FileMapping {
  localPath: string;
  firebaseUrl: string;
  firebasePath: string;
  success: boolean;
  error?: string;
}

interface MigrationResult {
  total: number;
  success: number;
  failed: number;
  mappings: FileMapping[];
}

// 지원되는 파일 확장자
const SUPPORTED_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.pdf', '.doc', '.docx'];

// Firebase에 업로드할 파일인지 확인
const isUploadableFile = (filename: string): boolean => {
  const ext = path.extname(filename).toLowerCase();
  return SUPPORTED_EXTENSIONS.includes(ext) && !filename.startsWith('.');
};

// 로컬 파일을 Firebase Storage로 업로드
const uploadFileToFirebase = async (
  localFilePath: string, 
  relativePath: string
): Promise<FileMapping> => {
  const mapping: FileMapping = {
    localPath: localFilePath,
    firebaseUrl: '',
    firebasePath: '',
    success: false
  };

  try {
    // 파일 읽기
    const fileBuffer = await fs.readFile(localFilePath);
    const stats = await fs.stat(localFilePath);
    
    // MIME 타입 추정
    const ext = path.extname(localFilePath).toLowerCase();
    let mimetype = 'application/octet-stream';
    if (ext === '.png') mimetype = 'image/png';
    else if (ext === '.jpg' || ext === '.jpeg') mimetype = 'image/jpeg';
    else if (ext === '.gif') mimetype = 'image/gif';
    else if (ext === '.pdf') mimetype = 'application/pdf';

    // Express.Multer.File 형태로 변환
    const file: Express.Multer.File = {
      fieldname: 'file',
      originalname: path.basename(localFilePath),
      encoding: '7bit',
      mimetype: mimetype,
      buffer: fileBuffer,
      size: stats.size,
      destination: '',
      filename: '',
      path: '',
      stream: null as any,
    };

    // Firebase Storage에 업로드
    const result = await uploadToFirebase(file, relativePath);
    
    mapping.firebaseUrl = result.url;
    mapping.firebasePath = result.path;
    mapping.success = true;
    
    console.log(`✅ ${localFilePath} → ${result.url}`);
    
  } catch (error) {
    mapping.error = error instanceof Error ? error.message : String(error);
    mapping.success = false;
    console.error(`❌ ${localFilePath}: ${mapping.error}`);
  }

  return mapping;
};

// 디렉토리 재귀 스캔
const scanDirectory = async (dirPath: string, baseDir: string): Promise<string[]> => {
  const files: string[] = [];
  
  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      
      if (entry.isDirectory()) {
        // 하위 디렉토리 재귀 스캔
        const subFiles = await scanDirectory(fullPath, baseDir);
        files.push(...subFiles);
      } else if (entry.isFile() && isUploadableFile(entry.name)) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`디렉토리 스캔 오류 (${dirPath}):`, error);
  }
  
  return files;
};

// 메인 마이그레이션 함수
const migrateUploadToFirebase = async (): Promise<MigrationResult> => {
  console.log('🚀 Firebase Storage 마이그레이션 시작...\n');
  
  const uploadsDir = path.join(process.cwd(), 'uploads');
  const result: MigrationResult = {
    total: 0,
    success: 0,
    failed: 0,
    mappings: []
  };

  try {
    // uploads 디렉토리 존재 확인
    await fs.access(uploadsDir);
    
    // 모든 파일 스캔
    console.log('📁 파일 스캔 중...');
    const allFiles = await scanDirectory(uploadsDir, uploadsDir);
    result.total = allFiles.length;
    
    console.log(`📊 총 ${result.total}개 파일 발견\n`);
    
    if (result.total === 0) {
      console.log('업로드할 파일이 없습니다.');
      return result;
    }

    // 파일별 업로드 진행
    for (let i = 0; i < allFiles.length; i++) {
      const filePath = allFiles[i];
      const relativePath = path.relative(uploadsDir, filePath).replace(/\\/g, '/');
      const folderPath = path.dirname(relativePath) === '.' ? 'uploads/' : `uploads/${path.dirname(relativePath)}/`;
      
      console.log(`[${i + 1}/${result.total}] ${relativePath}`);
      
      const mapping = await uploadFileToFirebase(filePath, folderPath);
      result.mappings.push(mapping);
      
      if (mapping.success) {
        result.success++;
      } else {
        result.failed++;
      }
      
      // 진행률 표시
      const progress = Math.round((i + 1) / result.total * 100);
      console.log(`진행률: ${progress}%\n`);
    }

    // 결과 저장
    const mappingFile = path.join(process.cwd(), 'migration-mapping.json');
    await fs.writeFile(mappingFile, JSON.stringify(result, null, 2));
    console.log(`📄 매핑 파일 저장: ${mappingFile}`);

  } catch (error) {
    console.error('❌ 마이그레이션 오류:', error);
    throw error;
  }

  return result;
};

// 스크립트 실행
const main = async () => {
  try {
    const result = await migrateUploadToFirebase();
    
    console.log('\n🎉 마이그레이션 완료!');
    console.log('='.repeat(50));
    console.log(`총 파일: ${result.total}`);
    console.log(`성공: ${result.success}`);
    console.log(`실패: ${result.failed}`);
    console.log(`성공률: ${Math.round(result.success / result.total * 100)}%`);
    
    if (result.failed > 0) {
      console.log('\n❌ 실패한 파일들:');
      result.mappings
        .filter(m => !m.success)
        .forEach(m => {
          console.log(`  - ${m.localPath}: ${m.error}`);
        });
    }
    
    console.log('\n✅ Firebase Storage 마이그레이션이 완료되었습니다!');
    
  } catch (error) {
    console.error('💥 마이그레이션 실패:', error);
    process.exit(1);
  }
};

// 스크립트가 직접 실행된 경우에만 main 함수 호출
if (require.main === module) {
  main();
}

export { migrateUploadToFirebase, FileMapping, MigrationResult };
</file>

<file path="scripts/setup-mkcert.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL 디렉토리 생성
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// 로컬 IP 주소 찾기
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`🔍 로컬 IP 주소: ${localIp}`);

// mkcert 설치 확인
function checkMkcert() {
  try {
    execSync('mkcert -version', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

// mkcert 설치 안내
function installMkcert() {
  console.log('📦 mkcert 설치가 필요합니다.');
  console.log('다음 명령어로 설치하세요:');
  
  const platform = os.platform();
  switch (platform) {
    case 'darwin':
      console.log('🍎 macOS:');
      console.log('  brew install mkcert');
      console.log('  brew install nss  # Firefox 지원용');
      break;
    case 'linux':
      console.log('🐧 Linux:');
      console.log('  # Ubuntu/Debian:');
      console.log('  sudo apt install libnss3-tools');
      console.log('  curl -JLO "https://dl.filippo.io/mkcert/latest?for=linux/amd64"');
      console.log('  chmod +x mkcert-v*-linux-amd64');
      console.log('  sudo mv mkcert-v*-linux-amd64 /usr/local/bin/mkcert');
      break;
    case 'win32':
      console.log('🪟 Windows:');
      console.log('  choco install mkcert');
      console.log('  # 또는 수동 다운로드: https://github.com/FiloSottile/mkcert/releases');
      break;
    default:
      console.log('💻 기타 플랫폼: https://github.com/FiloSottile/mkcert#installation');
  }
  
  console.log('\n설치 후 다시 실행하세요: node scripts/setup-mkcert.js');
  process.exit(1);
}

try {
  // mkcert 설치 확인
  if (!checkMkcert()) {
    installMkcert();
  }
  
  console.log('✅ mkcert가 설치되어 있습니다.');
  
  // 로컬 CA 설치 (처음 실행 시에만)
  console.log('🔐 로컬 CA 설치 중...');
  try {
    execSync('mkcert -install', { stdio: 'inherit' });
    console.log('✅ 로컬 CA 설치 완료');
  } catch (error) {
    console.log('ℹ️  로컬 CA가 이미 설치되어 있습니다.');
  }
  
  // 기존 인증서 백업
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath)) {
    fs.renameSync(keyPath, keyPath + '.backup');
    console.log('📦 기존 개인키 백업 완료');
  }
  
  if (fs.existsSync(certPath)) {
    fs.renameSync(certPath, certPath + '.backup');
    console.log('📦 기존 인증서 백업 완료');
  }
  
  // mkcert로 신뢰할 수 있는 인증서 생성
  console.log('📜 신뢰할 수 있는 SSL 인증서 생성 중...');
  const certCommand = `mkcert -key-file "${keyPath}" -cert-file "${certPath}" localhost 127.0.0.1 ::1 ${localIp}`;
  
  execSync(certCommand, { stdio: 'inherit', cwd: sslDir });
  
  console.log('✅ SSL 인증서 생성 완료!');
  console.log(`📁 인증서 위치: ${sslDir}`);
  console.log(`🔑 개인키: ${keyPath}`);
  console.log(`📜 인증서: ${certPath}`);
  
  console.log('\n🚀 HTTPS 서버 설정:');
  console.log('1. .env 파일에 ENABLE_HTTPS=true 설정');
  console.log('2. npm run dev 또는 npm start로 서버 실행');
  console.log(`3. https://localhost:3443 또는 https://${localIp}:3443 접속`);
  
  console.log('\n🎉 브라우저 경고 없음!');
  console.log('- mkcert로 생성된 인증서는 브라우저에서 신뢰됩니다.');
  console.log('- 별도의 경고 무시 작업이 필요하지 않습니다.');
  
  console.log('\n🔒 인증서 정보:');
  console.log(`- 유효기간: 약 10년`);
  console.log(`- 지원 도메인: localhost, 127.0.0.1, ${localIp}`);
  console.log(`- 브라우저 신뢰: Chrome, Firefox, Safari 모두 지원`);
  
} catch (error) {
  console.error('❌ SSL 인증서 생성 실패:', error.message);
  
  // 백업 파일 복구
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath + '.backup')) {
    fs.renameSync(keyPath + '.backup', keyPath);
    console.log('🔄 기존 개인키 복구 완료');
  }
  
  if (fs.existsSync(certPath + '.backup')) {
    fs.renameSync(certPath + '.backup', certPath);
    console.log('🔄 기존 인증서 복구 완료');
  }
  
  process.exit(1);
}
</file>

<file path="scripts/update-db-urls-to-firebase.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import mongoose from 'mongoose';

// 환경변수 로드 - 필요시 .env.atlas로 변경 가능
dotenv.config({ path: '.env.local' });

interface FileMapping {
  localPath: string;
  firebaseUrl: string;
  firebasePath: string;
  success: boolean;
  error?: string;
}

interface MigrationMappings {
  total: number;
  success: number;
  failed: number;
  mappings: FileMapping[];
}

interface UpdateResult {
  collection: string;
  field: string;
  documentId: string;
  oldValue: string;
  newValue: string;
  success: boolean;
  error?: string;
}

interface DatabaseUpdateResult {
  totalUpdates: number;
  successfulUpdates: number;
  failedUpdates: number;
  updates: UpdateResult[];
  collections: {
    [collectionName: string]: {
      documentsUpdated: number;
      fieldsUpdated: number;
    };
  };
}

// URL 매핑 생성 함수
const createUrlMapping = (mappings: FileMapping[]): Map<string, string> => {
  const urlMap = new Map<string, string>();
  
  mappings.forEach(mapping => {
    if (mapping.success && mapping.localPath && mapping.firebaseUrl) {
      // 절대 경로에서 /uploads/filename 추출
      const filename = path.basename(mapping.localPath);
      const localUrl = `/uploads/${filename}`;
      urlMap.set(localUrl, mapping.firebaseUrl);
      
      // 하위 폴더가 있는 경우도 처리
      const relativePath = mapping.localPath.split('/uploads/')[1];
      if (relativePath && relativePath !== filename) {
        const localUrlWithFolder = `/uploads/${relativePath}`;
        urlMap.set(localUrlWithFolder, mapping.firebaseUrl);
      }
    }
  });
  
  return urlMap;
};

// URL 업데이트 함수
const updateUrlInValue = (value: any, urlMap: Map<string, string>): { updated: boolean; newValue: any; changes: Array<{oldUrl: string; newUrl: string}> } => {
  const changes: Array<{oldUrl: string; newUrl: string}> = [];
  let updated = false;
  let newValue = value;

  if (typeof value === 'string' && value.startsWith('/uploads/')) {
    const firebaseUrl = urlMap.get(value);
    if (firebaseUrl) {
      changes.push({ oldUrl: value, newUrl: firebaseUrl });
      newValue = firebaseUrl;
      updated = true;
    }
  } else if (Array.isArray(value)) {
    const newArray = value.map(item => {
      const result = updateUrlInValue(item, urlMap);
      if (result.updated) {
        updated = true;
        changes.push(...result.changes);
      }
      return result.newValue;
    });
    if (updated) {
      newValue = newArray;
    }
  } else if (value && typeof value === 'object') {
    const newObject = { ...value };
    for (const [key, val] of Object.entries(value)) {
      const result = updateUrlInValue(val, urlMap);
      if (result.updated) {
        updated = true;
        changes.push(...result.changes);
        newObject[key] = result.newValue;
      }
    }
    if (updated) {
      newValue = newObject;
    }
  }

  return { updated, newValue, changes };
};

// avatarcategories 컬렉션 업데이트
const updateAvatarCategories = async (urlMap: Map<string, string>): Promise<UpdateResult[]> => {
  console.log('🔄 avatarcategories 컬렉션 업데이트 중...');
  
  const results: UpdateResult[] = [];
  const AvatarCategory = mongoose.model('AvatarCategory', new mongoose.Schema({}, { strict: false }));
  
  try {
    const categories = await AvatarCategory.find({});
    console.log(`📊 avatarcategories: ${categories.length}개 문서 발견`);
    
    for (const category of categories) {
      const categoryObj = category.toObject() as any;
      let documentUpdated = false;
      const documentUpdates: UpdateResult[] = [];
      
      if (categoryObj.options && Array.isArray(categoryObj.options)) {
        for (let optionIndex = 0; optionIndex < categoryObj.options.length; optionIndex++) {
          const option = categoryObj.options[optionIndex];
          
          // imageUrl 업데이트
          if (option.imageUrl) {
            const result = updateUrlInValue(option.imageUrl, urlMap);
            if (result.updated) {
              option.imageUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'avatarcategories',
                field: `options[${optionIndex}].imageUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // thumbnailUrl 업데이트
          if (option.thumbnailUrl) {
            const result = updateUrlInValue(option.thumbnailUrl, urlMap);
            if (result.updated) {
              option.thumbnailUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'avatarcategories',
                field: `options[${optionIndex}].thumbnailUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // color 배열 업데이트
          if (option.color && Array.isArray(option.color)) {
            for (let colorIndex = 0; colorIndex < option.color.length; colorIndex++) {
              const colorOption = option.color[colorIndex];
              
              // imageUrl
              if (colorOption.imageUrl) {
                const result = updateUrlInValue(colorOption.imageUrl, urlMap);
                if (result.updated) {
                  colorOption.imageUrl = result.newValue;
                  documentUpdated = true;
                  documentUpdates.push({
                    collection: 'avatarcategories',
                    field: `options[${optionIndex}].color[${colorIndex}].imageUrl`,
                    documentId: (category._id as any).toString(),
                    oldValue: result.changes[0].oldUrl,
                    newValue: result.changes[0].newUrl,
                    success: true
                  });
                }
              }
              
              // paletteImageUrl
              if (colorOption.paletteImageUrl) {
                const result = updateUrlInValue(colorOption.paletteImageUrl, urlMap);
                if (result.updated) {
                  colorOption.paletteImageUrl = result.newValue;
                  documentUpdated = true;
                  documentUpdates.push({
                    collection: 'avatarcategories',
                    field: `options[${optionIndex}].color[${colorIndex}].paletteImageUrl`,
                    documentId: (category._id as any).toString(),
                    oldValue: result.changes[0].oldUrl,
                    newValue: result.changes[0].newUrl,
                    success: true
                  });
                }
              }
              
              // resourceImages 처리
              if (colorOption.resourceImages) {
                for (const [resourceKey, resourceUrl] of Object.entries(colorOption.resourceImages)) {
                  if (typeof resourceUrl === 'string') {
                    const result = updateUrlInValue(resourceUrl, urlMap);
                    if (result.updated) {
                      colorOption.resourceImages[resourceKey] = result.newValue;
                      documentUpdated = true;
                      documentUpdates.push({
                        collection: 'avatarcategories',
                        field: `options[${optionIndex}].color[${colorIndex}].resourceImages.${resourceKey}`,
                        documentId: (category._id as any).toString(),
                        oldValue: result.changes[0].oldUrl,
                        newValue: result.changes[0].newUrl,
                        success: true
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      // 문서 저장
      if (documentUpdated) {
        try {
          await category.updateOne(categoryObj);
          results.push(...documentUpdates);
          console.log(`✅ avatarcategories - 문서 ${(category._id as any)} 업데이트 완료 (${documentUpdates.length}개 필드)`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`❌ avatarcategories - 문서 ${(category._id as any)} 업데이트 실패:`, errorMessage);
          documentUpdates.forEach(update => {
            update.success = false;
            update.error = errorMessage;
          });
          results.push(...documentUpdates);
        }
      }
    }
  } catch (error) {
    console.error('❌ avatarcategories 컬렉션 업데이트 중 오류:', error);
  }
  
  return results;
};

// itemcategories 컬렉션 업데이트
const updateItemCategories = async (urlMap: Map<string, string>): Promise<UpdateResult[]> => {
  console.log('🔄 itemcategories 컬렉션 업데이트 중...');
  
  const results: UpdateResult[] = [];
  const ItemCategory = mongoose.model('ItemCategory', new mongoose.Schema({}, { strict: false }));
  
  try {
    const categories = await ItemCategory.find({});
    console.log(`📊 itemcategories: ${categories.length}개 문서 발견`);
    
    for (const category of categories) {
      const categoryObj = category.toObject() as any;
      let documentUpdated = false;
      const documentUpdates: UpdateResult[] = [];
      
      if (categoryObj.items && Array.isArray(categoryObj.items)) {
        for (let itemIndex = 0; itemIndex < categoryObj.items.length; itemIndex++) {
          const item = categoryObj.items[itemIndex];
          
          // imageUrl 업데이트
          if (item.imageUrl) {
            const result = updateUrlInValue(item.imageUrl, urlMap);
            if (result.updated) {
              item.imageUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].imageUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // thumbnailUrl 업데이트
          if (item.thumbnailUrl) {
            const result = updateUrlInValue(item.thumbnailUrl, urlMap);
            if (result.updated) {
              item.thumbnailUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].thumbnailUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // animationUrl 업데이트
          if (item.animationUrl) {
            const result = updateUrlInValue(item.animationUrl, urlMap);
            if (result.updated) {
              item.animationUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].animationUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
        }
      }
      
      // 문서 저장
      if (documentUpdated) {
        try {
          await category.updateOne(categoryObj);
          results.push(...documentUpdates);
          console.log(`✅ itemcategories - 문서 ${(category._id as any)} 업데이트 완료 (${documentUpdates.length}개 필드)`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`❌ itemcategories - 문서 ${(category._id as any)} 업데이트 실패:`, errorMessage);
          documentUpdates.forEach(update => {
            update.success = false;
            update.error = errorMessage;
          });
          results.push(...documentUpdates);
        }
      }
    }
  } catch (error) {
    console.error('❌ itemcategories 컬렉션 업데이트 중 오류:', error);
  }
  
  return results;
};

// 메인 마이그레이션 함수
const updateDatabaseUrls = async (): Promise<DatabaseUpdateResult> => {
  console.log('🚀 데이터베이스 URL 업데이트 시작...\n');
  
  const result: DatabaseUpdateResult = {
    totalUpdates: 0,
    successfulUpdates: 0,
    failedUpdates: 0,
    updates: [],
    collections: {}
  };

  try {
    // MongoDB 연결
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/ar_namecard';
    console.log(`🔗 MongoDB 연결 중: ${mongoUri}`);
    await mongoose.connect(mongoUri);
    console.log('✅ MongoDB 연결 성공\n');

    // 마이그레이션 매핑 파일 로드
    const mappingFile = path.join(process.cwd(), 'migration-mapping.json');
    console.log(`📄 매핑 파일 로드: ${mappingFile}`);
    
    const mappingData = await fs.readFile(mappingFile, 'utf-8');
    const migrations: MigrationMappings = JSON.parse(mappingData);
    
    console.log(`📊 매핑 데이터: 총 ${migrations.total}개 파일, 성공 ${migrations.success}개`);
    
    if (migrations.success === 0) {
      console.log('❌ 성공적으로 마이그레이션된 파일이 없습니다.');
      return result;
    }

    // URL 매핑 생성
    const urlMap = createUrlMapping(migrations.mappings);
    console.log(`🗺️  URL 매핑 생성 완료: ${urlMap.size}개 URL\n`);

    // 각 컬렉션 업데이트
    const avatarResults = await updateAvatarCategories(urlMap);
    const itemResults = await updateItemCategories(urlMap);

    // 결과 집계
    result.updates = [...avatarResults, ...itemResults];
    result.totalUpdates = result.updates.length;
    result.successfulUpdates = result.updates.filter(u => u.success).length;
    result.failedUpdates = result.updates.filter(u => !u.success).length;

    // 컬렉션별 통계
    result.collections = {};
    for (const update of result.updates) {
      if (!result.collections[update.collection]) {
        result.collections[update.collection] = {
          documentsUpdated: 0,
          fieldsUpdated: 0
        };
      }
      result.collections[update.collection].fieldsUpdated++;
    }

    // 컬렉션별 문서 수 계산
    const documentIds = new Set();
    for (const update of result.updates) {
      const key = `${update.collection}-${update.documentId}`;
      if (!documentIds.has(key)) {
        documentIds.add(key);
        result.collections[update.collection].documentsUpdated++;
      }
    }

    // 결과 저장
    const resultFile = path.join(process.cwd(), 'db-url-update-result.json');
    await fs.writeFile(resultFile, JSON.stringify(result, null, 2));
    console.log(`\n📄 결과 파일 저장: ${resultFile}`);

  } catch (error) {
    console.error('❌ 데이터베이스 URL 업데이트 중 오류:', error);
    throw error;
  } finally {
    // MongoDB 연결 종료
    await mongoose.disconnect();
    console.log('🔌 MongoDB 연결 종료');
  }

  return result;
};

// 스크립트 실행
const main = async () => {
  try {
    const result = await updateDatabaseUrls();
    
    console.log('\n🎉 데이터베이스 URL 업데이트 완료!');
    console.log('='.repeat(50));
    console.log(`총 업데이트: ${result.totalUpdates}`);
    console.log(`성공: ${result.successfulUpdates}`);
    console.log(`실패: ${result.failedUpdates}`);
    console.log(`성공률: ${Math.round(result.successfulUpdates / result.totalUpdates * 100)}%`);
    
    console.log('\n📊 컬렉션별 통계:');
    for (const [collection, stats] of Object.entries(result.collections)) {
      console.log(`  ${collection}: ${stats.documentsUpdated}개 문서, ${stats.fieldsUpdated}개 필드`);
    }
    
    if (result.failedUpdates > 0) {
      console.log('\n❌ 실패한 업데이트들:');
      result.updates
        .filter(u => !u.success)
        .forEach(u => {
          console.log(`  - ${u.collection}.${u.field} (${u.documentId}): ${u.error}`);
        });
    }
    
    console.log('\n✅ 데이터베이스 URL 업데이트가 완료되었습니다!');
    
  } catch (error) {
    console.error('💥 데이터베이스 URL 업데이트 실패:', error);
    process.exit(1);
  }
};

// 스크립트가 직접 실행된 경우에만 main 함수 호출
if (require.main === module) {
  main();
}

export { updateDatabaseUrls, UpdateResult, DatabaseUpdateResult };
</file>

<file path="src/config/cors.ts">
import { CorsOptions } from 'cors';

// 환경 변수 읽기
const isDevelopment = process.env.NODE_ENV === 'development';
const allowAllOrigins = process.env.CORS_ALLOW_ALL === 'true';

// 개발자 모드에서 모든 origin 허용
if (isDevelopment && allowAllOrigins) {
  console.log('🔓 CORS: 개발자 모드 - 모든 origin 허용');
}

// 개발 환경에서 로컬 네트워크 자동 허용
if (isDevelopment) {
  console.log('🌐 CORS: 개발 모드 - 로컬 네트워크 접근 허용');
}

// 기본 허용 도메인 목록
const allowedOrigins = [
  // 로컬 개발 환경
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:5173',
  'http://localhost:5174',
  'https://localhost:3443',
  'https://localhost:3001',
  
  // 8th Wall 도메인
  'https://8thwall.com',
  'https://www.8thwall.com',
  'https://console.8thwall.com',
  'https://8thwall.app',
  'https://www.8thwall.app',
  
  // 로컬 네트워크 (모든 사설 IP 대역)
  /^https?:\/\/192\.168\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  /^https?:\/\/10\.\d{1,3}\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  /^https?:\/\/172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  
  // 8th Wall 동적 도메인 패턴
  /^https:\/\/.*\.8thwall\.com$/,
  /^https:\/\/.*\.8thwall\.app$/,
  
  // 테스트 도메인
  'http://test.com',
  'https://test.com',
  'https://192.168.1.20',
  
  // 개발 환경 추가 지원
  ...(isDevelopment ? [
    // 로컬 호스트 변형
    'http://127.0.0.1:3000',
    'http://0.0.0.0:3000',
    'https://127.0.0.1:3443',
    'https://0.0.0.0:3443',
    
    // 더 넓은 로컬 네트워크 지원
    /^https?:\/\/.*\.local(:\d+)?$/,
    /^https?:\/\/.*\.lan(:\d+)?$/,
    
    // 개발자 도구 지원
    'null', // file:// 프로토콜용
  ] : []),
  
  // CloudType 배포 도메인들
  'https://ar-namecard-api.run.goorm.site',
  /^https:\/\/port-\d+-ar-namecard-api-.*\.cloudtype\.app$/,
  /^https:\/\/.*\.cloudtype\.app$/,
  
  // 추가 프로덕션 도메인들 (필요시)
];

export const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    // 개발자 모드에서 모든 origin 허용
    if (isDevelopment && allowAllOrigins) {
      console.log(`✅ CORS: 모든 origin 허용 모드 - ${origin}`);
      return callback(null, true);
    }
    
    // origin이 없는 경우 (같은 도메인 요청) 허용
    if (!origin) {
      return callback(null, true);
    }
    
    // 개발 환경에서 로컬 네트워크 자동 허용
    if (isDevelopment) {
      const isLocalNetwork = /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0|192\.168\.\d{1,3}\.\d{1,3}|10\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3})(:\d+)?$/i.test(origin);
      
      if (isLocalNetwork) {
        console.log(`✅ CORS: 로컬 네트워크 허용 - ${origin}`);
        return callback(null, true);
      }
    }
    
    // 허용된 origin 목록 확인
    const isAllowed = allowedOrigins.some(allowedOrigin => {
      if (typeof allowedOrigin === 'string') {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      console.log(`✅ CORS: 허용된 origin - ${origin}`);
      callback(null, true);
    } else {
      console.warn(`🚫 CORS: 차단된 origin - ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin',
    'Access-Control-Allow-Origin'
  ]
};
</file>

<file path="src/config/database.ts">
import mongoose from 'mongoose';

export const connectDB = async (): Promise<void> => {
  try {
    const mongoURI = process.env['MONGODB_URI'] || 'mongodb://localhost:27017/ar_namecard';
    
    await mongoose.connect(mongoURI);
    
    console.log('MongoDB Connected Successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

mongoose.connection.on('disconnected', () => {
  console.log('MongoDB disconnected');
});

mongoose.connection.on('error', (error) => {
  console.error('MongoDB connection error:', error);
});
</file>

<file path="src/config/firebase-storage.ts">
import { initializeFirebase } from '../scripts/config/firebase-admin';

export const getStorage = () => {
  const app = initializeFirebase();
  return app.storage();
};

export const getBucket = () => {
  const storage = getStorage();
  return storage.bucket(process.env.FIREBASE_STORAGE_BUCKET);
};

export const uploadToFirebase = async (
  file: Express.Multer.File,
  folder: string = ''
): Promise<{ url: string; path: string }> => {
  const filename = `${folder}${Date.now()}-${Math.round(Math.random() * 1E9)}-${file.originalname}`;
  const bucket = getBucket();
  const fileUpload = bucket.file(filename);
  
  const stream = fileUpload.createWriteStream({
    metadata: {
      contentType: file.mimetype,
    },
  });

  return new Promise((resolve, reject) => {
    stream.on('error', reject);
    stream.on('finish', async () => {
      try {
        await fileUpload.makePublic();
        const url = `https://storage.googleapis.com/${bucket.name}/${filename}`;
        resolve({ url, path: filename });
      } catch (error) {
        reject(error);
      }
    });
    stream.end(file.buffer);
  });
};
</file>

<file path="src/config/swagger.ts">
import swaggerJSDoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';
import { Express } from 'express';
import os from 'os';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'AR Namecard API',
      version: '1.0.0',
      description: `AR 명함 서비스 API 문서입니다.

### 테스트 페이지:
* [로그인 테스트](/test/login/)
* [사용자 정보 테스트](/test/user/)
* [캐릭터 옵션 등록 테스트](/test/avatar/)
* [스티커 옵션 등록 테스트](/test/item/)
* [커스터마이징 테스트](/test/customize/)
`,
    },
    servers: [], // 동적으로 생성됨
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
          description: 'AR 명함 시스템 JWT 토큰',
        },
        firebaseAuth: {
          type: 'oauth2',
          description: 'Firebase Authentication (Google OAuth)',
          flows: {
            implicit: {
              authorizationUrl: 'https://accounts.google.com/o/oauth2/auth',
              scopes: {
                'openid': 'OpenID Connect',
                'email': 'Email address',
                'profile': 'User profile'
              }
            }
          }
        },
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: '사용자 ID',
            },
            nameEn: {
              type: 'string',
              description: '영문 이름',
            },
            email: {
              type: 'string',
              description: '이메일',
            },
            nameKr: {
              type: 'string',
              description: '한글 이름',
            },
            role: {
              type: 'string',
              description: '역할',
              default: 'User',
            },
            part: {
              type: 'string',
              description: '소속 부서',
              default: '',
            },
            phone: {
              type: 'string',
              description: '전화번호',
            },
            isNamecardActive: {
              type: 'boolean',
              description: '명함 활성화 여부',
              default: false,
            },
            arId: {
              type: 'string',
              description: 'AR 명함 ID (3자리)',
              minLength: 3,
              maxLength: 3,
            },
            isAdmin: {
              type: 'boolean',
              description: '관리자 여부',
              default: false,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: '생성일시',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: '수정일시',
            },
          },
          required: ['email', 'nameKr', 'phone', 'arId'],
        },
        UserCustomization: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: '사용자 ID 참조',
            },
            avatarSelections: {
              type: 'object',
              description: '아바타 선택 옵션',
              additionalProperties: {
                type: 'string',
              },
            },
            role: {
              type: 'string',
              description: '역할',
            },
            item1: {
              type: 'string',
              description: '아이템 1',
            },
            item2: {
              type: 'string',
              description: '아이템 2',
            },
            item3: {
              type: 'string',
              description: '아이템 3',
            },
            avatarImgUrl: {
              type: 'string',
              description: '아바타 이미지 URL',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: '생성일시',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: '수정일시',
            },
          },
          required: ['id'],
        },
        AvatarWithUser: {
          type: 'object',
          description: '사용자 정보와 아바타 정보가 합쳐진 응답',
          properties: {
            id: {
              type: 'string',
              description: '사용자 ID',
            },
            nameEn: {
              type: 'string',
              description: '영문 이름',
              nullable: true,
            },
            email: {
              type: 'string',
              description: '이메일',
              nullable: true,
            },
            nameKr: {
              type: 'string',
              description: '한글 이름',
              nullable: true,
            },
            part: {
              type: 'string',
              description: '소속 부서',
              default: '',
            },
            phone: {
              type: 'string',
              description: '전화번호',
              nullable: true,
            },
            isNamecardActive: {
              type: 'boolean',
              description: '명함 활성화 여부',
              default: false,
            },
            arId: {
              type: 'string',
              description: 'AR 명함 ID (3자리)',
              nullable: true,
            },
            isAdmin: {
              type: 'boolean',
              description: '관리자 여부',
              default: false,
            },
            avatarSelections: {
              type: 'object',
              description: '아바타 선택 옵션 (상세 정보 포함)',
              additionalProperties: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  name: { type: 'string' },
                  imageUrl: { type: 'string' },
                  thumbnailUrl: { type: 'string' },
                },
              },
            },
            role: {
              type: 'object',
              description: '역할 상세 정보',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
              },
            },
            item1: {
              type: 'object',
              description: '아이템 1 상세 정보',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            item2: {
              type: 'object',
              description: '아이템 2 상세 정보',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            item3: {
              type: 'object',
              description: '아이템 3 상세 정보',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            avatarImgUrl: {
              type: 'string',
              description: '아바타 이미지 URL',
              nullable: true,
            },
            message: {
              type: 'string',
              description: '사용자 메시지',
              default: '',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: '생성일시',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: '수정일시',
            },
          },
          required: ['id'],
        },
        AvatarCategory: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: '카테고리 ID',
            },
            name: {
              type: 'string',
              description: '카테고리 이름',
            },
            type: {
              type: 'string',
              description: '카테고리 타입',
            },
            options: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: {
                    type: 'string',
                    description: '옵션 이름',
                  },
                  imageUrl: {
                    type: 'string',
                    description: '이미지 URL',
                  },
                  thumbnailUrl: {
                    type: 'string',
                    description: '썸네일 이미지 URL',
                  },
                  thumbnailSource: {
                    type: 'string',
                    enum: ['user', 'auto'],
                    description: '썸네일 생성 방식',
                  },
                  modelUrl: {
                    type: 'string',
                    description: '모델 URL',
                  },
                  color: {
                    type: 'string',
                    description: '색상',
                  },
                  order: {
                    type: 'number',
                    description: '순서',
                    default: 0,
                  },
                },
                required: ['name', 'imageUrl'],
              },
            },
            order: {
              type: 'number',
              description: '순서',
              default: 0,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: '생성일시',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: '수정일시',
            },
          },
          required: ['name', 'type'],
        },
        ItemCategory: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: '카테고리 ID',
            },
            name: {
              type: 'string',
              description: '카테고리 이름',
            },
            type: {
              type: 'string',
              description: '카테고리 타입',
            },
            items: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: {
                    type: 'string',
                    description: '아이템 이름',
                  },
                  imageUrl: {
                    type: 'string',
                    description: '이미지 URL',
                  },
                  thumbnailUrl: {
                    type: 'string',
                    description: '썸네일 이미지 URL',
                  },
                  thumbnailSource: {
                    type: 'string',
                    enum: ['user', 'auto'],
                    description: '썸네일 생성 방식',
                  },
                  modelUrl: {
                    type: 'string',
                    description: '모델 URL',
                  },
                  animationUrl: {
                    type: 'string',
                    description: '애니메이션 URL',
                  },
                  animation: {
                    type: 'object',
                    properties: {
                      frames: {
                        type: 'number',
                        description: '프레임 수',
                      },
                      columns: {
                        type: 'number',
                        description: '열 수',
                      },
                      duration: {
                        type: 'number',
                        description: '지속 시간',
                      },
                      type: {
                        type: 'string',
                        description: '애니메이션 타입',
                      },
                    },
                    required: ['frames', 'columns', 'duration', 'type'],
                  },
                  order: {
                    type: 'number',
                    description: '순서',
                    default: 0,
                  },
                },
                required: ['name', 'imageUrl'],
              },
            },
            order: {
              type: 'number',
              description: '순서',
              default: 0,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: '생성일시',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: '수정일시',
            },
          },
          required: ['name', 'type'],
        },
        Error: {
          type: 'object',
          properties: {
            error: {
              type: 'string',
              description: '에러 메시지',
            },
            errors: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  field: {
                    type: 'string',
                    description: '필드명',
                  },
                  message: {
                    type: 'string',
                    description: '에러 메시지',
                  },
                },
              },
            },
          },
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
      {
        firebaseAuth: ['openid', 'email', 'profile'],
      },
    ],
  },
  apis: ['./src/routes/*.ts'], // API 파일 경로
};

// 로컬 IP 주소 찾기
function getLocalIpAddress(): string {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const networkInterface of interfaces[name]!) {
      const { address, family, internal } = networkInterface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

// 동적 서버 URL 생성
function generateServerUrls() {
  const localIp = getLocalIpAddress();
  const port = process.env.PORT || '3000';
  const httpsPort = process.env.HTTPS_PORT || '3443';
  
  return [
    {
      url: `http://localhost:${port}`,
      description: 'Local development server',
    },
    {
      url: `http://${localIp}:${port}`,
      description: 'Network development server',
    },
    {
      url: `https://localhost:${httpsPort}`,
      description: 'Local HTTPS server',
    },
    {
      url: `https://${localIp}:${httpsPort}`,
      description: 'Network HTTPS server',
    },
  ];
}

// 동적 옵션 생성
const getDynamicOptions = () => ({
  ...options,
  definition: {
    ...options.definition,
    servers: generateServerUrls(),
  },
});

export const setupSwagger = (app: Express): void => {
  const dynamicSpecs = swaggerJSDoc(getDynamicOptions());
  
  // Swagger UI 옵션 설정
  const swaggerUiOptions = {
    explorer: true,
    swaggerOptions: {
      docExpansion: 'none', // 기본적으로 모든 태그를 접음
      defaultModelsExpandDepth: 1,
      defaultModelExpandDepth: 1,
      displayOperationId: false,
      displayRequestDuration: true,
      filter: true,
      showExtensions: true,
      showCommonExtensions: true,
      tryItOutEnabled: true,
    }
  };
  
  // 커스텀 CSS와 JavaScript로 Avatars 태그만 확장
  const customCss = `
    .opblock-tag-section[data-tag="Avatars"] .opblock-tag {
      background-color: #e8f5e8 !important;
      border-left: 4px solid #4caf50 !important;
    }
    .opblock-tag-section[data-tag="Avatars"] .opblock-tag:after {
      content: " ⭐ 기본 확장" !important;
      font-size: 12px !important;
      color: #4caf50 !important;
      font-weight: bold !important;
    }
    
    /* 자동 확장 스크립트 */
    <script>
      window.addEventListener('DOMContentLoaded', function() {
        function expandAvatarsTag() {
          const avatarsSection = document.querySelector('[data-tag="Avatars"]');
          if (avatarsSection) {
            const avatarsTag = avatarsSection.querySelector('.opblock-tag');
            if (avatarsTag && !avatarsSection.classList.contains('is-open')) {
              avatarsTag.click();
              console.log('✅ Avatars 태그 자동 확장 완료');
            }
          } else {
            // DOM이 아직 로드되지 않았다면 재시도
            setTimeout(expandAvatarsTag, 500);
          }
        }
        
        // 페이지 로드 후 잠시 대기한 다음 실행
        setTimeout(expandAvatarsTag, 1000);
      });
    </script>
  `;
  
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(dynamicSpecs, swaggerUiOptions, {}, customCss, undefined, undefined, 'AR Namecard API Documentation'));
};
</file>

<file path="src/controllers/adminAvatarController.ts">
import { Request, Response } from 'express';
import { AvatarCategory } from '../models';
import { validationResult } from 'express-validator';
import { ThumbnailGenerator } from '../utils/thumbnailGenerator';
import { PaletteImageProcessor } from '../utils/paletteImageProcessor';
import { uploadToFirebase } from '../config/firebase-storage';
import { uploadToFirebaseStorage } from '../middleware/upload';
import path from 'path';
import fs from 'fs/promises'; // Added fs import

interface AuthRequest extends Request {
  user?: any;
}

// 파일 삭제 유틸리티 함수
const deleteFileIfExists = async (filePath: string): Promise<void> => {
  try {
    await fs.access(filePath);
    await fs.unlink(filePath);
    console.log(`File deleted: ${filePath}`);
  } catch (error) {
    // 파일이 존재하지 않거나 삭제 실패해도 무시
    console.warn(`Failed to delete file: ${filePath}`, error);
  }
};

// URL에서 실제 파일 경로 추출
const getFilePathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', filename);
};

// 썸네일 URL에서 실제 파일 경로 추출
const getThumbnailPathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', 'thumbnails', filename);
};

export const getAllAvatarCategories = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await AvatarCategory.find(query).sort({ order: 1 });
    
    // 기존 데이터 호환성을 위한 마이그레이션 로직 적용
    const migratedCategories = categories.map(category => {
      const categoryObj = category.toObject();
      if (categoryObj.options) {
        categoryObj.options = categoryObj.options.map((option: any) => {
          // 기존 구조(단일 color string)를 새 구조로 변환
          if (typeof option.color === 'string' && option.imageUrl) {
            option.color = [{
              colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
              imageUrl: option.imageUrl
            }];
          }
          // color가 배열이 아니고 imageUrl이 있는 경우 (null, undefined 등)
          else if (!Array.isArray(option.color) && option.imageUrl) {
            option.color = [{
              colorName: 'Default',
              imageUrl: option.imageUrl
            }];
          }

          // 기존 hairParts를 resourceImages로 변환 (hair 카테고리만)
          if (categoryObj.type === 'hair' && option.hairParts && Array.isArray(option.color)) {
            option.color = option.color.map((colorOpt: any) => {
              if (!colorOpt.resourceImages) {
                // 새로운 객체 구조로 변환
                const resourceImages: any = {};
                if (option.hairParts.middle) {
                  resourceImages.hairMiddleImageUrl = option.hairParts.middle; // 중간머리
                }
                if (option.hairParts.back) {
                  resourceImages.hairBackImageUrl = option.hairParts.back; // 뒷머리
                }
                colorOpt.resourceImages = resourceImages;
              }
              return colorOpt;
            });
            // 변환 후 hairParts 제거
            delete option.hairParts;
          }
          
          // 기존 배열 구조 resourceImages를 객체 구조로 변환 (hair 카테고리만)
          if (categoryObj.type === 'hair' && Array.isArray(option.color)) {
            option.color = option.color.map((colorOpt: any) => {
              if (colorOpt.resourceImages && Array.isArray(colorOpt.resourceImages)) {
                // 배열 구조를 객체 구조로 변환
                const newResourceImages: any = {};
                if (colorOpt.resourceImages[2]) {
                  newResourceImages.hairMiddleImageUrl = colorOpt.resourceImages[2]; // 중간머리
                }
                if (colorOpt.resourceImages[0]) {
                  newResourceImages.hairBackImageUrl = colorOpt.resourceImages[0]; // 뒷머리
                }
                colorOpt.resourceImages = newResourceImages;
              }
              return colorOpt;
            });
          }
          
          return option;
        });
      }
      return categoryObj;
    });
    
    res.json({ categories: migratedCategories, total: migratedCategories.length });
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const getAvatarCategoryById = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await AvatarCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // 기존 데이터 호환성을 위한 마이그레이션 로직 적용
    const categoryObj = category.toObject();
    if (categoryObj.options) {
      categoryObj.options = categoryObj.options.map((option: any) => {
        // 기존 구조(단일 color string)를 새 구조로 변환
        if (typeof option.color === 'string' && option.imageUrl) {
          option.color = [{
            colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
            imageUrl: option.imageUrl
          }];
        }
        // color가 배열이 아니고 imageUrl이 있는 경우 (null, undefined 등)
        else if (!Array.isArray(option.color) && option.imageUrl) {
          option.color = [{
            colorName: 'Default',
            imageUrl: option.imageUrl
          }];
        }
        
        return option;
      });
    }

    res.json(categoryObj);
  } catch (error) {
    console.error('Error fetching avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const createAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { name, type, order = 0 } = req.body;

    // 동일한 type이 있는지 확인
    const existingCategory = await AvatarCategory.findOne({ type });
    if (existingCategory) {
      res.status(400).json({ message: 'Avatar category with this type already exists' });
      return;
    }

    const category = new AvatarCategory({
      name,
      type,
      options: [],
      order
    });

    await category.save();
    res.status(201).json({ message: 'Avatar category created successfully', category });
  } catch (error) {
    console.error('Error creating avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, type, order } = req.body;

    // type이 변경되는 경우 중복 확인
    if (type) {
      const existingCategory = await AvatarCategory.findOne({ type, _id: { $ne: id } });
      if (existingCategory) {
        res.status(400).json({ message: 'Avatar category with this type already exists' });
        return;
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (type !== undefined) updateData.type = type;
    if (order !== undefined) updateData.order = order;

    const category = await AvatarCategory.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    res.json({ message: 'Avatar category updated successfully', category });
  } catch (error) {
    console.error('Error updating avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await AvatarCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // 카테고리의 모든 옵션 이미지, 썸네일 및 팔레트 이미지 삭제
    for (const option of category.options) {
      if (option.imageUrl) {
        const imagePath = getFilePathFromUrl(option.imageUrl);
        await deleteFileIfExists(imagePath);
      }
      if (option.thumbnailUrl) {
        const thumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
        await deleteFileIfExists(thumbnailPath);
      }
      
      // 팔레트 이미지들 삭제
      if (option.color && Array.isArray(option.color)) {
        for (const colorOpt of option.color) {
          if (colorOpt.paletteImageUrl) {
            await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
          }
        }
      }
    }

    await AvatarCategory.findByIdAndDelete(id);
    res.json({ message: 'Avatar category deleted successfully' });
  } catch (error) {
    console.error('Error deleting avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const addAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, colorOptions, order = 0 } = req.body;
    const files = req.files as Express.Multer.File[];
    
    console.log(`🔍 addAvatarOption 요청 데이터:`, {
      name,
      colorOptionsType: typeof colorOptions,
      colorOptionsLength: colorOptions?.length,
      filesCount: files?.length || 0
    });
    
    // colorOptions는 JSON 문자열로 전송될 것임
    let parsedColorOptions;
    try {
      parsedColorOptions = typeof colorOptions === 'string' ? JSON.parse(colorOptions) : colorOptions;
      console.log(`🔍 파싱된 colorOptions:`, parsedColorOptions);
    } catch (error) {
      console.error('❌ colorOptions 파싱 실패:', error);
      res.status(400).json({ message: 'Invalid colorOptions format' });
      return;
    }

    if (!parsedColorOptions || !Array.isArray(parsedColorOptions) || parsedColorOptions.length === 0) {
      console.error('❌ colorOptions 검증 실패:', {
        exists: !!parsedColorOptions,
        isArray: Array.isArray(parsedColorOptions),
        length: parsedColorOptions?.length || 0
      });
      res.status(400).json({ message: 'At least one color option is required' });
      return;
    }

    const category = await AvatarCategory.findById(id);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // hair 카테고리 감지
    const isHairCategory = category.type === 'hair';

    // 파일 배열을 객체로 변환 (upload.any() 사용으로 인해)
    const filesByName: { [key: string]: Express.Multer.File[] } = {};
    if (Array.isArray(files)) {
      files.forEach(file => {
        if (!filesByName[file.fieldname]) {
          filesByName[file.fieldname] = [];
        }
        filesByName[file.fieldname].push(file);
      });
    }

    // 디버깅: 받은 파일들 로그
    console.log('🔍 받은 파일들:', Object.keys(filesByName));
    if (isHairCategory) {
      console.log('💇‍♀️ Hair 카테고리 파일들:', Object.keys(filesByName).filter(key => key.startsWith('hair_')));
    }

    // 팔레트 이미지 및 hair 리소스 이미지 처리
    const paletteFiles = filesByName.palette || [];
    const processedColorOptions = await Promise.all(
      parsedColorOptions.map(async (colorOption: any, index: number) => {
        let paletteImageUrl = '';
        let resourceImages: { hairMiddleImageUrl: string; hairBackImageUrl?: string } | undefined;
        
        // 해당 인덱스에 팔레트 이미지가 있으면 처리
        if (paletteFiles[index]) {
          try {
            // Firebase Storage에 팔레트 이미지 업로드
            const uploadResult = await uploadToFirebaseStorage(paletteFiles[index], 'palettes/');
            paletteImageUrl = uploadResult.url;
            console.log(`✅ 팔레트 이미지 업로드 완료 (색상 옵션 ${index}):`, uploadResult.url);
          } catch (error) {
            console.error(`Error processing palette image for color option ${index}:`, error);
          }
        }

        // hair 카테고리인 경우 리소스 이미지 처리
        if (isHairCategory) {
          // hair 검증: 중간머리는 필수
          const middleHairKey = `hair_${index}_middle`;
          const backHairKey = `hair_${index}_back`;
          
          if (!filesByName[middleHairKey] || filesByName[middleHairKey].length === 0) {
            throw new Error(`Middle hair image is required for color option ${index + 1}: ${colorOption.colorName}`);
          }

          try {
            // 리소스 이미지 객체 초기화
            resourceImages = {} as { hairMiddleImageUrl: string; hairBackImageUrl?: string };
            
            // 중간머리 처리 (필수)
            const middleHairFile = filesByName[middleHairKey]![0];
            if (!middleHairFile.buffer) {
              throw new Error('Middle hair file buffer is missing');
            }
            const middleResult = await uploadToFirebase(middleHairFile, 'uploads/hair/');
            resourceImages.hairMiddleImageUrl = middleResult.url;

            // 뒷머리 처리 (선택사항)
            if (filesByName[backHairKey] && filesByName[backHairKey].length > 0) {
              const backHairFile = filesByName[backHairKey][0];
              if (!backHairFile.buffer) {
                throw new Error('Back hair file buffer is missing');
              }
              const backResult = await uploadToFirebase(backHairFile, 'uploads/hair/');
              resourceImages.hairBackImageUrl = backResult.url;
            }

          } catch (error) {
            console.error(`Error processing hair images for color option ${index}:`, error);
            throw new Error(`Failed to process hair images for color option: ${colorOption.colorName}`);
          }
        }

        // Hair 카테고리에서 imageUrl 결정
        let finalImageUrl = colorOption.imageUrl;
        if (isHairCategory) {
          // 중간머리가 있으면 사용, 없으면 기존 imageUrl 유지
          finalImageUrl = resourceImages?.hairMiddleImageUrl || colorOption.imageUrl;
          // Hair 카테고리에서 imageUrl이 여전히 없으면 에러
          if (!finalImageUrl) {
            throw new Error(`Hair category requires middle hair image for color option: ${colorOption.colorName}`);
          }
        }

        return {
          colorName: colorOption.colorName,
          imageUrl: finalImageUrl,
          paletteImageUrl,
          ...(isHairCategory && { resourceImages })
        };
      })
    );

    // 첫 번째 컬러 옵션의 이미지를 메인 이미지로 사용
    const mainImageUrl = processedColorOptions[0]?.imageUrl;
    console.log(`🔍 메인 이미지 URL (썸네일 생성용):`, mainImageUrl);
    if (!mainImageUrl) {
      res.status(400).json({ message: 'First color option must have an imageUrl' });
      return;
    }

    // 썸네일 처리 (첫 번째 컬러 옵션 이미지 기준)
    let thumbnailUrl = '';
    let thumbnailSource: 'user' | 'auto' = 'auto';

    if (filesByName.thumbnail && filesByName.thumbnail.length > 0) {
      // 사용자가 썸네일을 제공한 경우
      const thumbnailFile = filesByName.thumbnail[0];
      if (!thumbnailFile) {
        res.status(400).json({ message: 'Thumbnail file is invalid' });
        return;
      }
      // Firebase Storage에 썸네일 직접 업로드
      if (!thumbnailFile.buffer) {
        res.status(400).json({ message: 'Thumbnail file buffer is missing' });
        return;
      }
      
      const thumbnailUploadResult = await uploadToFirebaseStorage(thumbnailFile, 'thumbnails/');
      thumbnailUrl = thumbnailUploadResult.url;
      thumbnailSource = 'user';
    } else {
      // 첫 번째 컬러 옵션 이미지로 자동 썸네일 생성
      // mainImageUrl을 ThumbnailGenerator에 직접 전달 (Firebase Storage URL 또는 로컬 경로)
      console.log(`🔍 썸네일 생성용 이미지 URL:`, mainImageUrl);
      const thumbnailResult = await ThumbnailGenerator.generateThumbnail(mainImageUrl);
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    }

    const newOption: any = {
      name,
      imageUrl: mainImageUrl,
      thumbnailUrl,
      thumbnailSource,
      color: processedColorOptions,
      order: parseInt(order) || 0
    };

    category.options.push(newOption as any);
    await category.save();

    res.status(201).json({ 
      message: 'Avatar option added successfully', 
      option: newOption,
      category: category.name
    });
  } catch (error) {
    console.error('Error adding avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;
    const { name, colorOptions, order } = req.body;
    const files = req.files as Express.Multer.File[];

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];

    // 기존 파일 경로 저장 (삭제용)
    const oldThumbnailPath = option.thumbnailUrl ? getThumbnailPathFromUrl(option.thumbnailUrl) : '';

    // 기본 정보 업데이트
    if (name !== undefined) option.name = name;
    if (order !== undefined) option.order = parseInt(order);

    // hair 카테고리 감지
    const isHairCategory = category.type === 'hair';

    // 파일 배열을 객체로 변환 (upload.any() 사용으로 인해)
    const filesByName: { [key: string]: Express.Multer.File[] } = {};
    if (Array.isArray(files)) {
      files.forEach(file => {
        if (!filesByName[file.fieldname]) {
          filesByName[file.fieldname] = [];
        }
        filesByName[file.fieldname].push(file);
      });
    }

    // 컬러 옵션 업데이트
    if (colorOptions !== undefined) {
      let parsedColorOptions;
      try {
        parsedColorOptions = typeof colorOptions === 'string' ? JSON.parse(colorOptions) : colorOptions;
      } catch (error) {
        res.status(400).json({ message: 'Invalid colorOptions format' });
        return;
      }

      if (!parsedColorOptions || !Array.isArray(parsedColorOptions) || parsedColorOptions.length === 0) {
        res.status(400).json({ message: 'At least one color option is required' });
        return;
      }

      // 기존 팔레트 이미지들 삭제
      if (option.color && Array.isArray(option.color)) {
        for (const colorOpt of option.color) {
          if (colorOpt.paletteImageUrl) {
            await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
          }
        }
      }

      // 새로운 팔레트 이미지 및 hair 리소스 이미지 처리
      const paletteFiles = filesByName.palette || [];
      const processedColorOptions = await Promise.all(
        parsedColorOptions.map(async (colorOption: any, index: number) => {
          let paletteImageUrl = '';
          let resourceImages: { hairMiddleImageUrl: string; hairBackImageUrl?: string } | undefined;
          
          // 해당 인덱스에 팔레트 이미지가 있으면 처리
          if (paletteFiles[index]) {
            try {
              // Firebase Storage에 팔레트 이미지 업로드
              const uploadResult = await uploadToFirebaseStorage(paletteFiles[index], 'palettes/');
              paletteImageUrl = uploadResult.url;
              console.log(`✅ 팔레트 이미지 업로드 완료 (색상 옵션 ${index}):`, uploadResult.url);
            } catch (error) {
              console.error(`Error processing palette image for color option ${index}:`, error);
            }
          } else if (colorOption.paletteImageUrl) {
            // 기존 팔레트 이미지 유지
            paletteImageUrl = colorOption.paletteImageUrl;
          }

          // hair 카테고리인 경우 리소스 이미지 처리
          if (isHairCategory) {
            const middleHairKey = `hair_${index}_middle`;
            const backHairKey = `hair_${index}_back`;
            
            try {
              // 리소스 이미지 객체 초기화
              resourceImages = {} as { hairMiddleImageUrl: string; hairBackImageUrl?: string };
              
              // 기존 resourceImages 처리
              if (colorOption.resourceImages) {
                if (colorOption.resourceImages.hairMiddleImageUrl) {
                  resourceImages.hairMiddleImageUrl = colorOption.resourceImages.hairMiddleImageUrl;
                }
                if (colorOption.resourceImages.hairBackImageUrl) {
                  resourceImages.hairBackImageUrl = colorOption.resourceImages.hairBackImageUrl;
                }
              } else if (colorOption.imageUrl) {
                // 기존 Hair 옵션에서 resourceImages가 없는 경우, imageUrl을 중간머리로 사용
                resourceImages.hairMiddleImageUrl = colorOption.imageUrl;
              }
              
              // 중간머리 처리 (필수)
              if (filesByName[middleHairKey] && filesByName[middleHairKey].length > 0) {
                const middleHairFile = filesByName[middleHairKey][0];
                if (!middleHairFile.buffer) {
                  throw new Error('Middle hair file buffer is missing');
                }
                const middleResult = await uploadToFirebase(middleHairFile, 'uploads/hair/');
                resourceImages.hairMiddleImageUrl = middleResult.url;
              }

              // 뒷머리 처리 (선택사항)
              if (filesByName[backHairKey] && filesByName[backHairKey].length > 0) {
                const backHairFile = filesByName[backHairKey][0];
                if (!backHairFile.buffer) {
                  throw new Error('Back hair file buffer is missing');
                }
                const backResult = await uploadToFirebase(backHairFile, 'uploads/hair/');
                resourceImages.hairBackImageUrl = backResult.url;
              }

            } catch (error) {
              console.error(`Error processing hair images for color option ${index}:`, error);
            }
          }

          // Hair 카테고리에서 imageUrl 결정
          let finalImageUrl = colorOption.imageUrl;
          if (isHairCategory && resourceImages) {
            // 중간머리가 있으면 사용, 없으면 기존 imageUrl 유지
            finalImageUrl = resourceImages.hairMiddleImageUrl || colorOption.imageUrl;
          }

          return {
            colorName: colorOption.colorName,
            imageUrl: finalImageUrl,
            paletteImageUrl,
            ...(isHairCategory && { resourceImages })
          };
        })
      );

      option.color = processedColorOptions;
      
      // 첫 번째 컬러 옵션의 이미지를 메인 이미지로 업데이트
      const newMainImageUrl = processedColorOptions[0]?.imageUrl;
      console.log(`🔍 업데이트 - 새 메인 이미지 URL:`, newMainImageUrl, `기존:`, option.imageUrl);
      if (newMainImageUrl && newMainImageUrl !== option.imageUrl) {
        option.imageUrl = newMainImageUrl;
        
        // 메인 이미지가 변경되면 썸네일도 재생성 (자동 생성인 경우)
        if (option.thumbnailSource === 'auto') {
          // 기존 썸네일 삭제
          if (oldThumbnailPath) {
            await deleteFileIfExists(oldThumbnailPath);
          }

          console.log(`🔍 업데이트 - 썸네일 생성용 이미지 URL:`, newMainImageUrl);
          const thumbnailResult = await ThumbnailGenerator.generateThumbnail(newMainImageUrl);
          option.thumbnailUrl = thumbnailResult.thumbnailUrl;
        }
      }
    }

    // 새 썸네일이 있는 경우
    if (filesByName.thumbnail && filesByName.thumbnail.length > 0) {
      const thumbnailFile = filesByName.thumbnail[0];
      if (thumbnailFile) {
        // Firebase Storage 사용 시 로컬 파일 삭제 불필요

        // Firebase Storage에 썸네일 직접 업로드
        if (!thumbnailFile.buffer) {
          res.status(400).json({ message: 'Thumbnail file buffer is missing' });
          return;
        }
        
        const thumbnailUploadResult = await uploadToFirebaseStorage(thumbnailFile, 'thumbnails/');
        option.thumbnailUrl = thumbnailUploadResult.url;
        option.thumbnailSource = 'user';
      }
    }

    await category.save();

    res.json({ 
      message: 'Avatar option updated successfully', 
      option,
      category: category.name
    });
  } catch (error) {
    console.error('Error updating avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];

    // 관련 파일들 삭제
    if (option.imageUrl) {
      const imagePath = getFilePathFromUrl(option.imageUrl);
      await deleteFileIfExists(imagePath);
    }
    if (option.thumbnailUrl) {
      const thumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
      await deleteFileIfExists(thumbnailPath);
    }
    
    // 팔레트 이미지들 삭제
    if (option.color && Array.isArray(option.color)) {
      for (const colorOpt of option.color) {
        if (colorOpt.paletteImageUrl) {
          await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
        }
      }
    }

    category.options.splice(optionIndex, 1);
    await category.save();

    res.json({ message: 'Avatar option deleted successfully' });
  } catch (error) {
    console.error('Error deleting avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const regenerateThumbnail = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];
    
    if (!option.imageUrl) {
      res.status(400).json({ message: 'No image URL found for this option' });
      return;
    }
    
    // 기존 썸네일 삭제
    if (option.thumbnailUrl) {
      const oldThumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
      await deleteFileIfExists(oldThumbnailPath);
    }
    
    // 썸네일 재생성 (Firebase Storage URL 또는 로컬 경로 자동 처리)
    const thumbnailResult = await ThumbnailGenerator.generateThumbnail(option.imageUrl);
    option.thumbnailUrl = thumbnailResult.thumbnailUrl;
    option.thumbnailSource = 'auto';

    await category.save();

    res.json({ 
      message: 'Thumbnail regenerated successfully', 
      thumbnailUrl: option.thumbnailUrl
    });
  } catch (error) {
    console.error('Error regenerating thumbnail:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/adminController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { validationResult } from 'express-validator';

interface AuthRequest extends Request {
  user?: any;
}

export const getAllUsers = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }
    
    const { page = 1, limit = 20, search, role, isActive, isAdmin } = req.query;
    
    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;
    
    let query: any = {};
    
    if (search) {
      query.$or = [
        { nameKr: { $regex: search, $options: 'i' } },
        { nameEn: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { arId: { $regex: search, $options: 'i' } }
      ];
    }
    
    if (role) {
      query.role = role;
    }
    
    if (isActive !== undefined) {
      query.isNamecardActive = isActive === 'true';
    }

    if (isAdmin !== undefined) {
      query.isAdmin = isAdmin === 'true';
    }
    
    const [users, total] = await Promise.all([
      User.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      User.countDocuments(query)
    ]);
    
    res.json({
      users,
      total,
      currentPage: pageNum,
      totalPages: Math.ceil(total / limitNum),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        pages: Math.ceil(total / limitNum)
      }
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateUserPermissions = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }
    
    const { id } = req.params;
    const { isAdmin, isNamecardActive, role, nameKr, nameEn, part, phone } = req.body;
    
    const updateData: any = {};
    
    if (isAdmin !== undefined) {
      updateData.isAdmin = isAdmin;
    }
    
    if (isNamecardActive !== undefined) {
      updateData.isNamecardActive = isNamecardActive;
    }
    
    if (role !== undefined) {
      updateData.role = role;
    }

    if (nameKr !== undefined) {
      updateData.nameKr = nameKr;
    }

    if (nameEn !== undefined) {
      updateData.nameEn = nameEn;
    }

    if (part !== undefined) {
      updateData.part = part;
    }

    if (phone !== undefined) {
      updateData.phone = phone;
    }
    
    const user = await User.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );
    
    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }
    
    res.json({ message: 'User updated successfully', user });
  } catch (error) {
    console.error('Error updating user permissions:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Internal server error' });
    }
  }
};
</file>

<file path="src/controllers/adminItemController.ts">
import { Request, Response } from 'express';
import { ItemCategory } from '../models';
import { validationResult } from 'express-validator';
import { ThumbnailGenerator } from '../utils/thumbnailGenerator';
import { uploadToFirebase } from '../config/firebase-storage';
import path from 'path';
import fs from 'fs/promises';

interface AuthRequest extends Request {
  user?: any;
}

interface MulterFiles {
  image?: Express.Multer.File[];
  thumbnail?: Express.Multer.File[];
}

// 파일 삭제 유틸리티 함수
const deleteFileIfExists = async (filePath: string): Promise<void> => {
  try {
    await fs.access(filePath);
    await fs.unlink(filePath);
    console.log(`File deleted: ${filePath}`);
  } catch (error) {
    // 파일이 존재하지 않거나 삭제 실패해도 무시
    console.warn(`Failed to delete file: ${filePath}`, error);
  }
};

// URL에서 실제 파일 경로 추출
const getFilePathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', filename);
};

// 썸네일 URL에서 실제 파일 경로 추출
const getThumbnailPathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', 'thumbnails', filename);
};

export const getAllItemCategories = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await ItemCategory.find(query).sort({ order: 1 });
    res.json({ categories, total: categories.length });
  } catch (error) {
    console.error('Error fetching item categories:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const getItemCategoryById = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await ItemCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    res.json(category);
  } catch (error) {
    console.error('Error fetching item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const createItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { name, type, order = 0 } = req.body;

    // 동일한 type이 있는지 확인
    const existingCategory = await ItemCategory.findOne({ type });
    if (existingCategory) {
      res.status(400).json({ message: 'Item category with this type already exists' });
      return;
    }

    const category = new ItemCategory({
      name,
      type,
      items: [],
      order
    });

    await category.save();
    res.status(201).json({ message: 'Item category created successfully', category });
  } catch (error) {
    console.error('Error creating item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, type, order } = req.body;

    // type이 변경되는 경우 중복 확인
    if (type) {
      const existingCategory = await ItemCategory.findOne({ type, _id: { $ne: id } });
      if (existingCategory) {
        res.status(400).json({ message: 'Item category with this type already exists' });
        return;
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (type !== undefined) updateData.type = type;
    if (order !== undefined) updateData.order = order;

    const category = await ItemCategory.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    res.json({ message: 'Item category updated successfully', category });
  } catch (error) {
    console.error('Error updating item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await ItemCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    // 카테고리의 모든 아이템 이미지 및 썸네일 삭제
    for (const item of category.items) {
      if (item.imageUrl) {
        const imagePath = getFilePathFromUrl(item.imageUrl);
        await deleteFileIfExists(imagePath);
      }
      if (item.thumbnailUrl) {
        const thumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
        await deleteFileIfExists(thumbnailPath);
      }
    }

    await ItemCategory.findByIdAndDelete(id);
    res.json({ message: 'Item category deleted successfully' });
  } catch (error) {
    console.error('Error deleting item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const addItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, order = 0, frames, columns = 16, duration, animationType } = req.body;
    const files = req.files as MulterFiles;

    if (!files || !files.image || files.image.length === 0) {
      res.status(400).json({ message: 'Image file is required' });
      return;
    }

    const category = await ItemCategory.findById(id);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const imageFile = files.image[0];
    if (!imageFile) {
      res.status(400).json({ message: 'Image file is required' });
      return;
    }

    // Firebase Storage에 이미지 업로드 (메모리에서 직접 사용)
    if (!imageFile.buffer) {
      res.status(400).json({ message: 'Image file buffer is missing' });
      return;
    }
    
    const imageResult = await uploadToFirebase(imageFile, 'uploads/items/');
    const imageUrl = imageResult.url;

    // 애니메이션 정보 처리
    let animation = undefined;
    if (animationType && animationType !== 'none') {
      // 애니메이션이 있는 경우만 animation 객체 생성
      if (frames && columns && duration) {
        animation = {
          frames: parseInt(frames),
          columns: parseInt(columns),
          duration: parseInt(duration),
          type: animationType
        };
      }
    }

    // 썸네일 처리
    let thumbnailUrl = '';
    let thumbnailSource: 'user' | 'auto' = 'auto';

    if (files.thumbnail && files.thumbnail.length > 0) {
      // 사용자가 썸네일을 제공한 경우
      const thumbnailFile = files.thumbnail[0];
      if (!thumbnailFile) {
        res.status(400).json({ message: 'Thumbnail file is invalid' });
        return;
      }
      // Firebase Storage에 썸네일 직접 업로드
      if (!thumbnailFile.buffer) {
        res.status(400).json({ message: 'Thumbnail file buffer is missing' });
        return;
      }
      
      const thumbnailUploadResult = await uploadToFirebase(thumbnailFile, 'uploads/thumbnails/');
      thumbnailUrl = thumbnailUploadResult.url;
      thumbnailSource = 'user';
    } else if (animation) {
      // 스프라이트 이미지에서 첫 번째 프레임 추출 (Firebase Storage URL 사용)
      const rows = Math.ceil(animation.frames / animation.columns);
      const thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
        imageUrl, // Firebase Storage URL 사용
        animation.columns,
        rows,
        imageFile.filename
      );
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    } else {
      // 일반 이미지에서 썸네일 생성 (Firebase Storage URL 사용)
      const thumbnailResult = await ThumbnailGenerator.generateThumbnail(
        imageUrl,
        imageFile.filename
      );
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    }

    const newItem = {
      name,
      imageUrl,
      animationUrl: animation ? imageUrl : undefined,
      animation,
      thumbnailUrl,
      thumbnailSource,
      order: parseInt(order) || 0
    };

    category.items.push(newItem as any);
    await category.save();

    res.status(201).json({ 
      message: 'Item added successfully', 
      item: newItem,
      category: category.name
    });
  } catch (error) {
    console.error('Error adding item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;
    const { name, order, frames, columns, duration, animationType } = req.body;
    const files = req.files as MulterFiles;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];

    // 기존 파일 경로 저장 (삭제용)
    const oldImagePath = item.imageUrl ? getFilePathFromUrl(item.imageUrl) : '';
    const oldThumbnailPath = item.thumbnailUrl ? getThumbnailPathFromUrl(item.thumbnailUrl) : '';

    // 기본 정보 업데이트
    if (name !== undefined) item.name = name;
    if (order !== undefined) item.order = parseInt(order);

    // 애니메이션 정보 업데이트
    if (animationType !== undefined) {
      if (animationType === 'none' || animationType === '') {
        // 애니메이션 없음 또는 선택 안함인 경우 animation 제거
        item.animation = undefined;
        item.animationUrl = undefined;
      } else {
        // 애니메이션이 있는 경우
        if (!item.animation) {
          item.animation = {
            frames: parseInt(frames) || 1,
            columns: parseInt(columns) || 1,
            duration: parseInt(duration) || 1000,
            type: animationType
          };
        } else {
          if (frames !== undefined) item.animation.frames = parseInt(frames);
          if (columns !== undefined) item.animation.columns = parseInt(columns);
          if (duration !== undefined) item.animation.duration = parseInt(duration);
          item.animation.type = animationType;
        }
        item.animationUrl = item.imageUrl;
      }
    } else if (frames || columns || duration) {
      // animationType이 undefined이지만 다른 애니메이션 정보가 있는 경우
      if (!item.animation) {
        item.animation = {
          frames: parseInt(frames) || 1,
          columns: parseInt(columns) || 1,
          duration: parseInt(duration) || 1000,
          type: 'loop'
        };
      } else {
        if (frames !== undefined) item.animation.frames = parseInt(frames);
        if (columns !== undefined) item.animation.columns = parseInt(columns);
        if (duration !== undefined) item.animation.duration = parseInt(duration);
      }
    }

    // 새 이미지가 있는 경우
    if (files && files.image && files.image.length > 0) {
      const imageFile = files.image[0];
      if (imageFile) {
        // Firebase Storage 사용 시 로컬 파일 삭제 불필요 (URL이므로)
        // 기존 Firebase Storage 파일은 자동으로 관리됨

        // Firebase Storage에 새 이미지 업로드 (메모리에서 직접 사용)
        if (!imageFile.buffer) {
          res.status(400).json({ message: 'Image file buffer is missing' });
          return;
        }
        
        const imageResult = await uploadToFirebase(imageFile, 'uploads/items/');
        item.imageUrl = imageResult.url;
        
        if (item.animation) {
          item.animationUrl = item.imageUrl;
        }

        // 기존 썸네일이 자동 생성된 것이면 새로 생성
        if (item.thumbnailSource === 'auto') {
          // Firebase Storage 사용 시 썸네일도 URL이므로 로컬 삭제 불필요

          let thumbnailResult;
          if (item.animation) {
            const rows = Math.ceil(item.animation.frames / item.animation.columns);
            thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
              item.imageUrl, // Firebase Storage URL 사용
              item.animation.columns,
              rows,
              imageFile.filename
            );
          } else {
            thumbnailResult = await ThumbnailGenerator.generateThumbnail(
              item.imageUrl, // Firebase Storage URL 사용
              imageFile.filename
            );
          }
          item.thumbnailUrl = thumbnailResult.thumbnailUrl;
        }
      }
    }

    // 새 썸네일이 있는 경우
    if (files && files.thumbnail && files.thumbnail.length > 0) {
      const thumbnailFile = files.thumbnail[0];
      if (thumbnailFile) {
        // Firebase Storage 사용 시 썸네일 파일도 URL이므로 로컬 삭제 불필요

        // Firebase Storage에 썸네일 업로드 후 처리
        if (!thumbnailFile.buffer) {
          res.status(400).json({ message: 'Thumbnail file buffer is missing' });
          return;
        }
        
        const thumbnailUploadResult = await uploadToFirebase(thumbnailFile, 'uploads/thumbnails/');
        item.thumbnailUrl = thumbnailUploadResult.url;
        item.thumbnailSource = 'user';
      }
    }

    await category.save();

    res.json({ 
      message: 'Item updated successfully', 
      item,
      category: category.name
    });
  } catch (error) {
    console.error('Error updating item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];

    // 관련 파일들 삭제
    if (item.imageUrl) {
      const imagePath = getFilePathFromUrl(item.imageUrl);
      await deleteFileIfExists(imagePath);
    }
    if (item.thumbnailUrl) {
      const thumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
      await deleteFileIfExists(thumbnailPath);
    }

    category.items.splice(itemIndex, 1);
    await category.save();

    res.json({ message: 'Item deleted successfully' });
  } catch (error) {
    console.error('Error deleting item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const regenerateItemThumbnail = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];
    
    // 원본 이미지 경로 추출
    const imagePath = path.join(process.cwd(), 'uploads', path.basename(item.imageUrl));
    
    // 기존 썸네일 삭제
    if (item.thumbnailUrl) {
      const oldThumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
      await deleteFileIfExists(oldThumbnailPath);
    }
    
    // 썸네일 재생성
    let thumbnailResult;
    if (item.animation) {
      const rows = Math.ceil(item.animation.frames / item.animation.columns);
      thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
        imagePath,
        item.animation.columns,
        rows
      );
    } else {
      thumbnailResult = await ThumbnailGenerator.generateThumbnail(imagePath);
    }
    
    item.thumbnailUrl = thumbnailResult.thumbnailUrl;
    item.thumbnailSource = 'auto';

    await category.save();

    res.json({ 
      message: 'Thumbnail regenerated successfully', 
      thumbnailUrl: item.thumbnailUrl
    });
  } catch (error) {
    console.error('Error regenerating thumbnail:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/authController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { generateToken } from '../middleware/auth';
import { validationResult } from 'express-validator';

export const loginUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    const { email, arId } = req.body;
    
    // 이메일 또는 arId로 사용자 찾기
    const query = email ? { email } : { arId };
    const user = await User.findOne(query);
    
    if (!user) {
      res.status(401).json({ error: 'Invalid credentials' });
      return;
    }
    
    // JWT 토큰 생성
    const token = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });
    
    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        nameEn: user.nameEn,
        role: user.role,
        part: user.part,
        arId: user.arId,
        isAdmin: user.isAdmin,
        isNamecardActive: user.isNamecardActive
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getTestToken = async (req: Request, res: Response): Promise<void> => {
  try {
    const { arId } = req.params;
    
    const user = await User.findOne({ arId });
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    const token = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });
    
    res.json({
      message: 'Test token generated',
      token,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        arId: user.arId,
        isAdmin: user.isAdmin
      }
    });
  } catch (error) {
    console.error('Test token generation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/avatarController.ts">
import { Request, Response } from 'express';
import { UserCustomization, AvatarCategory } from '../models';
import { validationResult } from 'express-validator';

export const getAvatarByUserId = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId } = req.params;
    
    // 먼저 id로 검색
    let avatar = await UserCustomization.findOne({ id: userId });
    let user = null;
    
    // id로 찾지 못하면 User 테이블에서 arId로 검색해서 실제 id를 찾아 다시 검색
    if (!avatar) {
      const { User } = require('../models');
      user = await User.findOne({ arId: userId });
      if (user) {
        avatar = await UserCustomization.findOne({ id: user._id.toString() });
      }
    } else {
      // avatar가 있으면 해당 사용자 정보도 가져오기
      const { User } = require('../models');
      user = await User.findById(avatar.id);
    }
    
    if (!avatar) {
      res.status(404).json({ error: 'Avatar not found' });
      return;
    }
    
    // 아바타 옵션들의 상세 정보 가져오기
    const { AvatarCategory, ItemCategory } = require('../models');
    
    // avatarSelections 상세 정보 가져오기
    const avatarSelectionsWithDetails: any = {};
    if (avatar.avatarSelections) {
      for (const [categoryType, optionId] of Object.entries(avatar.avatarSelections)) {
        const category = await AvatarCategory.findOne({ type: categoryType });
        if (category) {
          const option = category.options.find((opt: any) => opt._id.toString() === optionId);
          if (option) {
            // 기존 데이터 호환성을 위한 마이그레이션 로직
            let colorOptions = option.color;
            
            // 기존 구조(단일 color string)를 새 구조로 변환
            if (typeof option.color === 'string' && option.imageUrl) {
              colorOptions = [{
                colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
                imageUrl: option.imageUrl
              }];
            }
            // color가 배열이 아니고 imageUrl이 있는 경우 (null, undefined 등)
            else if (!Array.isArray(option.color) && option.imageUrl) {
              colorOptions = [{
                colorName: 'Default',
                imageUrl: option.imageUrl
              }];
            }
            
            avatarSelectionsWithDetails[categoryType] = {
              id: optionId,
              name: option.name,
              imageUrl: option.imageUrl,
              thumbnailUrl: option.thumbnailUrl,
              color: colorOptions
            };
          }
        }
      }
    }
    
    // role 상세 정보 가져오기
    let roleDetails = null;
    if (avatar.role) {
      const roleCategory = await ItemCategory.findOne({ type: 'role' });
      if (roleCategory) {
        const roleItem = roleCategory.items.find((item: any) => item._id.toString() === avatar.role);
        if (roleItem) {
          roleDetails = {
            id: avatar.role,
            name: roleItem.name,
            imageUrl: roleItem.imageUrl,
            thumbnailUrl: roleItem.thumbnailUrl
          };
        }
      }
    }
    
    // item1, item2, item3 상세 정보 가져오기
    const itemDetails: any = {};
    const items = ['item1', 'item2', 'item3'];
    
    for (const itemKey of items) {
      if ((avatar as any)[itemKey]) {
        // 모든 아이템 카테고리에서 검색
        const itemCategories = await ItemCategory.find({ type: { $ne: 'role' } });
        let found = false;
        
        for (const category of itemCategories) {
          const item = category.items.find((item: any) => item._id.toString() === (avatar as any)[itemKey]);
          if (item) {
            itemDetails[itemKey] = {
              id: (avatar as any)[itemKey],
              name: item.name,
              imageUrl: item.imageUrl,
              thumbnailUrl: item.thumbnailUrl,
              category: category.name
            };
            found = true;
            break;
          }
        }
        
        if (!found) {
          itemDetails[itemKey] = {
            id: (avatar as any)[itemKey],
            name: 'Unknown',
            imageUrl: null,
            thumbnailUrl: null,
            category: 'Unknown'
          };
        }
      }
    }
    
    // 최종 응답 구성 (사용자 정보 + 아바타 정보 통합)
    const response = {
      id: avatar.id,
      nameEn: user ? user.nameEn : null,
      email: user ? user.email : null,
      nameKr: user ? user.nameKr : null,
      part: user ? user.part : '',
      phone: user ? user.phone : null,
      isNamecardActive: user ? user.isNamecardActive : false,
      arId: user ? user.arId : null,
      isAdmin: user ? user.isAdmin : false,
      avatarSelections: avatarSelectionsWithDetails,
      role: roleDetails,
      item1: itemDetails['item1'] || null,
      item2: itemDetails['item2'] || null,
      item3: itemDetails['item3'] || null,
      avatarImgUrl: avatar.avatarImgUrl,
      message: avatar.message || '',
      createdAt: user ? user.createdAt : avatar.createdAt,
      updatedAt: user ? user.updatedAt : avatar.updatedAt
    };
    
    res.json(response);
  } catch (error) {
    console.error('Error fetching avatar:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const updateAvatar = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('Validation errors:', errors.array());
      res.status(400).json({ error: 'Validation failed', details: errors.array() });
      return;
    }
    
    const { userId } = req.params;
    const updateData = req.body;
    
    console.log('Updating avatar for user:', userId);
    console.log('Update data:', updateData);
    
    const avatar = await UserCustomization.findOneAndUpdate(
      { id: userId },
      updateData,
      { new: true, runValidators: true, upsert: true }
    );
    
    res.json(avatar);
  } catch (error) {
    console.error('Error updating avatar:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message, details: error });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const uploadAvatarImage = async (req: Request, res: Response): Promise<void> => {
  try {
    if (!req.file) {
      res.status(400).json({ error: 'No file uploaded' });
      return;
    }
    
    const { userId } = req.body;
    
    if (!userId) {
      res.status(400).json({ error: 'User ID is required' });
      return;
    }
    
    // Firebase Storage를 사용하여 이미지 업로드
    const { uploadToFirebase } = require('../config/firebase-storage');
    
    if (!req.file.buffer) {
      res.status(400).json({ error: 'File buffer is missing' });
      return;
    }
    
    const uploadResult = await uploadToFirebase(req.file, 'uploads/avatars/');
    const avatarImgUrl = uploadResult.url;
    
    const avatar = await UserCustomization.findOneAndUpdate(
      { id: userId },
      { avatarImgUrl },
      { new: true, runValidators: true, upsert: true }
    );
    
    res.json({ 
      message: 'Avatar image uploaded successfully',
      avatarImgUrl,
      avatar 
    });
  } catch (error) {
    console.error('Error uploading avatar image:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// 일반 사용자용 아바타 카테고리 조회 (마이그레이션 로직 포함)
export const getAvatarCategories = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await AvatarCategory.find(query).sort({ order: 1 });
    
    // 기존 데이터 호환성을 위한 마이그레이션 로직 적용
    const migratedCategories = categories.map(category => {
      const categoryObj = category.toObject();
      if (categoryObj.options) {
        categoryObj.options = categoryObj.options.map((option: any) => {
          // 기존 구조(단일 color string)를 새 구조로 변환
          if (typeof option.color === 'string' && option.imageUrl) {
            option.color = [{
              colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
              imageUrl: option.imageUrl
            }];
          }
          // color가 배열이 아니고 imageUrl이 있는 경우 (null, undefined 등)
          else if (!Array.isArray(option.color) && option.imageUrl) {
            option.color = [{
              colorName: 'Default',
              imageUrl: option.imageUrl
            }];
          }
          
          return option;
        });
      }
      return categoryObj;
    });
    
    res.json({ categories: migratedCategories, total: migratedCategories.length });
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/firebaseAuthController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { generateToken } from '../middleware/auth';
import { validationResult } from 'express-validator';
import { initializeFirebase, verifyIdToken } from '../scripts/config/firebase-admin';

export const verifyFirebaseToken = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    const { idToken } = req.body;

    initializeFirebase();

    const decodedToken = await verifyIdToken(idToken);
    const firebaseUid = decodedToken.uid;
    const firebaseEmail = decodedToken.email;

    if (!firebaseEmail) {
      res.status(400).json({ error: 'Firebase user email not found' });
      return;
    }

    let user = await User.findOne({ email: firebaseEmail });
    
    if (!user) {
      res.status(404).json({ 
        error: 'User not found in system',
        message: 'Firebase user exists but not registered in AR namecard system',
        firebaseEmail: firebaseEmail
      });
      return;
    }

    const jwtToken = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });

    res.json({
      message: 'Firebase authentication successful',
      token: jwtToken,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        nameEn: user.nameEn,
        role: user.role,
        part: user.part,
        arId: user.arId,
        isAdmin: user.isAdmin,
        isNamecardActive: user.isNamecardActive
      },
      firebase: {
        uid: firebaseUid,
        email: firebaseEmail
      }
    });
  } catch (error) {
    console.error('Firebase token verification error:', error);
    
    if (error instanceof Error && error.message.includes('Firebase ID token')) {
      res.status(401).json({ error: 'Invalid Firebase ID token' });
      return;
    }
    
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/itemController.ts">
import { Request, Response } from 'express';
import { ItemCategory, AvatarCategory } from '../models';

export const getItems = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    
    let query = {};
    
    if (type) {
      query = { type };
    }
    
    const items = await ItemCategory.find(query).sort({ order: 1, createdAt: -1 });
    
    res.json(items);
  } catch (error) {
    console.error('Error fetching items:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getItemById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const item = await ItemCategory.findById(id);
    
    if (!item) {
      res.status(404).json({ error: 'Item not found' });
      return;
    }
    
    res.json(item);
  } catch (error) {
    console.error('Error fetching item:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getAvatarCategories = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    
    let query = {};
    
    if (type) {
      query = { type };
    }
    
    const categories = await AvatarCategory.find(query).sort({ order: 1, createdAt: -1 });
    
    res.json(categories);
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getAvatarCategoryById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const category = await AvatarCategory.findById(id);
    
    if (!category) {
      res.status(404).json({ error: 'Avatar category not found' });
      return;
    }
    
    res.json(category);
  } catch (error) {
    console.error('Error fetching avatar category:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/userController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { validationResult } from 'express-validator';

export const getUserById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const user = await User.findById(id);
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    res.json(user);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const updateUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    
    const { id } = req.params;
    const updateData = req.body;
    
    const user = await User.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    res.json(user);
  } catch (error) {
    console.error('Error updating user:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const createUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    
    const userData = req.body;
    
    const existingUser = await User.findOne({
      $or: [
        { email: userData.email },
        { arId: userData.arId }
      ]
    });
    
    if (existingUser) {
      res.status(409).json({ error: 'User with this email or arId already exists' });
      return;
    }
    
    const user = new User(userData);
    await user.save();
    
    res.status(201).json(user);
  } catch (error) {
    console.error('Error creating user:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};
</file>

<file path="src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: any;
}

export const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction): void => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    res.status(401).json({ error: 'Access token required' });
    return;
  }

  const secret = process.env['JWT_SECRET'] || 'your-secret-key';
  
  jwt.verify(token, secret, (err, user) => {
    if (err) {
      res.status(403).json({ error: 'Invalid token' });
      return;
    }
    
    req.user = user;
    next();
  });
};

export const generateToken = (payload: any): string => {
  const secret = process.env['JWT_SECRET'] || 'your-secret-key';
  const expiresIn = process.env['JWT_EXPIRES_IN'] || '24h';
  
  return jwt.sign(payload, secret, { expiresIn } as jwt.SignOptions);
};
</file>

<file path="src/middleware/upload.ts">
import multer from 'multer';
import path from 'path';
import { Request } from 'express';
import { uploadToFirebase } from '../config/firebase-storage';

// 메모리 저장으로 변경
const storage = multer.memoryStorage();

const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  if (mimetype && extname) {
    cb(null, true);
  } else {
    cb(new Error('Only images and documents are allowed'));
  }
};

export const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  },
  fileFilter: fileFilter
});

// Firebase 업로드 함수
export const uploadToFirebaseStorage = async (
  file: Express.Multer.File,
  folder: string = 'uploads/'
): Promise<{ url: string; path: string }> => {
  return await uploadToFirebase(file, folder);
};

export const uploadSingle = (fieldName: string) => upload.single(fieldName);
export const uploadMultiple = (fieldName: string, maxCount: number) => upload.array(fieldName, maxCount);
export const uploadFields = (fields: multer.Field[]) => upload.fields(fields);
</file>

<file path="src/models/AvatarCategory.ts">
import { Schema, model, Document } from 'mongoose';

export interface IHairResourceImages {
  hairMiddleImageUrl: string;  // 중간머리 이미지 URL (필수)
  hairBackImageUrl?: string;   // 뒷머리 이미지 URL (선택사항)
}

export interface IColorOption {
  colorName: string;
  imageUrl: string;
  paletteImageUrl?: string;
  resourceImages?: IHairResourceImages;  // hair 카테고리용 리소스 이미지 객체
}

export interface IHairParts {
  middle: string;    // 중간머리 이미지 URL (필수)
  back?: string;     // 뒷머리 이미지 URL (선택사항)
}

export interface IAvatarOption {
  name: string;
  imageUrl: string;
  modelUrl?: string;
  thumbnailUrl?: string;
  thumbnailSource?: 'user' | 'auto';
  color?: IColorOption[];
  hairParts?: IHairParts;  // hair 카테고리 전용 필드
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface IAvatarCategory extends Document {
  name: string;
  type: string;
  options: IAvatarOption[];
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const avatarOptionSchema = new Schema<IAvatarOption>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  imageUrl: {
    type: String,
    required: true,
    trim: true
  },
  modelUrl: {
    type: String,
    trim: true
  },
  thumbnailUrl: {
    type: String,
    trim: true
  },
  thumbnailSource: {
    type: String,
    enum: ['user', 'auto'],
    default: 'auto'
  },
  color: [{
    colorName: {
      type: String,
      required: true,
      trim: true
    },
    imageUrl: {
      type: String,
      required: true,
      trim: true
    },
    paletteImageUrl: {
      type: String,
      trim: true
    },
    resourceImages: {
      hairMiddleImageUrl: {
        type: String,
        trim: true
      },
      hairBackImageUrl: {
        type: String,
        trim: true
      }
    }
  }],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  _id: true
});

const avatarCategorySchema = new Schema<IAvatarCategory>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  options: [avatarOptionSchema],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

avatarCategorySchema.index({ order: 1 });
avatarCategorySchema.index({ createdAt: -1 });

export const AvatarCategory = model<IAvatarCategory>('AvatarCategory', avatarCategorySchema);
</file>

<file path="src/models/index.ts">
export { User, IUser } from './User';
export { UserCustomization, IUserCustomization } from './UserCustomization';
export { AvatarCategory, IAvatarCategory, IAvatarOption } from './AvatarCategory';
export { ItemCategory, IItemCategory, IItem, IItemAnimation } from './ItemCategory';
</file>

<file path="src/models/ItemCategory.ts">
import { Schema, model, Document } from 'mongoose';

export interface IItemAnimation {
  frames: number;
  columns: number;
  duration: number;
  type: string;
}

export interface IItem {
  name: string;
  imageUrl: string;
  modelUrl?: string;
  animationUrl?: string;
  animation?: IItemAnimation;
  thumbnailUrl?: string;
  thumbnailSource?: 'user' | 'auto';
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface IItemCategory extends Document {
  name: string;
  type: string;
  items: IItem[];
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const itemAnimationSchema = new Schema<IItemAnimation>({
  frames: {
    type: Number,
    required: true
  },
  columns: {
    type: Number,
    required: true
  },
  duration: {
    type: Number,
    required: true
  },
  type: {
    type: String,
    required: true,
    trim: true
  }
}, { _id: false });

const itemSchema = new Schema<IItem>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  imageUrl: {
    type: String,
    required: true,
    trim: true
  },
  modelUrl: {
    type: String,
    trim: true
  },
  animationUrl: {
    type: String,
    trim: true
  },
  animation: {
    type: itemAnimationSchema,
    required: false
  },
  thumbnailUrl: {
    type: String,
    trim: true
  },
  thumbnailSource: {
    type: String,
    enum: ['user', 'auto'],
    default: 'auto'
  },
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  _id: true
});

const itemCategorySchema = new Schema<IItemCategory>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  items: [itemSchema],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

itemCategorySchema.index({ order: 1 });
itemCategorySchema.index({ createdAt: -1 });

export const ItemCategory = model<IItemCategory>('ItemCategory', itemCategorySchema);
</file>

<file path="src/models/User.ts">
import { Schema, model, Document } from 'mongoose';

export interface IUser extends Document {
  id: string;
  nameEn?: string;
  email: string;
  nameKr: string;
  role: string;
  part: string;
  phone: string;
  isNamecardActive: boolean;
  arId: string;
  isAdmin: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>({
  nameEn: {
    type: String,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  nameKr: {
    type: String,
    required: true,
    trim: true
  },
  role: {
    type: String,
    default: 'User',
    trim: true
  },
  part: {
    type: String,
    default: '',
    trim: true
  },
  phone: {
    type: String,
    required: true,
    trim: true
  },
  isNamecardActive: {
    type: Boolean,
    default: false
  },
  arId: {
    type: String,
    required: true,
    unique: true,
    minlength: 3,
    maxlength: 3,
    trim: true
  },
  isAdmin: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

userSchema.index({ createdAt: -1 });

export const User = model<IUser>('User', userSchema);
</file>

<file path="src/models/UserCustomization.ts">
import { Schema, model, Document, Types } from 'mongoose';

export interface IUserCustomization extends Document {
  id: string;
  avatarSelections: any; // Map<string, string> 또는 객체를 허용
  role?: string;
  item1?: string;
  item2?: string;
  item3?: string;
  avatarImgUrl?: string;
  message?: string;
  createdAt: Date;
  updatedAt: Date;
}

const userCustomizationSchema = new Schema<IUserCustomization>({
  id: {
    type: String,
    required: true,
    unique: true
  },
  avatarSelections: {
    type: Schema.Types.Mixed,
    default: {}
  },
  role: {
    type: String,
    trim: true
  },
  item1: {
    type: String,
    trim: true
  },
  item2: {
    type: String,
    trim: true
  },
  item3: {
    type: String,
    trim: true
  },
  avatarImgUrl: {
    type: String,
    default: null,
    trim: true
  },
  message: {
    type: String,
    trim: true,
    maxlength: 100
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      if (ret.avatarSelections) {
        if (ret.avatarSelections instanceof Map) {
          ret.avatarSelections = Object.fromEntries(ret.avatarSelections);
        } else if (typeof ret.avatarSelections === 'object' && ret.avatarSelections !== null) {
          // 이미 객체인 경우 그대로 유지
          ret.avatarSelections = ret.avatarSelections;
        } else {
          ret.avatarSelections = {};
        }
      } else {
        ret.avatarSelections = {};
      }
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

userCustomizationSchema.index({ createdAt: -1 });

export const UserCustomization = model<IUserCustomization>('UserCustomization', userCustomizationSchema);
</file>

<file path="src/routes/adminAvatarRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import {
  getAllAvatarCategories,
  getAvatarCategoryById,
  createAvatarCategory,
  updateAvatarCategory,
  deleteAvatarCategory,
  addAvatarOption,
  updateAvatarOption,
  deleteAvatarOption,
  regenerateThumbnail
} from '../controllers/adminAvatarController';
import { authenticateToken } from '../middleware/auth';
import { upload } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Admin - Characters
 *   description: 관리자 캐릭터 요소 관리 API
 */

const router = Router();

// 카테고리 관리
const categoryValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('type').isString().isLength({ min: 1, max: 50 }).withMessage('Type must be 1-50 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

// 옵션 관리
const optionValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('colorOptions').optional().isString().withMessage('Color options must be a JSON string'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

/**
 * @swagger
 * /api/admin/characters/categories:
 *   get:
 *     summary: 아바타 카테고리 목록 조회 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: 카테고리 타입 필터
 *     responses:
 *       200:
 *         description: 아바타 카테고리 목록
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 categories:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/AvatarCategory'
 *                 total:
 *                   type: integer
 *       401:
 *         description: 인증 실패
 *       403:
 *         description: 관리자 권한 필요
 */
router.get('/categories', authenticateToken, getAllAvatarCategories);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   get:
 *     summary: 아바타 카테고리 상세 조회 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     responses:
 *       200:
 *         description: 아바타 카테고리 상세 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarCategory'
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.get('/categories/:id', authenticateToken, getAvatarCategoryById);

/**
 * @swagger
 * /api/admin/characters/categories:
 *   post:
 *     summary: 새 아바타 카테고리 생성 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *             properties:
 *               name:
 *                 type: string
 *                 description: 카테고리 이름
 *                 example: "헤어스타일"
 *               type:
 *                 type: string
 *                 description: 카테고리 타입 (고유값)
 *                 example: "hair"
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *                 example: 1
 *     responses:
 *       201:
 *         description: 아바타 카테고리 생성 성공
 *       400:
 *         description: 잘못된 요청 또는 중복된 타입
 *       403:
 *         description: 관리자 권한 필요
 */
router.post('/categories', authenticateToken, categoryValidation, createAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   put:
 *     summary: 아바타 카테고리 수정 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: 카테고리 이름
 *               type:
 *                 type: string
 *                 description: 카테고리 타입
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       200:
 *         description: 아바타 카테고리 수정 성공
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.put('/categories/:id', authenticateToken, categoryValidation, updateAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   delete:
 *     summary: 아바타 카테고리 삭제 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     responses:
 *       200:
 *         description: 아바타 카테고리 삭제 성공
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.delete('/categories/:id', authenticateToken, deleteAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}/options:
 *   post:
 *     summary: 아바타 옵션 추가 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - colorOptions
 *             properties:
 *               name:
 *                 type: string
 *                 description: 옵션 이름
 *               colorOptions:
 *                 type: string
 *                 description: 색상 옵션 JSON 문자열 (예. [{"colorName":"red","imageUrl":"/uploads/red.jpg"}])
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: 썸네일 이미지 파일 (100x100px, 선택사항)
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       201:
 *         description: 아바타 옵션 추가 성공
 *       400:
 *         description: 잘못된 요청
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.post('/categories/:id/options', 
  authenticateToken, 
  upload.any(), 
  optionValidation, 
  addAvatarOption
);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}:
 *   put:
 *     summary: 아바타 옵션 수정 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: 옵션 ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: 옵션 이름
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: 새 원본 이미지 파일 (선택사항)
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: 새 썸네일 이미지 파일 (선택사항)
 *               color:
 *                 type: string
 *                 description: 색상 정보
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       200:
 *         description: 아바타 옵션 수정 성공
 *       404:
 *         description: 카테고리 또는 옵션을 찾을 수 없음
 */
router.put('/categories/:categoryId/options/:optionId', 
  authenticateToken, 
  upload.any(), 
  updateAvatarOption
);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}:
 *   delete:
 *     summary: 아바타 옵션 삭제 (관리자 전용)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: 옵션 ID
 *     responses:
 *       200:
 *         description: 아바타 옵션 삭제 성공
 *       404:
 *         description: 카테고리 또는 옵션을 찾을 수 없음
 */
router.delete('/categories/:categoryId/options/:optionId', authenticateToken, deleteAvatarOption);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}/thumbnail/regenerate:
 *   post:
 *     summary: 아바타 옵션 썸네일 재생성
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: 옵션 ID
 *     responses:
 *       200:
 *         description: 썸네일 재생성 성공
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 thumbnailUrl:
 *                   type: string
 *       404:
 *         description: 카테고리 또는 옵션을 찾을 수 없음
 */
router.post('/categories/:categoryId/options/:optionId/thumbnail/regenerate', authenticateToken, regenerateThumbnail);

export default router;
</file>

<file path="src/routes/adminItemRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import {
  getAllItemCategories,
  getItemCategoryById,
  createItemCategory,
  updateItemCategory,
  deleteItemCategory,
  addItem,
  updateItem,
  deleteItem,
  regenerateItemThumbnail
} from '../controllers/adminItemController';
import { authenticateToken } from '../middleware/auth';
import { upload } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Admin - Stickers
 *   description: 관리자 스티커 관리 API
 */

const router = Router();

// 카테고리 관리
const categoryValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('type').isString().isLength({ min: 1, max: 50 }).withMessage('Type must be 1-50 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

// 스티커 관리
const itemValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer'),
  body('frames').optional().isInt({ min: 1 }).withMessage('Frames must be a positive integer'),
  body('columns').optional().isInt({ min: 1, max: 64 }).withMessage('Columns must be 1-64'),
  body('duration').optional().isInt({ min: 1 }).withMessage('Duration must be a positive integer'),
  body('animationType').optional().isString().withMessage('Animation type must be a string')
];

/**
 * @swagger
 * /api/admin/stickers/categories:
 *   get:
 *     summary: 스티커 카테고리 목록 조회 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: 카테고리 타입 필터
 *     responses:
 *       200:
 *         description: 스티커 카테고리 목록
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 categories:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/ItemCategory'
 *                 total:
 *                   type: integer
 *       401:
 *         description: 인증 실패
 *       403:
 *         description: 관리자 권한 필요
 */
router.get('/categories', authenticateToken, getAllItemCategories);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   get:
 *     summary: 스티커 카테고리 상세 조회 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     responses:
 *       200:
 *         description: 스티커 카테고리 상세 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ItemCategory'
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.get('/categories/:id', authenticateToken, getItemCategoryById);

/**
 * @swagger
 * /api/admin/stickers/categories:
 *   post:
 *     summary: 새 스티커 카테고리 생성 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *             properties:
 *               name:
 *                 type: string
 *                 description: 카테고리 이름
 *                 example: "운동"
 *               type:
 *                 type: string
 *                 description: 카테고리 타입 (고유값)
 *                 example: "exercise"
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *                 example: 1
 *     responses:
 *       201:
 *         description: 스티커 카테고리 생성 성공
 *       400:
 *         description: 잘못된 요청 또는 중복된 타입
 *       403:
 *         description: 관리자 권한 필요
 */
router.post('/categories', authenticateToken, categoryValidation, createItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   put:
 *     summary: 스티커 카테고리 수정 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: 카테고리 이름
 *               type:
 *                 type: string
 *                 description: 카테고리 타입
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       200:
 *         description: 스티커 카테고리 수정 성공
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.put('/categories/:id', authenticateToken, categoryValidation, updateItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   delete:
 *     summary: 스티커 카테고리 삭제 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     responses:
 *       200:
 *         description: 스티커 카테고리 삭제 성공
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.delete('/categories/:id', authenticateToken, deleteItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}/items:
 *   post:
 *     summary: 스티커 추가 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - image
 *             properties:
 *               name:
 *                 type: string
 *                 description: 스티커 이름
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: 원본 이미지 또는 스프라이트 시퀀스 이미지
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: 썸네일 이미지 파일 (100x100px, 선택사항)
 *               frames:
 *                 type: integer
 *                 description: 총 프레임 수 (애니메이션인 경우)
 *               columns:
 *                 type: integer
 *                 description: 스프라이트시트 컬럼 수 (기본값 16)
 *                 default: 16
 *               duration:
 *                 type: integer
 *                 description: 애니메이션 지속 시간 (ms)
 *               animationType:
 *                 type: string
 *                 description: 애니메이션 타입 (loop, once, etc.)
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       201:
 *         description: 스티커 추가 성공
 *       400:
 *         description: 잘못된 요청
 *       404:
 *         description: 카테고리를 찾을 수 없음
 */
router.post('/categories/:id/items', 
  authenticateToken, 
  upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'thumbnail', maxCount: 1 }
  ]), 
  itemValidation, 
  addItem
);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}:
 *   put:
 *     summary: 스티커 수정 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: 스티커 ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: 스티커 이름
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: 새 원본 이미지 (선택사항)
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: 새 썸네일 이미지 (선택사항)
 *               frames:
 *                 type: integer
 *                 description: 총 프레임 수
 *               columns:
 *                 type: integer
 *                 description: 스프라이트시트 컬럼 수
 *               duration:
 *                 type: integer
 *                 description: 애니메이션 지속 시간 (ms)
 *               animationType:
 *                 type: string
 *                 description: 애니메이션 타입
 *               order:
 *                 type: integer
 *                 description: 표시 순서
 *     responses:
 *       200:
 *         description: 스티커 수정 성공
 *       404:
 *         description: 카테고리 또는 스티커을 찾을 수 없음
 */
router.put('/categories/:categoryId/items/:itemId', 
  authenticateToken, 
  upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'thumbnail', maxCount: 1 }
  ]), 
  updateItem
);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}:
 *   delete:
 *     summary: 스티커 삭제 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: 스티커 ID
 *     responses:
 *       200:
 *         description: 스티커 삭제 성공
 *       404:
 *         description: 카테고리 또는 스티커을 찾을 수 없음
 */
router.delete('/categories/:categoryId/items/:itemId', authenticateToken, deleteItem);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}/regenerate-thumbnail:
 *   post:
 *     summary: 스티커 썸네일 재생성 (관리자 전용)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: 카테고리 ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: 스티커 ID
 *     responses:
 *       200:
 *         description: 썸네일 재생성 성공
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 thumbnailUrl:
 *                   type: string
 *       404:
 *         description: 카테고리 또는 스티커을 찾을 수 없음
 */
router.post('/categories/:categoryId/items/:itemId/regenerate-thumbnail', authenticateToken, regenerateItemThumbnail);

export default router;
</file>

<file path="src/routes/adminRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getAllUsers, updateUserPermissions } from '../controllers/adminController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Admin - Users
 *   description: 관리자 사용자 관리 API
 */

const router = Router();

const permissionUpdateValidation = [
  body('isAdmin').optional().isBoolean().withMessage('isAdmin must be a boolean'),
  body('isNamecardActive').optional().isBoolean().withMessage('isNamecardActive must be a boolean'),
  body('role').optional().isString().withMessage('role must be a string').trim()
];

/**
 * @swagger
 * /api/admin/users:
 *   get:
 *     summary: 전체 사용자 목록 조회 (관리자 전용)
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: 페이지 번호
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *         description: 페이지당 항목 수
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: 검색어 (이름, 이메일, arId)
 *       - in: query
 *         name: role
 *         schema:
 *           type: string
 *         description: 역할 필터
 *       - in: query
 *         name: isActive
 *         schema:
 *           type: boolean
 *         description: 활성화 상태 필터
 *     responses:
 *       200:
 *         description: 사용자 목록
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 *                 pagination:
 *                   type: object
 *                   properties:
 *                     page:
 *                       type: integer
 *                     limit:
 *                       type: integer
 *                     total:
 *                       type: integer
 *                     pages:
 *                       type: integer
 *       401:
 *         description: 인증 실패
 *       403:
 *         description: 관리자 권한 필요
 */
router.get('/users', authenticateToken, getAllUsers);

/**
 * @swagger
 * /api/admin/users/{id}:
 *   put:
 *     summary: 사용자 권한 관리 (관리자 전용)
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 사용자 ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               isAdmin:
 *                 type: boolean
 *                 description: 관리자 여부
 *               isNamecardActive:
 *                 type: boolean
 *                 description: 명함 활성화 여부
 *               role:
 *                 type: string
 *                 description: 역할
 *     responses:
 *       200:
 *         description: 수정된 사용자 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: 잘못된 요청
 *       401:
 *         description: 인증 실패
 *       403:
 *         description: 관리자 권한 필요
 *       404:
 *         description: 사용자를 찾을 수 없음
 */
router.put('/users/:id', authenticateToken, permissionUpdateValidation, updateUserPermissions);

export default router;
</file>

<file path="src/routes/authRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { loginUser, getTestToken } from '../controllers/authController';

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: "사용자 인증 API"
 */

const router = Router();

const loginValidation = [
  body('email').optional().isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('arId').optional().isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters')
];

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: "사용자 로그인"
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 description: "이메일 (email 또는 arId 중 하나 필수)"
 *               arId:
 *                 type: string
 *                 description: "AR 명함 ID (email 또는 arId 중 하나 필수)"
 *             example:
 *               email: "hyeonseo.ahn@hnine.com"
 *     responses:
 *       200:
 *         description: "로그인 성공"
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 token:
 *                   type: string
 *                   description: "JWT 토큰"
 *                 user:
 *                   $ref: '#/components/schemas/User'
 *       401:
 *         description: "인증 실패"
 *       400:
 *         description: "잘못된 요청"
 */
router.post('/login', loginValidation, loginUser);

/**
 * @swagger
 * /api/auth/test-token/{arId}:
 *   get:
 *     summary: "테스트용 토큰 생성 (개발용)"
 *     tags: [Authentication]
 *     parameters:
 *       - in: path
 *         name: arId
 *         required: true
 *         schema:
 *           type: string
 *         description: "AR 명함 ID (예: 001)"
 *     responses:
 *       200:
 *         description: "테스트 토큰 생성 성공"
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 token:
 *                   type: string
 *                   description: "JWT 토큰"
 *                 user:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                     email:
 *                       type: string
 *                     nameKr:
 *                       type: string
 *                     arId:
 *                       type: string
 *                     isAdmin:
 *                       type: boolean
 *       404:
 *         description: "사용자를 찾을 수 없음"
 */
router.get('/test-token/:arId', getTestToken);

export default router;
</file>

<file path="src/routes/avatarRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getAvatarByUserId, updateAvatar, uploadAvatarImage } from '../controllers/avatarController';
// import { getAvatarCategories } from '../controllers/avatarController'; // Hidden endpoint
import { authenticateToken } from '../middleware/auth';
import { uploadSingle } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Avatars
 *   description: 아바타 관리 API
 */

const router = Router();

// Hidden endpoint - 아바타 카테고리 목록 조회는 Characters API에서 처리
// /**
//  * @swagger
//  * /api/avatars/categories:
//  *   get:
//  *     summary: 아바타 카테고리 목록 조회 (일반 사용자용)
//  *     tags: [Avatars]
//  *     parameters:
//  *       - in: query
//  *         name: type
//  *         schema:
//  *           type: string
//  *         description: 카테고리 타입 필터
//  *     responses:
//  *       200:
//  *         description: 아바타 카테고리 목록
//  *         content:
//  *           application/json:
//  *             schema:
//  *               type: object
//  *               properties:
//  *                 categories:
//  *                   type: array
//  *                   items:
//  *                     $ref: '#/components/schemas/AvatarCategory'
//  *                 total:
//  *                   type: integer
//  */
// router.get('/categories', getAvatarCategories);

const avatarValidation = [
  body('avatarSelections').optional().isObject().withMessage('Avatar selections must be an object'),
  body('role').optional().trim(),
  body('item1').optional().trim(),
  body('item2').optional().trim(),
  body('item3').optional().trim(),
  body('avatarImgUrl').optional().matches(/^(\/uploads\/.*\.(png|jpg|jpeg|gif|webp)$|https:\/\/.*\.(png|jpg|jpeg|gif|webp)$)/i).withMessage('Avatar image URL must be a valid image path').trim()
];

/**
 * @swagger
 * /api/avatars/{userId}:
 *   get:
 *     summary: 아바타 정보 조회 (사용자 정보 포함 8thwall 용)
 *     tags: [Avatars]
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: 사용자 ID 또는 arId
 *     responses:
 *       200:
 *         description: 사용자 정보와 아바타 정보가 합쳐진 응답
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarWithUser'
 *       404:
 *         description: 아바타를 찾을 수 없음
 */
router.get('/:userId', getAvatarByUserId);

/**
 * @swagger
 * /api/avatars/{userId}:
 *   put:
 *     summary: 아바타 정보 수정
 *     tags: [Avatars]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: 사용자 ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               avatarSelections:
 *                 type: object
 *                 description: 아바타 선택 옵션
 *                 additionalProperties:
 *                   type: string
 *               role:
 *                 type: string
 *                 description: 역할
 *               item1:
 *                 type: string
 *                 description: 아이템 1
 *               item2:
 *                 type: string
 *                 description: 아이템 2
 *               item3:
 *                 type: string
 *                 description: 아이템 3
 *               avatarImgUrl:
 *                 type: string
 *                 description: 아바타 이미지 URL
 *     responses:
 *       200:
 *         description: 수정된 아바타 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserCustomization'
 *       400:
 *         description: 잘못된 요청
 *       401:
 *         description: 인증 실패
 */
router.put('/:userId', authenticateToken, avatarValidation, updateAvatar);

/**
 * @swagger
 * /api/avatars/upload:
 *   post:
 *     summary: 아바타 이미지 업로드
 *     tags: [Avatars]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               avatar:
 *                 type: string
 *                 format: binary
 *                 description: 아바타 이미지 파일
 *               userId:
 *                 type: string
 *                 description: 사용자 ID
 *             required:
 *               - avatar
 *               - userId
 *     responses:
 *       200:
 *         description: 업로드 성공
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: 성공 메시지
 *                 avatarImgUrl:
 *                   type: string
 *                   description: 업로드된 이미지 URL
 *                 avatar:
 *                   $ref: '#/components/schemas/UserCustomization'
 *       400:
 *         description: 잘못된 요청
 *       401:
 *         description: 인증 실패
 */
router.post('/upload', authenticateToken, uploadSingle('avatar'), uploadAvatarImage);

export default router;
</file>

<file path="src/routes/charactersRoutes.ts">
import { Router } from 'express';
import { getAvatarCategories, getAvatarCategoryById } from '../controllers/itemController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Characters And Stickers
 *   description: 캐릭터 요소 및 스티커 관리 API
 */

const router = Router();

/**
 * @swagger
 * /api/characters:
 *   get:
 *     summary: 캐릭터 요소 전체 목록 조회 (눈, 코, 입, 머리, 눈썹 등)
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: 카테고리 타입 필터
 *     responses:
 *       200:
 *         description: 캐릭터 카테고리 목록
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/AvatarCategory'
 *       401:
 *         description: 인증 실패
 */
router.get('/', authenticateToken, getAvatarCategories);

/**
 * @swagger
 * /api/characters/{id}:
 *   get:
 *     summary: 캐릭터 요소 상세 조회
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 캐릭터 카테고리 ID
 *     responses:
 *       200:
 *         description: 캐릭터 카테고리 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarCategory'
 *       401:
 *         description: 인증 실패
 *       404:
 *         description: 캐릭터 카테고리를 찾을 수 없음
 */
router.get('/:id', authenticateToken, getAvatarCategoryById);

export default router;
</file>

<file path="src/routes/firebaseAuthRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { verifyFirebaseToken } from '../controllers/firebaseAuthController';

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: 사용자 인증 API
 */

const router = Router();

const firebaseTokenValidation = [
  body('idToken')
    .notEmpty()
    .withMessage('Firebase ID token is required')
    .isString()
    .withMessage('ID token must be a string')
];

/**
 * @swagger
 * /api/auth/firebase/verify:
 *   post:
 *     summary: Firebase ID 토큰 검증 및 로그인
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - idToken
 *             properties:
 *               idToken:
 *                 type: string
 *                 description: Firebase Authentication에서 발급된 ID 토큰
 *             example:
 *               idToken: "eyJhbGciOiJSUzI1NiIsImtpZCI6IjE2N..."
 *     responses:
 *       200:
 *         description: Firebase 인증 성공
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Firebase authentication successful"
 *                 token:
 *                   type: string
 *                   description: AR 명함 시스템 JWT 토큰
 *                 user:
 *                   $ref: '#/components/schemas/User'
 *                 firebase:
 *                   type: object
 *                   properties:
 *                     uid:
 *                       type: string
 *                       description: Firebase 사용자 UID
 *                     email:
 *                       type: string
 *                       description: Firebase 사용자 이메일
 *       400:
 *         description: 잘못된 요청 (ID 토큰 누락 등)
 *       401:
 *         description: 유효하지 않은 Firebase ID 토큰
 *       404:
 *         description: Firebase 사용자는 존재하지만 AR 명함 시스템에 등록되지 않음
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found in system"
 *                 message:
 *                   type: string
 *                   example: "Firebase user exists but not registered in AR namecard system"
 *                 firebaseEmail:
 *                   type: string
 *                   description: Firebase에서 확인된 이메일
 *       500:
 *         description: 서버 내부 오류
 */
router.post('/verify', firebaseTokenValidation, verifyFirebaseToken);

export default router;
</file>

<file path="src/routes/itemRoutes.ts">
import { Router } from 'express';
import { getItems, getItemById, getAvatarCategories, getAvatarCategoryById } from '../controllers/itemController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Characters And Stickers
 *   description: 캐릭터 요소 및 스티커 관리 API
 */

const router = Router();

/**
 * @swagger
 * /api/stickers:
 *   get:
 *     summary: 스티커 전체 목록 조회
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: 스티커 타입 필터
 *     responses:
 *       200:
 *         description: 스티커 목록
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/ItemCategory'
 *       401:
 *         description: 인증 실패
 */
router.get('/', authenticateToken, getItems);

/**
 * @swagger
 * /api/stickers/{id}:
 *   get:
 *     summary: 스티커 상세 조회
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 스티커 ID
 *     responses:
 *       200:
 *         description: 스티커 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ItemCategory'
 *       401:
 *         description: 인증 실패
 *       404:
 *         description: 스티커를 찾을 수 없음
 */
router.get('/:id', authenticateToken, getItemById);

export default router;
</file>

<file path="src/routes/userRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getUserById, updateUser, createUser } from '../controllers/userController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Admin - Users
 *   description: 관리자 사용자 관리 API
 */

const router = Router();

const userValidation = [
  body('email').isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('nameKr').notEmpty().withMessage('Korean name is required').trim(),
  body('phone').notEmpty().withMessage('Phone number is required').trim(),
  body('arId').isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters'),
  body('nameEn').optional().trim(),
  body('role').optional().trim(),
  body('part').optional().trim(),
  body('isNamecardActive').optional().isBoolean(),
  body('isAdmin').optional().isBoolean()
];

const userUpdateValidation = [
  body('email').optional().isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('nameKr').optional().notEmpty().withMessage('Korean name cannot be empty').trim(),
  body('phone').optional().notEmpty().withMessage('Phone number cannot be empty').trim(),
  body('arId').optional().isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters'),
  body('nameEn').optional().trim(),
  body('role').optional().trim(),
  body('part').optional().trim(),
  body('isNamecardActive').optional().isBoolean(),
  body('isAdmin').optional().isBoolean()
];

/**
 * @swagger
 * /api/users/{id}:
 *   get:
 *     summary: 사용자 정보 조회
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 사용자 ID
 *     responses:
 *       200:
 *         description: 사용자 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       401:
 *         description: 인증 실패
 *       404:
 *         description: 사용자를 찾을 수 없음
 */
router.get('/:id', authenticateToken, getUserById);

/**
 * @swagger
 * /api/users/{id}:
 *   put:
 *     summary: 사용자 정보 수정
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: 사용자 ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nameEn:
 *                 type: string
 *                 description: 영문 이름
 *               email:
 *                 type: string
 *                 description: 이메일
 *               nameKr:
 *                 type: string
 *                 description: 한글 이름
 *               role:
 *                 type: string
 *                 description: 역할
 *               part:
 *                 type: string
 *                 description: 소속 부서
 *               phone:
 *                 type: string
 *                 description: 전화번호
 *               isNamecardActive:
 *                 type: boolean
 *                 description: 명함 활성화 여부
 *               arId:
 *                 type: string
 *                 description: AR 명함 ID (3자리)
 *               isAdmin:
 *                 type: boolean
 *                 description: 관리자 여부
 *     responses:
 *       200:
 *         description: 수정된 사용자 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: 잘못된 요청
 *       401:
 *         description: 인증 실패
 *       404:
 *         description: 사용자를 찾을 수 없음
 */
router.put('/:id', authenticateToken, userUpdateValidation, updateUser);

/**
 * @swagger
 * /api/users:
 *   post:
 *     summary: 사용자 생성
 *     tags: [Admin - Users]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - nameKr
 *               - phone
 *               - arId
 *             properties:
 *               nameEn:
 *                 type: string
 *                 description: 영문 이름
 *               email:
 *                 type: string
 *                 description: 이메일
 *               nameKr:
 *                 type: string
 *                 description: 한글 이름
 *               role:
 *                 type: string
 *                 description: 역할
 *                 default: User
 *               part:
 *                 type: string
 *                 description: 소속 부서
 *                 default: ""
 *               phone:
 *                 type: string
 *                 description: 전화번호
 *               isNamecardActive:
 *                 type: boolean
 *                 description: 명함 활성화 여부
 *                 default: false
 *               arId:
 *                 type: string
 *                 description: AR 명함 ID (3자리)
 *                 minLength: 3
 *                 maxLength: 3
 *               isAdmin:
 *                 type: boolean
 *                 description: 관리자 여부
 *                 default: false
 *     responses:
 *       201:
 *         description: 생성된 사용자 정보
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: 잘못된 요청
 *       409:
 *         description: 이미 존재하는 사용자
 */
router.post('/', userValidation, createUser);

export default router;
</file>

<file path="src/scripts/config/firebase-admin.ts">
import * as admin from 'firebase-admin';
import * as path from 'path';

export const initializeFirebase = (): admin.app.App => {
  if (!admin.apps.length) {
    // 환경변수 우선, 없으면 파일 기반 fallback
    if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_PRIVATE_KEY && process.env.FIREBASE_CLIENT_EMAIL) {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
        }),
        projectId: process.env.FIREBASE_PROJECT_ID
      });
    } else {
      // 로컬 개발용 fallback
      try {
        const serviceAccount = require(path.join(__dirname, '../../../hninepeople-firebase-adminsdk-fbsvc-cf8551df6d.json'));
        admin.initializeApp({
          credential: admin.credential.cert(serviceAccount),
          projectId: 'hninepeople'
        });
      } catch (error) {
        console.error('Firebase initialization failed. Please set environment variables or provide service account file.');
        throw error;
      }
    }
  }
  return admin.app();
};

export const getFirestore = (): admin.firestore.Firestore => {
  return admin.firestore();
};

export const verifyIdToken = async (idToken: string): Promise<admin.auth.DecodedIdToken> => {
  try {
    return await admin.auth().verifyIdToken(idToken);
  } catch (error) {
    throw new Error(`Failed to verify Firebase ID token: ${error}`);
  }
};

export { admin };
</file>

<file path="src/scripts/types/firebase-user.ts">
export interface FirebaseUser {
  email: string;
  englishName: string;
  koreanName: string;
  organization: string;
  position: string;
  role: string;
  imageUrl: string;
}

export interface MigrationResult {
  success: boolean;
  userId?: string;
  email: string;
  arId?: string;
  error?: string;
}

export interface MigrationReport {
  total: number;
  success: number;
  failed: number;
  results: MigrationResult[];
  startTime: Date;
  endTime: Date;
}
</file>

<file path="src/scripts/utils/arId-generator.ts">
import { User } from '../../models';

export class ArIdGenerator {
  private static instance: ArIdGenerator;
  private currentId: number = 0;

  private constructor() {}

  public static getInstance(): ArIdGenerator {
    if (!ArIdGenerator.instance) {
      ArIdGenerator.instance = new ArIdGenerator();
    }
    return ArIdGenerator.instance;
  }

  public async initialize(): Promise<void> {
    try {
      // 기존 DB에서 가장 큰 arId 찾기
      const lastUser = await User.findOne({}, { arId: 1 })
        .sort({ arId: -1 })
        .lean();

      if (lastUser && lastUser.arId) {
        this.currentId = parseInt(lastUser.arId);
      }
      
      console.log(`ArId Generator initialized. Starting from: ${this.currentId}`);
    } catch (error) {
      console.error('Error initializing ArId Generator:', error);
      this.currentId = 0;
    }
  }

  public async generateNextArId(): Promise<string> {
    let nextId = this.currentId + 1;
    let arId = this.formatArId(nextId);
    
    // 중복 검사
    while (await this.isArIdExists(arId)) {
      nextId++;
      arId = this.formatArId(nextId);
    }
    
    this.currentId = nextId;
    return arId;
  }

  private formatArId(id: number): string {
    return id.toString().padStart(3, '0');
  }

  private async isArIdExists(arId: string): Promise<boolean> {
    try {
      const existing = await User.findOne({ arId }).lean();
      return !!existing;
    } catch (error) {
      console.error('Error checking arId existence:', error);
      return false;
    }
  }

  public getCurrentId(): number {
    return this.currentId;
  }
}
</file>

<file path="src/scripts/utils/data-mapper.ts">
import { FirebaseUser } from '../types/firebase-user';
import { IUser } from '../../models';

export class DataMapper {
  public static mapFirebaseUserToUser(firebaseUser: FirebaseUser, arId: string): Partial<IUser> {
    return {
      email: firebaseUser.email,
      nameEn: firebaseUser.englishName,
      nameKr: firebaseUser.koreanName,
      part: firebaseUser.organization,
      role: firebaseUser.role,
      phone: '010-0000-0000',
      arId: arId,
      isNamecardActive: false,
      isAdmin: false
    };
  }

  public static mapFirebaseUserToCustomization(firebaseUser: FirebaseUser, userId: string): any {
    return {
      id: userId, // MongoDB ObjectId will be set
      avatarSelections: new Map(),
      role: firebaseUser.role,
      avatarImgUrl: null // Firebase imageUrl 무시, null로 설정
    };
  }

  public static validateFirebaseUser(data: any): FirebaseUser | null {
    if (!data || typeof data !== 'object') {
      return null;
    }

    const requiredFields = ['email', 'englishName', 'koreanName', 'organization', 'role'];
    for (const field of requiredFields) {
      if (!data[field] || typeof data[field] !== 'string') {
        console.warn(`Missing or invalid field: ${field}`);
        return null;
      }
    }

    return {
      email: data.email,
      englishName: data.englishName,
      koreanName: data.koreanName,
      organization: data.organization,
      position: data.position || '',
      role: data.role,
      imageUrl: data.imageUrl || ''
    };
  }
}
</file>

<file path="src/scripts/create-admin.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { User } from '../models';

// 환경 변수 로드
dotenv.config();

const createAdmin = async (): Promise<void> => {
  try {
    console.log('🔧 Creating admin user...');
    
    // MongoDB 연결
    await connectDB();
    console.log('✅ MongoDB connected');

    // arId 001 사용자를 관리자로 변경
    const result = await User.findOneAndUpdate(
      { arId: '001' },
      { isAdmin: true },
      { new: true }
    );

    if (result) {
      console.log(`✅ User ${result.email} (arId: ${result.arId}) is now an admin`);
      console.log(`📧 Email: ${result.email}`);
      console.log(`👤 Name: ${result.nameKr} (${result.nameEn})`);
      console.log(`🏢 Part: ${result.part}`);
      console.log(`👑 Admin: ${result.isAdmin}`);
    } else {
      console.log('❌ User with arId 001 not found');
    }

    console.log('\n🎉 Admin creation completed!');
    process.exit(0);

  } catch (error) {
    console.error('💥 Error creating admin:', error);
    process.exit(1);
  }
};

// 스크립트 실행
if (require.main === module) {
  createAdmin();
}
</file>

<file path="src/scripts/firebase-migration.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { initializeFirebase, getFirestore } from './config/firebase-admin';
import { ArIdGenerator } from './utils/arId-generator';
import { DataMapper } from './utils/data-mapper';
import { User, UserCustomization } from '../models';
import { FirebaseUser, MigrationResult, MigrationReport } from './types/firebase-user';
import * as admin from 'firebase-admin';

// 환경 변수 로드
dotenv.config();

class FirebaseMigration {
  private arIdGenerator: ArIdGenerator;
  private firestore!: admin.firestore.Firestore;

  constructor() {
    this.arIdGenerator = ArIdGenerator.getInstance();
  }

  public async run(): Promise<void> {
    console.log('🔥 Firebase to MongoDB Migration Started');
    console.log('==========================================');

    const startTime = new Date();
    const report: MigrationReport = {
      total: 0,
      success: 0,
      failed: 0,
      results: [],
      startTime,
      endTime: new Date()
    };

    try {
      // 1. 연결 초기화
      await this.initializeConnections();

      // 2. Firebase에서 사용자 데이터 가져오기
      const firebaseUsers = await this.fetchFirebaseUsers();
      report.total = firebaseUsers.length;

      console.log(`📊 Found ${firebaseUsers.length} users in Firebase`);

      // 3. 각 사용자 마이그레이션
      for (const firebaseUser of firebaseUsers) {
        const result = await this.migrateUser(firebaseUser);
        report.results.push(result);
        
        if (result.success) {
          report.success++;
          console.log(`✅ ${result.email} → User ID: ${result.userId}, arId: ${result.arId}`);
        } else {
          report.failed++;
          console.log(`❌ ${result.email} → Error: ${result.error}`);
        }
      }

      report.endTime = new Date();
      this.printReport(report);

    } catch (error) {
      console.error('💥 Migration failed:', error);
      process.exit(1);
    }
  }

  private async initializeConnections(): Promise<void> {
    console.log('🔌 Initializing connections...');
    
    // MongoDB 연결
    await connectDB();
    console.log('✅ MongoDB connected');

    // Firebase 초기화
    initializeFirebase();
    this.firestore = getFirestore();
    console.log('✅ Firebase initialized');

    // ArId Generator 초기화
    await this.arIdGenerator.initialize();
    console.log('✅ ArId Generator initialized');
  }

  private async fetchFirebaseUsers(): Promise<FirebaseUser[]> {
    console.log('📥 Fetching users from Firebase...');
    
    const snapshot = await this.firestore.collection('people').get();
    const users: FirebaseUser[] = [];

    snapshot.forEach((doc: admin.firestore.QueryDocumentSnapshot) => {
      const data = doc.data();
      const user = DataMapper.validateFirebaseUser(data);
      
      if (user) {
        users.push(user);
      } else {
        console.warn(`⚠️ Invalid user data for document: ${doc.id}`);
      }
    });

    return users;
  }

  private async migrateUser(firebaseUser: FirebaseUser): Promise<MigrationResult> {
    try {
      // 1. 이메일 중복 검사
      const existingUser = await User.findOne({ email: firebaseUser.email });
      if (existingUser) {
        return {
          success: false,
          email: firebaseUser.email,
          error: 'Email already exists'
        };
      }

      // 2. arId 생성
      const arId = await this.arIdGenerator.generateNextArId();

      // 3. User 생성
      const userData = DataMapper.mapFirebaseUserToUser(firebaseUser, arId);
      const user = new User(userData);
      await user.save();

      // 4. UserCustomization 생성
      const customizationData = DataMapper.mapFirebaseUserToCustomization(firebaseUser, (user._id as any).toString());
      const customization = new UserCustomization(customizationData);
      await customization.save();

      return {
        success: true,
        userId: (user._id as any).toString(),
        email: firebaseUser.email,
        arId: arId
      };

    } catch (error) {
      return {
        success: false,
        email: firebaseUser.email,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private printReport(report: MigrationReport): void {
    const duration = report.endTime.getTime() - report.startTime.getTime();
    
    console.log('\n🎯 Migration Report');
    console.log('==================');
    console.log(`📊 Total: ${report.total}`);
    console.log(`✅ Success: ${report.success}`);
    console.log(`❌ Failed: ${report.failed}`);
    console.log(`⏱️ Duration: ${duration}ms`);
    console.log(`🚀 Success Rate: ${((report.success / report.total) * 100).toFixed(1)}%`);
    
    if (report.failed > 0) {
      console.log('\n❌ Failed Users:');
      report.results.filter(r => !r.success).forEach(result => {
        console.log(`  - ${result.email}: ${result.error}`);
      });
    }
    
    console.log('\n🎉 Migration completed!');
  }
}

// 스크립트 실행
if (require.main === module) {
  const migration = new FirebaseMigration();
  migration.run().catch(error => {
    console.error('💥 Migration script error:', error);
    process.exit(1);
  });
}
</file>

<file path="src/scripts/update-admin-permissions.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { User } from '../models';

// 환경 변수 로드
dotenv.config();

interface AdminUpdate {
  email: string;
  isAdmin: boolean;
  action: 'remove' | 'add';
}

const updateAdminPermissions = async (): Promise<void> => {
  try {
    console.log('🔧 Starting admin permission updates...');
    
    // MongoDB 연결
    await connectDB();
    console.log('✅ MongoDB connected');

    // 업데이트할 사용자 목록 정의
    const adminUpdates: AdminUpdate[] = [
      {
        email: 'hyeonseo.ahn@hnine.com',
        isAdmin: false,
        action: 'remove'
      },
      {
        email: 'beomseok.jang@hnine.com',
        isAdmin: true,
        action: 'add'
      },
      {
        email: 'kyungmin.woo@hnine.com',
        isAdmin: true,
        action: 'add'
      },
      {
        email: 'daekyo.jeong@hnine.com',
        isAdmin: true,
        action: 'add'
      }
    ];

    console.log(`📝 Processing ${adminUpdates.length} user permission updates...\n`);

    let successCount = 0;
    let failCount = 0;

    // 각 사용자에 대해 권한 업데이트 수행
    for (const update of adminUpdates) {
      try {
        console.log(`🔄 ${update.action === 'add' ? 'Adding' : 'Removing'} admin permission for: ${update.email}`);
        
        const result = await User.findOneAndUpdate(
          { email: update.email },
          { isAdmin: update.isAdmin },
          { new: true }
        );

        if (result) {
          successCount++;
          const actionText = update.action === 'add' ? 'granted' : 'removed';
          console.log(`✅ Admin permission ${actionText} for ${result.email}`);
          console.log(`   📧 Email: ${result.email}`);
          console.log(`   👤 Name: ${result.nameKr}${result.nameEn ? ` (${result.nameEn})` : ''}`);
          console.log(`   🏢 Part: ${result.part}`);
          console.log(`   👑 Admin: ${result.isAdmin}`);
          console.log(`   🆔 AR ID: ${result.arId}\n`);
        } else {
          failCount++;
          console.log(`❌ User not found: ${update.email}\n`);
        }
      } catch (error) {
        failCount++;
        console.error(`💥 Error updating ${update.email}:`, error);
        console.log('');
      }
    }

    // 결과 요약
    console.log('📊 Update Summary:');
    console.log(`✅ Successfully updated: ${successCount} users`);
    console.log(`❌ Failed updates: ${failCount} users`);
    
    if (failCount === 0) {
      console.log('\n🎉 All admin permission updates completed successfully!');
      process.exit(0);
    } else {
      console.log('\n⚠️  Some updates failed. Please check the logs above.');
      process.exit(1);
    }

  } catch (error) {
    console.error('💥 Error during admin permission updates:', error);
    process.exit(1);
  }
};

// 스크립트 실행
if (require.main === module) {
  updateAdminPermissions();
}

export { updateAdminPermissions };
</file>

<file path="src/utils/paletteImageProcessor.ts">
// import sharp from 'sharp'; // Temporarily commented out due to platform issues
import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';

export class PaletteImageProcessor {
  private static PALETTE_SIZE = 128;
  private static PALETTE_UPLOAD_DIR = 'uploads/palettes';

  static async ensurePaletteDirectoryExists(): Promise<void> {
    try {
      await fs.access(this.PALETTE_UPLOAD_DIR);
    } catch {
      await fs.mkdir(this.PALETTE_UPLOAD_DIR, { recursive: true });
    }
  }

  static async processPaletteImage(inputPath: string, originalFilename?: string): Promise<{ paletteImageUrl: string, filename: string }> {
    // inputPath가 undefined인 경우 처리
    if (!inputPath) {
      throw new Error('Input path is required for palette image processing');
    }

    await this.ensurePaletteDirectoryExists();

    const fileExtension = path.extname(originalFilename || inputPath) || '.jpg';
    const filename = `palette_${uuidv4()}${fileExtension}`;
    const outputPath = path.join(this.PALETTE_UPLOAD_DIR, filename);

    try {
      // TEMPORARY WORKAROUND: Just copy the file for now until Sharp is fixed
      await fs.copyFile(inputPath, outputPath);
      
      console.log('⚠️  NOTICE: Using temporary palette image processing (Sharp not available)');

      // 원본 파일 삭제 (임시 업로드 파일인 경우)
      if (inputPath.includes('uploads/') && !inputPath.includes('palettes/')) {
        try {
          await fs.unlink(inputPath);
        } catch (error) {
          console.warn('Failed to delete temporary file:', inputPath);
        }
      }

      return {
        paletteImageUrl: `/${this.PALETTE_UPLOAD_DIR}/${filename}`,
        filename
      };
    } catch (error) {
      console.error('Error processing palette image:', error);
      throw new Error('Failed to process palette image');
    }
  }

  static async deletePaletteImage(paletteImageUrl: string): Promise<void> {
    if (!paletteImageUrl) return;

    try {
      const filename = path.basename(paletteImageUrl);
      const filePath = path.join(this.PALETTE_UPLOAD_DIR, filename);
      
      // 파일 존재 여부 확인
      try {
        await fs.access(filePath);
        await fs.unlink(filePath);
        console.log(`Palette image deleted: ${filePath}`);
      } catch (accessError: any) {
        if (accessError.code === 'ENOENT') {
          console.log(`Palette image already deleted or not found: ${filePath}`);
        } else {
          throw accessError;
        }
      }
    } catch (error) {
      console.warn(`Failed to delete palette image: ${paletteImageUrl}`, error);
    }
  }

  static getFilePathFromUrl(url: string): string {
    if (!url) return '';
    const filename = path.basename(url);
    return path.join(this.PALETTE_UPLOAD_DIR, filename);
  }
}
</file>

<file path="src/utils/thumbnailGenerator.ts">
// import sharp from 'sharp';
import path from 'path';
import fs from 'fs/promises';
import { uploadToFirebase, getBucket } from '../config/firebase-storage';
import { Readable } from 'stream';

export interface ThumbnailResult {
  thumbnailPath: string;
  thumbnailUrl: string;
  source: 'user' | 'auto';
}

export class ThumbnailGenerator {
  private static readonly THUMBNAIL_SIZE = 300;
  private static readonly THUMBNAIL_DIR = 'uploads/thumbnails';

  /**
   * Firebase Storage URL인지 확인
   */
  private static isFirebaseUrl(url: string): boolean {
    return url.startsWith('https://storage.googleapis.com/') || url.startsWith('gs://');
  }

  /**
   * 이미지를 로컬 임시 파일로 다운로드 (Firebase Storage URL인 경우)
   */
  private static async downloadImageToTemp(imageUrl: string): Promise<string> {
    if (!this.isFirebaseUrl(imageUrl)) {
      // 로컬 파일 경로인 경우 절대 경로로 변환
      if (imageUrl.startsWith('/')) {
        // /uploads/... 형태의 경우
        return path.join(process.cwd(), imageUrl.slice(1));
      } else if (path.isAbsolute(imageUrl)) {
        // 이미 절대 경로인 경우 그대로 반환
        return imageUrl;
      } else {
        // 상대 경로인 경우 현재 디렉토리 기준으로 변환
        return path.join(process.cwd(), imageUrl);
      }
    }

    // Firebase Storage에서 다운로드
    const tempFilePath = path.join(process.cwd(), 'temp', `temp_${Date.now()}_${Math.random()}.jpg`);
    
    try {
      // temp 디렉토리 생성
      await fs.mkdir(path.dirname(tempFilePath), { recursive: true });
      
      // Firebase Storage URL에서 파일 경로 추출 (개선된 파싱)
      const url = new URL(imageUrl);
      let filePath = '';
      
      // 다양한 Firebase Storage URL 형식 지원
      if (url.hostname.includes('firebasestorage.app') || url.hostname.includes('googleapis.com')) {
        // 새로운 형식: https://storage.googleapis.com/bucket-name/uploads/filename
        if (url.pathname.includes('/o/')) {
          filePath = decodeURIComponent(url.pathname.split('/o/')[1]?.split('?')[0] || '');
        } else {
          // 직접 경로 형식: https://storage.googleapis.com/bucket-name/uploads/filename
          const pathParts = url.pathname.split('/');
          if (pathParts.length >= 3) {
            filePath = pathParts.slice(2).join('/'); // bucket-name 이후의 경로
          }
        }
      }
      
      if (!filePath) {
        console.error('❌ Firebase Storage URL 파싱 실패:', imageUrl);
        console.error('URL 구조:', { hostname: url.hostname, pathname: url.pathname });
        throw new Error('Invalid Firebase Storage URL format');
      }
      
      console.log('✅ 파싱된 Firebase 파일 경로:', filePath);

      const bucket = getBucket();
      const file = bucket.file(filePath);
      
      // 파일 다운로드
      const [fileBuffer] = await file.download();
      await fs.writeFile(tempFilePath, fileBuffer);
      
      return tempFilePath;
    } catch (error) {
      console.error('Error downloading image from Firebase:', error);
      throw new Error(`Failed to download image: ${error}`);
    }
  }

  /**
   * 썸네일 이미지를 Firebase Storage에 업로드
   */
  private static async uploadThumbnailToFirebase(localThumbnailPath: string, filename: string): Promise<string> {
    try {
      const thumbnailBuffer = await fs.readFile(localThumbnailPath);
      
      // Express.Multer.File 형태로 변환
      const uploadFile: Express.Multer.File = {
        fieldname: 'thumbnail',
        originalname: filename,
        encoding: '7bit',
        mimetype: 'image/jpeg',
        buffer: thumbnailBuffer,
        size: thumbnailBuffer.length,
        destination: '',
        filename: filename,
        path: localThumbnailPath,
        stream: null as any,
      };

      // Firebase Storage에 업로드
      const result = await uploadToFirebase(uploadFile, 'uploads/thumbnails/');
      
      // 임시 파일 삭제
      try {
        await fs.unlink(localThumbnailPath);
      } catch (error) {
        console.warn('Failed to delete temporary thumbnail file:', error);
      }
      
      return result.url;
    } catch (error) {
      console.error('Error uploading thumbnail to Firebase:', error);
      throw new Error(`Failed to upload thumbnail: ${error}`);
    }
  }

  static async ensureThumbnailDir(): Promise<void> {
    try {
      await fs.access(this.THUMBNAIL_DIR);
    } catch {
      await fs.mkdir(this.THUMBNAIL_DIR, { recursive: true });
    }
  }

  /**
   * 원본 이미지에서 썸네일을 자동 생성합니다
   */
  static async generateThumbnail(
    originalImagePath: string,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    // originalImagePath가 undefined인 경우 방어
    if (!originalImagePath) {
      throw new Error('Original image path is required for thumbnail generation');
    }
    
    const originalName = filename || path.basename(originalImagePath, path.extname(originalImagePath));
    const thumbnailFilename = `thumb_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    let tempImagePath: string | null = null;

    try {
      console.log(`🔍 썸네일 생성 시도:`, { originalImagePath, thumbnailFilename });
      
      // 이미지 다운로드 (Firebase Storage URL인 경우)
      const localImagePath = await this.downloadImageToTemp(originalImagePath);
      if (this.isFirebaseUrl(originalImagePath)) {
        tempImagePath = localImagePath; // 임시 파일이므로 나중에 삭제
      }
      
      // 원본 파일 존재 확인
      try {
        await fs.access(localImagePath);
      } catch (error) {
        throw new Error(`Original image not found: ${localImagePath}`);
      }
      
      // Temporary: 원본 파일을 복사해서 썸네일로 사용 (Sharp 없이)
      await fs.copyFile(localImagePath, localThumbnailPath);
      console.log(`✅ 로컬 썸네일 생성 완료:`, localThumbnailPath);
      
      // Firebase Storage에 업로드
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`✅ Firebase 썸네일 업로드 완료:`, firebaseUrl);
      
      // 임시 이미지 파일 삭제
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch (error) {
          console.warn('Failed to delete temporary image file:', error);
        }
      }
      
      return {
        thumbnailPath: localThumbnailPath, // 로컬 경로 (호환성 유지)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'auto'
      };
    } catch (error) {
      console.error(`❌ 썸네일 생성 실패:`, error);
      
      // 임시 파일들 정리
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch {}
      }
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to generate thumbnail: ${error}`);
    }
  }

  /**
   * 스프라이트 이미지의 첫 번째 프레임에서 썸네일을 생성합니다
   */
  static async generateThumbnailFromSprite(
    spriteImagePath: string,
    columns: number = 16,
    rows?: number,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    // spriteImagePath가 undefined인 경우 방어
    if (!spriteImagePath) {
      throw new Error('Sprite image path is required for thumbnail generation');
    }

    const originalName = filename || path.basename(spriteImagePath, path.extname(spriteImagePath));
    const thumbnailFilename = `thumb_sprite_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    let tempImagePath: string | null = null;

    try {
      console.log(`🔍 스프라이트 썸네일 생성 시도:`, { spriteImagePath, thumbnailFilename });
      
      // 이미지 다운로드 (Firebase Storage URL인 경우)
      const localImagePath = await this.downloadImageToTemp(spriteImagePath);
      if (this.isFirebaseUrl(spriteImagePath)) {
        tempImagePath = localImagePath; // 임시 파일이므로 나중에 삭제
      }

      // 스프라이트 이미지 정보 가져오기
      // const { width, height } = await sharp(localImagePath).metadata();
      const width = 800, height = 600; // Temporary values
      
      if (!width || !height) {
        throw new Error('Cannot get sprite image dimensions');
      }

      // 첫 번째 프레임 크기 계산
      const frameWidth = Math.floor(width / columns);
      let frameHeight: number;
      
      if (rows) {
        // 행 수가 지정된 경우
        frameHeight = Math.floor(height / rows);
      } else {
        // 행 수가 지정되지 않은 경우, 정사각형 프레임이라고 가정
        frameHeight = frameWidth;
      }

      console.log(`Sprite info: ${width}x${height}, columns: ${columns}, rows: ${rows || 'auto'}`);
      console.log(`Frame size: ${frameWidth}x${frameHeight}`);

      // Temporary: 원본 파일을 복사해서 썸네일로 사용 (Sharp 없이)
      // 실제로는 Sharp를 사용해서 첫 번째 프레임만 추출해야 함
      await fs.copyFile(localImagePath, localThumbnailPath);
      console.log(`✅ 로컬 스프라이트 썸네일 생성 완료:`, localThumbnailPath);

      // Firebase Storage에 업로드
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`✅ Firebase 스프라이트 썸네일 업로드 완료:`, firebaseUrl);

      // 임시 이미지 파일 삭제
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch (error) {
          console.warn('Failed to delete temporary sprite image file:', error);
        }
      }

      return {
        thumbnailPath: localThumbnailPath, // 로컬 경로 (호환성 유지)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'auto'
      };
    } catch (error) {
      console.error(`❌ 스프라이트 썸네일 생성 실패:`, error);
      
      // 임시 파일들 정리
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch {}
      }
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to generate thumbnail from sprite: ${error}`);
    }
  }

  /**
   * 사용자가 업로드한 썸네일 이미지를 처리합니다
   */
  static async processUserThumbnail(
    thumbnailImagePath: string,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    const originalName = filename || path.basename(thumbnailImagePath, path.extname(thumbnailImagePath));
    const thumbnailFilename = `thumb_user_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    try {
      console.log(`🔍 사용자 썸네일 처리 시도:`, { thumbnailImagePath, thumbnailFilename });
      
      // 원본 파일 존재 확인
      try {
        await fs.access(thumbnailImagePath);
      } catch (error) {
        throw new Error(`Thumbnail image not found: ${thumbnailImagePath}`);
      }

      // Temporary: 원본 파일을 복사해서 썸네일로 사용 (Sharp 없이)
      // 실제로는 Sharp를 사용해서 300x300으로 리사이징해야 함
      await fs.copyFile(thumbnailImagePath, localThumbnailPath);
      console.log(`✅ 로컬 사용자 썸네일 생성 완료:`, localThumbnailPath);

      // Firebase Storage에 업로드
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`✅ Firebase 사용자 썸네일 업로드 완료:`, firebaseUrl);

      return {
        thumbnailPath: localThumbnailPath, // 로컬 경로 (호환성 유지)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'user'
      };
    } catch (error) {
      console.error(`❌ 사용자 썸네일 처리 실패:`, error);
      
      // 임시 파일 정리
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to process user thumbnail: ${error}`);
    }
  }

  /**
   * 썸네일 파일을 삭제합니다
   */
  static async deleteThumbnail(thumbnailPath: string): Promise<void> {
    try {
      await fs.unlink(thumbnailPath);
    } catch (error) {
      console.warn(`Failed to delete thumbnail: ${thumbnailPath}`, error);
    }
  }

  /**
   * 이미지 파일이 유효한지 검증합니다
   */
  static async validateImage(imagePath: string): Promise<boolean> {
    try {
      // Temporary: Skip sharp validation
      // const metadata = await sharp(imagePath).metadata();
      // return !!(metadata.width && metadata.height);
      return true; // Always return true for development
    } catch {
      return false;
    }
  }

  /**
   * 썸네일 크기가 올바른지 검증합니다
   */
  static async validateThumbnailSize(imagePath: string): Promise<boolean> {
    try {
      // Temporary: Skip sharp validation
      // const { width, height } = await sharp(imagePath).metadata();
      // return width === this.THUMBNAIL_SIZE && height === this.THUMBNAIL_SIZE;
      return true; // Always return true for development
    } catch {
      return false;
    }
  }
}
</file>

<file path="src/index.ts">
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { connectDB } from './config/database';
import { corsOptions } from './config/cors';
import { setupSwagger } from './config/swagger';
import path from 'path';
import https from 'https';
import fs from 'fs';
import os from 'os';

import userRoutes from './routes/userRoutes';
import avatarRoutes from './routes/avatarRoutes';
import itemRoutes from './routes/itemRoutes';
import charactersRoutes from './routes/charactersRoutes';
import adminRoutes from './routes/adminRoutes';
import adminAvatarRoutes from './routes/adminAvatarRoutes';
import adminItemRoutes from './routes/adminItemRoutes';
import authRoutes from './routes/authRoutes';
import firebaseAuthRoutes from './routes/firebaseAuthRoutes';

// 환경에 따라 다른 env 파일 로딩
if (process.env.NODE_ENV === 'production') {
  dotenv.config(); // 배포 환경에서는 기본 .env 사용
} else {
  dotenv.config({ path: '.env.local' }); // 개발 환경에서는 .env.local 사용
}

const app = express();
const PORT = parseInt(process.env['PORT'] || '3000', 10);
const HTTPS_PORT = parseInt(process.env['HTTPS_PORT'] || '3443', 10);
const HOST = process.env['HOST'] || '0.0.0.0';
const ENABLE_HTTPS = process.env['ENABLE_HTTPS'] === 'true' && process.env.NODE_ENV !== 'production';

// 로컬 IP 주소 찾기
function getLocalIpAddress(): string {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const networkInterface of interfaces[name]!) {
      const { address, family, internal } = networkInterface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use('/uploads', express.static('uploads'));
app.use('/uploads/thumbnails', express.static('uploads/thumbnails'));
app.use('/uploads/palettes', express.static('uploads/palettes'));

// 정적 파일 서빙 (테스트 페이지용)
app.use('/public', express.static('public'));

// 테스트 페이지 직접 접근 라우트
app.get('/test/avatar', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/avatar_new.html'));
});


app.get('/test/item', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/item.html'));
});

app.get('/test/user', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/user.html'));
});

app.get('/test/login', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/login.html'));
});

app.get('/test/customize', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/customize.html'));
});

app.get('/test/cors-test', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/cors-test.html'));
});

app.get('/test/customize/', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/customize.html'));
});

connectDB();

setupSwagger(app);

// 단순 이미지 업로드 엔드포인트 (Firebase Storage 사용)
import { upload, uploadToFirebaseStorage } from './middleware/upload';
app.post('/api/upload', upload.single('file'), async (req, res): Promise<void> => {
  if (!req.file) {
    res.status(400).json({ message: 'No file uploaded' });
    return;
  }
  
  try {
    const result = await uploadToFirebaseStorage(req.file, 'uploads/');
    res.json({ 
      url: result.url,
      filename: result.path 
    });
  } catch (error) {
    console.error('Upload failed:', error);
    res.status(500).json({ message: 'Upload failed', error: (error as Error).message });
  }
});

// Health 체크 엔드포인트 (CloudType용)
app.get(['/health', '/api/health', '/health2'], (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString(),
    server: 'AR Namecard API',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    cors: 'enabled',
    origin: req.headers.origin || 'no-origin',
    mongodb: 'connected',
    firebase: 'configured'
  });
});

app.use('/api/auth', authRoutes);
app.use('/api/auth/firebase', firebaseAuthRoutes);
app.use('/api/users', userRoutes);
app.use('/api/avatars', avatarRoutes);
app.use('/api/stickers', itemRoutes);
app.use('/api/characters', charactersRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/admin/characters', adminAvatarRoutes);
app.use('/api/admin/stickers', adminItemRoutes);

// 루트 경로 접근 시 API 정보 제공
app.get('/', (_req, res) => {
  res.json({
    message: 'AR Namecard API Server',
    version: '1.0.0',
    status: 'running',
    endpoints: {
      health: '/health',
      api: {
        auth: '/api/auth',
        users: '/api/users',
        avatars: '/api/avatars',
        stickers: '/api/stickers',
        characters: '/api/characters',
        admin: '/api/admin'
      },
      test: {
        avatar: '/test/avatar',
        item: '/test/item',
        user: '/test/user',
        login: '/test/login',
        customize: '/test/customize'
      },
      docs: '/api-docs'
    }
  });
});

app.use('*', (_req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// HTTP 서버 시작
app.listen(PORT, HOST, () => {
  const localIp = getLocalIpAddress();
  console.log(`🚀 HTTP Server is running on:`);
  console.log(`   - Local:    http://localhost:${PORT}`);
  console.log(`   - Network:  http://${localIp}:${PORT}`);
  
  if (ENABLE_HTTPS) {
    console.log(`   - HTTPS:    https://localhost:${HTTPS_PORT}`);
    console.log(`   - Network:  https://${localIp}:${HTTPS_PORT}`);
  }
});

// HTTPS 서버 시작 (활성화된 경우)
if (ENABLE_HTTPS) {
  const keyPath = process.env['SSL_KEY_PATH'] || './ssl/server.key';
  const certPath = process.env['SSL_CERT_PATH'] || './ssl/server.crt';
  
  try {
    const privateKey = fs.readFileSync(keyPath, 'utf8');
    const certificate = fs.readFileSync(certPath, 'utf8');
    
    const httpsServer = https.createServer({
      key: privateKey,
      cert: certificate
    }, app);
    
    httpsServer.listen(HTTPS_PORT, HOST, () => {
      console.log(`🔐 HTTPS Server is running on port ${HTTPS_PORT}`);
      console.log(`📱 8th Wall 접근 가능!`);
    });
  } catch (error) {
    console.error('❌ HTTPS 서버 시작 실패:', error);
    console.log('💡 SSL 인증서 생성: node scripts/generate-ssl-cert.js');
  }
}
</file>

<file path="ssl/server.crt">
-----BEGIN CERTIFICATE-----
MIIEjzCCAvegAwIBAgIRAL2IEOQlKBqv+/I+vjie5kQwDQYJKoZIhvcNAQELBQAw
gaExHjAcBgNVBAoTFW1rY2VydCBkZXZlbG9wbWVudCBDQTE7MDkGA1UECwwyamFu
Z2Jlb21zZW9rQEphbmctTWFjQm9va1Byby5sb2NhbCAoSmFuZyBCZW9tc2Vvaykx
QjBABgNVBAMMOW1rY2VydCBqYW5nYmVvbXNlb2tASmFuZy1NYWNCb29rUHJvLmxv
Y2FsIChKYW5nIEJlb21zZW9rKTAeFw0yNTA3MTgxMDQxNTVaFw0yNzEwMTgxMDQx
NTRaMGYxJzAlBgNVBAoTHm1rY2VydCBkZXZlbG9wbWVudCBjZXJ0aWZpY2F0ZTE7
MDkGA1UECwwyamFuZ2Jlb21zZW9rQEphbmctTWFjQm9va1Byby5sb2NhbCAoSmFu
ZyBCZW9tc2VvaykwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCy3O6t
VZMS3eBURm9iLvpY5Q+qq2c39o3bPGkwBQRT3SemoUdrUprZ3J+QVfGBi1OIFNvN
bXBMzh3i9FwAEve+vrNhuwlHh/vBaNutEEerrJ7UAp4h0QvMMsJzz1W/KT/LWBeo
ZqUVZcWF//BPqBSLDEt1V7R3DwFoQW/SgWk2oFzrwO1M+xqJJQBCVEIp4mk7+u5l
skYO9TsOlLMTNFoYuLbSnrDWKk0sqIgtHqV0ipngRZnp8cOK0R14kWFSUoyT9sY8
tKYvI9NHPp+q0ZDqb8+shNZcaSjad3DYmjS9Of0Y+GyKjDRojeiLnaLmOq3q+svf
MzC19p1msopqpa4tAgMBAAGjfDB6MA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAK
BggrBgEFBQcDATAfBgNVHSMEGDAWgBQKmNpkox2gG1RnWq2Xk0JpDdGlZzAyBgNV
HREEKzApgglsb2NhbGhvc3SHBH8AAAGHEAAAAAAAAAAAAAAAAAAAAAGHBMCoAhQw
DQYJKoZIhvcNAQELBQADggGBAAZHvURQqV5KxP+05Liq0MshitsizOK2gKH1AjfZ
egnPyPIajfd6AsuoMS83RsN/ikzyDvm6ZMHKz3STy8xM7iLztLFxjgPh52dFdheG
IluFn8E5BZabr8hd3pQnJQ/41WUrvvoSwN2tYbUa7B5CKzkjZ36BCGUvv0zmPhpG
eTQy2LW4/wldn0ctobYPXilnpvUDD5FG3APY+nH3qYUltmZrRMud8c91hBr0NEF0
tiYj/rIxn8oBU6pnKc5DPlTKbSaG5erUsR3Ayv2CqC1691iFqtz3AMBuDfiZJqvN
OmK5Fz5Ubh/8z3Ry3EF4k4FffbxpgacZKLWzBe95cdLXpp+Yo6ZG97l9f/CdlpZz
z/rEbPtr9oz9BDtjCnPNpffWbK/ZGOUNz2EApVLSPyqlgs2ae6nQbTXR4vCPL03z
eEfVsRKLbFAI47Eu3XynjjOqftD48s93NbUQWWkbVrImuwwID94hCQvw0TSPKPhN
F2VLo1i7dAOL/+1RZ8als/Y8wg==
-----END CERTIFICATE-----
</file>

<file path="ssl/server.crt.backup">
-----BEGIN CERTIFICATE-----
MIIDyjCCArKgAwIBAgIUVUcGe5bFx0iUQLk4fNbSzH03ov0wDQYJKoZIhvcNAQEL
BQAwWzELMAkGA1UEBhMCS1IxDjAMBgNVBAgMBVNlb3VsMQ4wDAYDVQQHDAVTZW91
bDEYMBYGA1UECgwPQVIgTmFtZWNhcmQgRGV2MRIwEAYDVQQDDAlsb2NhbGhvc3Qw
HhcNMjUwNzE4MDkxNjUxWhcNMjYwNzE4MDkxNjUxWjBbMQswCQYDVQQGEwJLUjEO
MAwGA1UECAwFU2VvdWwxDjAMBgNVBAcMBVNlb3VsMRgwFgYDVQQKDA9BUiBOYW1l
Y2FyZCBEZXYxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAJltBd0DPtIXYsdph1akEQVU7z8gaO1S5MnWcLsfyVZUfz9Z
ivrP3zMoeSkwfg+SaTlPTqyoGh5sn8ds9ut+jFVB8NMD7Dhb0tKInaO5UetuxEFC
wKyaAXiwImeZJThhF0LMil0aGgiry0FnKovCPg84x21C/em5nnfO2dkA8d/2VDZ4
bgAm8iWCDLTZnkBQNywl6dCS/SJycrNFWHCCM1caRIB+hqXfQxHTdiNdZmU/hVG1
NwHbT/eOUuQBiwBfU81hZbfnkOg5+IFTdEhTvsVv5iJ0kZvsjMzW3/vv9g5SI8d4
ZLtsx8143DXWtKCx9ummKO6lvA/gAVadpL5jND8CAwEAAaOBhTCBgjALBgNVHQ8E
BAMCBDAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwPwYDVR0RBDgwNoIJbG9jYWxob3N0
ggsqLmxvY2FsaG9zdIcEfwAAAYcQAAAAAAAAAAAAAAAAAAAAAYcEwKgCFDAdBgNV
HQ4EFgQUgCJFBAvGvVtuAkHyDzYcUpgwoM4wDQYJKoZIhvcNAQELBQADggEBAGD2
cMVnEs1skKQ3HrLUY4kJsK7W3i8n59ISDMApc30q6QyJmKwrV6fRJTfsQ62qkhqG
JPO8xIILk+7MuMFfuCsSBe010VvnNCtFJWWnk34zwnMuUjOiSgTCtBdhYzGWWaUO
K9ezc7THZoWLJxgHpLL9r+8PFJs7/2HBZziAT04eDs9LfDoKioveRxZ6fok+u0hh
ygL9yP9T/Gpzv6JgLNSF5PPW/7OmDy/rsUSCvCRyh/WxWEnhb6r9yrmPWb/7uEfA
6q5zkmIHc7LYxB8H225reR/zdBXnVHQ6R9/3a/CTEK6uhtnAAcwlMMPrVQPoInoc
w+wdK6tpHVk6OVFWoa0=
-----END CERTIFICATE-----
</file>

<file path=".gitignore">
*.json
**/*-firebase-adminsdk-*.json
*firebase-adminsdk*.json
**/*-firebase-adminsdk-*.json
</file>

<file path="backup.sh">
#!/bin/bash

# ==============================================
# AR Namecard API - Backup Script for Synology NAS
# ==============================================

set -e

# Configuration
NAS_IP="192.168.1.93"
NAS_USER="admin"
NAS_BASE_PATH="/volume1/docker/ar-namecard"
BACKUP_BASE="/volume1/docker/ar-namecard/backups"
SERVICE_NAME="ar-namecard"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Backup MongoDB data
backup_mongodb() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/mongodb/$timestamp"
    
    log "Backing up MongoDB data..."
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $NAS_BASE_PATH/app
        
        # Create backup directory
        mkdir -p $backup_dir
        
        # Get MongoDB connection details from environment
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Create MongoDB dump
        docker-compose exec -T mongodb mongodump \
            --host localhost:27017 \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --db \$MONGO_DB_NAME \
            --out /tmp/backup
        
        # Copy backup from container to host
        docker cp ar-namecard-mongodb:/tmp/backup/$MONGO_DB_NAME $backup_dir/
        
        # Compress backup
        cd $BACKUP_BASE/mongodb
        tar -czf ${timestamp}_mongodb.tar.gz $timestamp/
        rm -rf $timestamp/
        
        echo 'MongoDB backup completed: ${timestamp}_mongodb.tar.gz'
    "
    
    success "MongoDB backup completed."
}

# Backup uploaded files
backup_uploads() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/uploads"
    
    log "Backing up uploaded files..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH
        
        if [ -d uploads ] && [ \"\$(ls -A uploads 2>/dev/null)\" ]; then
            tar -czf $backup_dir/${timestamp}_uploads.tar.gz uploads/
            echo 'Uploads backup completed: ${timestamp}_uploads.tar.gz'
        else
            echo 'No files to backup in uploads directory.'
        fi
    "
    
    success "Uploads backup completed."
}

# Backup configuration files
backup_config() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/config"
    
    log "Backing up configuration files..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH/app
        
        # Backup configuration files
        tar -czf $backup_dir/${timestamp}_config.tar.gz \
            .env \
            docker-compose.yml \
            nas.env \
            firebase-service-account.json 2>/dev/null || \
        tar -czf $backup_dir/${timestamp}_config.tar.gz \
            .env \
            docker-compose.yml \
            nas.env
        
        echo 'Configuration backup completed: ${timestamp}_config.tar.gz'
    "
    
    success "Configuration backup completed."
}

# Backup SSL certificates
backup_ssl() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/ssl"
    
    log "Backing up SSL certificates..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH
        
        if [ -d ssl ] && [ -f ssl/server.crt ] && [ -f ssl/server.key ]; then
            tar -czf $backup_dir/${timestamp}_ssl.tar.gz ssl/
            echo 'SSL backup completed: ${timestamp}_ssl.tar.gz'
        else
            echo 'No SSL certificates to backup.'
        fi
    "
    
    success "SSL backup completed."
}

# Create full backup
full_backup() {
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    
    log "Starting full backup with timestamp: $timestamp"
    
    # Create backup directories
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $BACKUP_BASE/{mongodb,uploads,config,ssl,logs}
    "
    
    # Perform backups
    backup_mongodb "$timestamp"
    backup_uploads "$timestamp"
    backup_config "$timestamp"
    backup_ssl "$timestamp"
    
    # Create backup manifest
    ssh "$NAS_USER@$NAS_IP" "
        cat > $BACKUP_BASE/backup_${timestamp}.manifest << EOF
AR Namecard Backup Manifest
Timestamp: $timestamp
Date: \$(date)
NAS: $NAS_IP

Backup Contents:
- MongoDB: ${timestamp}_mongodb.tar.gz
- Uploads: ${timestamp}_uploads.tar.gz
- Config:  ${timestamp}_config.tar.gz
- SSL:     ${timestamp}_ssl.tar.gz

Backup Sizes:
\$(du -h $BACKUP_BASE/*/${timestamp}_*.tar.gz 2>/dev/null || echo 'No backup files found')

Total Backup Size: \$(du -sh $BACKUP_BASE | cut -f1)
EOF
    "
    
    success "Full backup completed with timestamp: $timestamp"
}

# Restore MongoDB data
restore_mongodb() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Restoring MongoDB from backup: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $NAS_BASE_PATH/app
        
        if [ ! -f $BACKUP_BASE/mongodb/${backup_file}_mongodb.tar.gz ]; then
            echo 'Backup file not found: ${backup_file}_mongodb.tar.gz'
            exit 1
        fi
        
        # Extract backup
        cd /tmp
        tar -xzf $BACKUP_BASE/mongodb/${backup_file}_mongodb.tar.gz
        
        # Get environment variables
        cd $NAS_BASE_PATH/app
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Stop API service temporarily
        docker-compose stop api
        
        # Drop existing database
        docker-compose exec -T mongodb mongosh \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --eval \"use \$MONGO_DB_NAME; db.dropDatabase();\"
        
        # Copy backup to container
        docker cp /tmp/$backup_file/ ar-namecard-mongodb:/tmp/restore/
        
        # Restore database
        docker-compose exec -T mongodb mongorestore \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --db \$MONGO_DB_NAME \
            /tmp/restore/
        
        # Restart API service
        docker-compose start api
        
        # Cleanup
        rm -rf /tmp/$backup_file/
        
        echo 'MongoDB restore completed.'
    "
    
    success "MongoDB restore completed."
}

# Restore uploaded files
restore_uploads() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Restoring uploads from backup: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ ! -f $BACKUP_BASE/uploads/${backup_file}_uploads.tar.gz ]; then
            echo 'Backup file not found: ${backup_file}_uploads.tar.gz'
            exit 1
        fi
        
        cd $NAS_BASE_PATH
        
        # Backup current uploads
        if [ -d uploads ]; then
            mv uploads uploads_backup_\$(date +%Y%m%d_%H%M%S)
        fi
        
        # Restore uploads
        tar -xzf $BACKUP_BASE/uploads/${backup_file}_uploads.tar.gz
        
        echo 'Uploads restore completed.'
    "
    
    success "Uploads restore completed."
}

# List available backups
list_backups() {
    log "Available backups:"
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ -d $BACKUP_BASE ]; then
            echo ''
            echo 'Backup Files:'
            find $BACKUP_BASE -name '*.tar.gz' -exec basename {} \; | sort -r | head -20
            
            echo ''
            echo 'Backup Manifests:'
            find $BACKUP_BASE -name '*.manifest' -exec basename {} \; | sort -r | head -10
            
            echo ''
            echo 'Backup Directory Size:'
            du -sh $BACKUP_BASE
        else
            echo 'No backup directory found.'
        fi
    "
}

# Cleanup old backups
cleanup_backups() {
    local retention_days="${1:-30}"
    
    log "Cleaning up backups older than $retention_days days..."
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ -d $BACKUP_BASE ]; then
            # Remove backup files older than retention period
            find $BACKUP_BASE -name '*.tar.gz' -type f -mtime +$retention_days -delete
            find $BACKUP_BASE -name '*.manifest' -type f -mtime +$retention_days -delete
            
            # Remove empty directories
            find $BACKUP_BASE -type d -empty -delete
            
            echo 'Backup cleanup completed.'
            echo 'Remaining backup size: \$(du -sh $BACKUP_BASE | cut -f1)'
        else
            echo 'No backup directory found.'
        fi
    "
    
    success "Backup cleanup completed."
}

# Verify backup integrity
verify_backup() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Verifying backup integrity: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $BACKUP_BASE
        
        echo 'Checking backup files...'
        
        # Check MongoDB backup
        if [ -f mongodb/${backup_file}_mongodb.tar.gz ]; then
            echo '✓ MongoDB backup exists'
            if tar -tzf mongodb/${backup_file}_mongodb.tar.gz >/dev/null 2>&1; then
                echo '✓ MongoDB backup is valid'
            else
                echo '✗ MongoDB backup is corrupted'
            fi
        else
            echo '✗ MongoDB backup missing'
        fi
        
        # Check uploads backup
        if [ -f uploads/${backup_file}_uploads.tar.gz ]; then
            echo '✓ Uploads backup exists'
            if tar -tzf uploads/${backup_file}_uploads.tar.gz >/dev/null 2>&1; then
                echo '✓ Uploads backup is valid'
            else
                echo '✗ Uploads backup is corrupted'
            fi
        else
            echo '- Uploads backup not found (may be empty)'
        fi
        
        # Check config backup
        if [ -f config/${backup_file}_config.tar.gz ]; then
            echo '✓ Config backup exists'
            if tar -tzf config/${backup_file}_config.tar.gz >/dev/null 2>&1; then
                echo '✓ Config backup is valid'
            else
                echo '✗ Config backup is corrupted'
            fi
        else
            echo '✗ Config backup missing'
        fi
        
        # Check SSL backup
        if [ -f ssl/${backup_file}_ssl.tar.gz ]; then
            echo '✓ SSL backup exists'
            if tar -tzf ssl/${backup_file}_ssl.tar.gz >/dev/null 2>&1; then
                echo '✓ SSL backup is valid'
            else
                echo '✗ SSL backup is corrupted'
            fi
        else
            echo '- SSL backup not found (may not exist)'
        fi
        
        # Check manifest
        if [ -f backup_${backup_file}.manifest ]; then
            echo '✓ Backup manifest exists'
        else
            echo '✗ Backup manifest missing'
        fi
    "
    
    success "Backup verification completed."
}

# Main function
main() {
    case "${1:-backup}" in
        "backup"|"full")
            full_backup
            ;;
        "restore-db")
            restore_mongodb "$2"
            ;;
        "restore-uploads")
            restore_uploads "$2"
            ;;
        "list")
            list_backups
            ;;
        "cleanup")
            cleanup_backups "$2"
            ;;
        "verify")
            verify_backup "$2"
            ;;
        *)
            echo "Usage: $0 {backup|restore-db|restore-uploads|list|cleanup|verify}"
            echo ""
            echo "Commands:"
            echo "  backup           - Create full backup"
            echo "  restore-db <id>  - Restore MongoDB from backup"
            echo "  restore-uploads <id> - Restore uploads from backup"
            echo "  list             - List available backups"
            echo "  cleanup [days]   - Remove backups older than X days (default: 30)"
            echo "  verify <id>      - Verify backup integrity"
            echo ""
            echo "Examples:"
            echo "  $0 backup"
            echo "  $0 restore-db 20250121_143000"
            echo "  $0 cleanup 7"
            echo "  $0 verify 20250121_143000"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
</file>

<file path="CORS_SETUP.md">
# CORS 설정 가이드

## 개발자 모드에서 다중 디바이스 접근 설정

### 🎯 목적
- 다른 PC/모바일에서 HTTP로 접근 시 CORS 오류 해결
- 개발 환경에서 모든 네트워크 접근 허용
- 8th Wall 및 다양한 개발 도구 지원

### 🚀 빠른 설정

#### 1. 모든 Origin 허용 (개발 모드)
`.env` 파일에 추가:
```bash
CORS_ALLOW_ALL=true
```

#### 2. 서버 재시작
기존 서버 종료 후:
```bash
npm run dev
```

서버 시작 시 다음 메시지 확인:
```
🔓 CORS: 개발자 모드 - 모든 origin 허용
```

### 🌐 지원되는 접근 환경

#### 자동 허용되는 도메인들:

**로컬 개발 환경**
- `http://localhost:3000`
- `http://127.0.0.1:3000`
- `http://0.0.0.0:3000`
- `https://localhost:3443`

**로컬 네트워크**
- `http://192.168.x.x:3000`
- `http://10.x.x.x:3000`
- `http://172.16-31.x.x:3000`
- `http://xxx.local:3000`
- `http://xxx.lan:3000`

**8th Wall 플랫폼**
- `https://*.8thwall.com`
- `https://*.8thwall.app`

**개발자 도구**
- `null` origin (file:// 프로토콜)
- Chrome DevTools
- Postman 등

### ⚙️ 설정 옵션

#### 1. 완전 개방 모드 (권장)
```bash
CORS_ALLOW_ALL=true
```
- 모든 origin에서 접근 가능
- 개발 환경에서만 작동
- 가장 편리한 설정

#### 2. 제한적 모드
```bash
CORS_ALLOW_ALL=false
```
- 사전 정의된 도메인만 허용
- 더 안전한 개발 환경
- 일부 네트워크에서 제한 가능

### 🔧 환경별 설정

#### 개발 환경 (NODE_ENV=development)
- 추가 로컬 호스트 변형 지원
- 더 넓은 네트워크 패턴 허용
- 개발자 도구 친화적

#### 프로덕션 환경 (NODE_ENV=production)
- `CORS_ALLOW_ALL` 무시
- 사전 정의된 도메인만 허용
- 보안 강화

### 🐛 문제 해결

#### 1. 여전히 CORS 오류가 발생하는 경우
```bash
# 서버 로그 확인
🚫 CORS: 차단된 origin - http://192.168.x.x:3000
```

**해결 방법:**
1. `.env` 파일에 `CORS_ALLOW_ALL=true` 확인
2. 서버 재시작
3. 브라우저 캐시 클리어

#### 2. 개발자 도구에서 접근 불가
- Chrome: 개발자 도구 → Network → Disable cache
- 시크릿 모드로 테스트
- 다른 브라우저로 테스트

#### 3. 모바일에서 접근 불가
- 방화벽 설정 확인
- 같은 WiFi 네트워크 연결 확인
- IP 주소 정확성 확인

### 🔒 보안 고려사항

#### 개발 환경에서만 사용
- `CORS_ALLOW_ALL=true`는 개발용
- 프로덕션에서는 자동 무시
- 민감한 데이터 노출 주의

#### 프로덕션 배포 시
```bash
NODE_ENV=production
CORS_ALLOW_ALL=false  # 또는 제거
```

### 📱 테스트 방법

#### 1. 로컬에서 테스트
```bash
curl -H "Origin: http://test.com" http://localhost:3000/api/health
```

#### 2. 다른 PC에서 테스트
브라우저에서 `http://192.168.x.x:3000/api/health` 접속

#### 3. 모바일에서 테스트
모바일 브라우저에서 `http://192.168.x.x:3000/test/customize` 접속

### 🎉 성공 확인

서버 로그에서 다음 메시지 확인:
```
🔓 CORS: 개발자 모드 - 모든 origin 허용
🚀 HTTP Server is running on:
   - Local:    http://localhost:3000
   - Network:  http://192.168.x.x:3000
```

브라우저에서 CORS 오류 없이 API 호출 성공!
</file>

<file path="deploy.sh">
#!/bin/bash

# ==============================================
# AR Namecard API - Synology NAS Deployment Script
# ==============================================

set -e  # Exit on any error

# Configuration
NAS_IP="192.168.1.93"
NAS_USER="admin"
NAS_PASSWORD="hnine0426"
NAS_BASE_PATH="/volume1/docker/ar-namecard"
LOCAL_BUILD_PATH="./build"
SERVICE_NAME="ar-namecard"

# SSH function with password
ssh_nas() {
    expect -c "
        set timeout 30
        spawn ssh -o StrictHostKeyChecking=no $NAS_USER@$NAS_IP \"$1\"
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
}

# SCP function with password
scp_nas() {
    expect -c "
        set timeout 60
        spawn $1
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa ]; then
        warning "SSH key not found. You may need to enter password multiple times."
    fi
    
    # Check if rsync is available
    if ! command -v rsync &> /dev/null; then
        error "rsync is required but not installed."
    fi
    
    # Check if Docker files exist
    if [ ! -f "./Dockerfile" ] || [ ! -f "./docker-compose.yml" ]; then
        error "Docker configuration files not found."
    fi
    
    success "Prerequisites check completed."
}

# Test NAS connection
test_connection() {
    log "Testing connection to NAS..."
    
    result=$(ssh_nas "echo 'connection_test_ok'")
    if echo "$result" | grep -q "connection_test_ok"; then
        success "SSH connection to NAS successful."
    else
        error "Cannot connect to NAS. Please check SSH configuration."
    fi
}

# Create directory structure on NAS
create_directories() {
    log "Creating directory structure on NAS..."
    
    ssh_nas "
        mkdir -p $NAS_BASE_PATH/{app,data/mongodb,data/mongodb-config,uploads,ssl,public,backups,logs}
        chmod -R 755 $NAS_BASE_PATH
    "
    
    success "Directory structure created."
}

# Build application locally
build_application() {
    log "Building application locally..."
    
    # Clean previous build
    rm -rf "$LOCAL_BUILD_PATH"
    mkdir -p "$LOCAL_BUILD_PATH"
    
    # Copy source files to build directory (Docker will handle the build)
    cp -r src package*.json tsconfig.json "$LOCAL_BUILD_PATH/"
    cp Dockerfile docker-compose.yml nas.env "$LOCAL_BUILD_PATH/"
    
    # Copy SSL certificates if they exist
    if [ -d "./ssl" ]; then
        cp -r ssl "$LOCAL_BUILD_PATH/"
    fi
    
    # Copy Firebase service account if it exists
    if [ -f "./firebase-service-account.json" ]; then
        cp firebase-service-account.json "$LOCAL_BUILD_PATH/"
    fi
    
    # Copy any additional files
    if [ -d "./scripts" ]; then
        cp -r scripts "$LOCAL_BUILD_PATH/"
    fi
    
    success "Application files prepared for Docker build."
}

# Transfer files to NAS
transfer_files() {
    log "Transferring files to NAS..."
    
    # Use expect for rsync with password
    expect -c "
        set timeout 300
        spawn rsync -avz --delete --exclude='node_modules/.cache' --exclude='*.log' $LOCAL_BUILD_PATH/ $NAS_USER@$NAS_IP:$NAS_BASE_PATH/app/
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
    
    success "Files transferred successfully."
}

# Setup environment configuration
setup_environment() {
    log "Setting up environment configuration..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Copy nas.env to .env if .env doesn't exist
        if [ ! -f .env ]; then
            cp nas.env .env
            echo 'Environment file created from nas.env template.'
            echo 'Please edit .env file with your actual configuration.'
        fi
        
        # Generate JWT secret if needed
        if grep -q 'your-super-secure-jwt-secret' .env; then
            JWT_SECRET=\$(openssl rand -base64 32)
            sed -i \"s/your-super-secure-jwt-secret-for-production-use-minimum-32-characters/\$JWT_SECRET/g\" .env
            echo 'JWT secret generated automatically.'
        fi
    "
    
    success "Environment configuration completed."
}

# Generate SSL certificates
generate_ssl() {
    log "Generating SSL certificates..."
    
    ssh_nas "
        cd $NAS_BASE_PATH
        
        if [ ! -f ssl/server.crt ] || [ ! -f ssl/server.key ]; then
            openssl req -x509 -newkey rsa:4096 -keyout ssl/server.key -out ssl/server.crt -days 365 -nodes \
                -subj '/C=KR/ST=Seoul/L=Seoul/O=AR-Namecard/CN=$NAS_IP' \
                -addext 'subjectAltName=IP:$NAS_IP,IP:127.0.0.1,DNS:localhost,DNS:ar-namecard.local'
            
            chmod 600 ssl/server.key
            chmod 644 ssl/server.crt
            
            echo 'SSL certificates generated.'
        else
            echo 'SSL certificates already exist.'
        fi
    "
    
    success "SSL certificates ready."
}

# Deploy with Docker Compose
deploy_services() {
    log "Deploying services with Docker Compose..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Load environment variables
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Stop existing services
        docker-compose down --remove-orphans
        
        # Pull latest images
        docker-compose pull
        
        # Build and start services
        docker-compose up -d --build
        
        # Wait for services to start
        sleep 30
        
        # Check service status
        docker-compose ps
    "
    
    success "Services deployed successfully."
}

# Verify deployment
verify_deployment() {
    log "Verifying deployment..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Check if containers are running
        if docker-compose ps | grep -q 'Up'; then
            echo 'Containers are running.'
        else
            echo 'Some containers are not running properly.'
            docker-compose logs --tail=20
            exit 1
        fi
        
        # Test API health endpoint
        sleep 10
        if curl -f http://localhost:3000/api/health &>/dev/null; then
            echo 'API health check passed.'
        else
            echo 'API health check failed.'
            exit 1
        fi
    "
    
    success "Deployment verification completed."
}

# Cleanup local build
cleanup() {
    log "Cleaning up local build files..."
    rm -rf "$LOCAL_BUILD_PATH"
    success "Cleanup completed."
}

# Show deployment information
show_info() {
    log "Deployment completed successfully!"
    echo ""
    echo "📡 Service URLs:"
    echo "   HTTP:  http://$NAS_IP:3000"
    echo "   HTTPS: https://$NAS_IP:3443"
    echo "   API Docs: http://$NAS_IP:3000/api-docs"
    echo ""
    echo "🛠  Management Commands:"
    echo "   Check logs: ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose logs -f'"
    echo "   Restart:    ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose restart'"
    echo "   Stop:       ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose down'"
    echo ""
    echo "⚙️  Configuration:"
    echo "   Edit: ssh $NAS_USER@$NAS_IP 'nano $NAS_BASE_PATH/app/.env'"
    echo ""
}

# Main deployment process
main() {
    echo "🚀 Starting AR Namecard API deployment to Synology NAS..."
    echo ""
    
    check_prerequisites
    test_connection
    create_directories
    build_application
    transfer_files
    setup_environment
    generate_ssl
    deploy_services
    verify_deployment
    cleanup
    show_info
}

# Handle script arguments
case "${1:-deploy}" in
    "deploy")
        main
        ;;
    "logs")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose logs -f"
        ;;
    "restart")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose restart"
        ;;
    "stop")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose down"
        ;;
    "status")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose ps"
        ;;
    "update")
        log "Updating application..."
        build_application
        transfer_files
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose up -d --build"
        cleanup
        success "Application updated successfully."
        ;;
    *)
        echo "Usage: $0 {deploy|logs|restart|stop|status|update}"
        echo ""
        echo "Commands:"
        echo "  deploy  - Full deployment (default)"
        echo "  logs    - Show service logs"
        echo "  restart - Restart services"
        echo "  stop    - Stop services"
        echo "  status  - Show service status"
        echo "  update  - Update application only"
        exit 1
        ;;
esac
</file>

<file path="DEPLOYMENT_CHECKLIST.md">
# ✅ CloudType 배포 후 검증 체크리스트

## 🎯 배포 URL
배포 완료 후 CloudType에서 제공하는 URL을 기록하세요:
```
Base URL: https://port-3000-ar-namecard-api-xxxxx.cloudtype.app
```

## 🔍 Phase 1: 기본 서비스 확인

### 1.1 Health Check 엔드포인트
- [ ] **GET** `/health`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/health
  ```
  **Expected Response:**
  ```json
  {
    "status": "healthy",
    "timestamp": "2024-01-XX...",
    "server": "AR Namecard API",
    "version": "1.0.0",
    "environment": "production",
    "cors": "enabled",
    "mongodb": "connected",
    "firebase": "configured"
  }
  ```

- [ ] **GET** `/api/health`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/health
  ```

### 1.2 Swagger 문서 접근
- [ ] **GET** `/api-docs`
  - 브라우저에서 접근 가능
  - Swagger UI 정상 로드
  - 모든 API 엔드포인트 표시

## 📋 Phase 2: 테스트 페이지 확인

### 2.1 캐릭터 옵션 관리 테스트
- [ ] **GET** `/test/avatar`
  - 페이지 정상 로드
  - 관리자 토큰 생성 버튼 작동
  - 카테고리 목록 로드 가능
  - 옵션 추가/수정/삭제 UI 표시

### 2.2 사용자 관리 테스트
- [ ] **GET** `/test/user`
  - 사용자 목록 표시
  - 검색 기능 작동
  - 사용자 상세 정보 확인

### 2.3 로그인 테스트
- [ ] **GET** `/test/login`
  - 로그인 폼 표시
  - Firebase 인증 설정 확인
  - 로그인 프로세스 테스트

### 2.4 아이템 관리 테스트
- [ ] **GET** `/test/item`
  - 스티커 목록 표시
  - 검색/필터 기능 작동

### 2.5 커스터마이제이션 테스트
- [ ] **GET** `/test/customize`
  - 캐릭터 커스터마이제이션 UI 로드
  - 옵션 선택 기능 작동

## 🔌 Phase 3: API 엔드포인트 검증

### 3.1 Authentication API
- [ ] **GET** `/api/auth/test-token/001`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/auth/test-token/001
  ```
  **Expected:** 관리자 토큰 생성

### 3.2 Characters API
- [ ] **GET** `/api/characters`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/characters
  ```
  **Expected:** 캐릭터 카테고리 목록

### 3.3 Stickers API
- [ ] **GET** `/api/stickers`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/stickers
  ```
  **Expected:** 스티커 목록

### 3.4 Admin API (토큰 필요)
- [ ] **GET** `/api/admin/characters/categories`
  ```bash
  curl -H "Authorization: Bearer [TOKEN]" \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/admin/characters/categories
  ```
  **Expected:** 관리자 전용 카테고리 목록

## 🗄️ Phase 4: MongoDB Atlas 연결 검증

### 4.1 데이터베이스 연결 상태
- [ ] Atlas 대시보드에서 연결 확인
- [ ] Real-time 탭에서 활성 연결 확인
- [ ] Metrics에서 연결 성능 확인

### 4.2 컬렉션 생성 확인
- [ ] `users` 컬렉션 존재
- [ ] `avatarcategories` 컬렉션 존재
- [ ] `usercustomizations` 컬렉션 존재
- [ ] `items` 컬렉션 존재

### 4.3 데이터 CRUD 테스트
- [ ] 사용자 생성 테스트 (회원가입)
- [ ] 데이터 조회 테스트
- [ ] 데이터 수정 테스트
- [ ] 데이터 삭제 테스트

## 🔥 Phase 5: Firebase 연동 검증

### 5.1 Firebase Authentication
- [ ] **POST** `/api/auth/firebase/verify`
  ```bash
  curl -X POST \
       -H "Content-Type: application/json" \
       -d '{"idToken": "TEST_TOKEN"}' \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/auth/firebase/verify
  ```

### 5.2 Firebase 설정 확인
- [ ] 환경변수 FIREBASE_PROJECT_ID 확인
- [ ] FIREBASE_PRIVATE_KEY 정상 설정 확인
- [ ] FIREBASE_CLIENT_EMAIL 정상 설정 확인

## 📁 Phase 6: 파일 업로드 기능 검증

### 6.1 기본 파일 업로드
- [ ] **POST** `/api/upload`
  ```bash
  curl -X POST \
       -F "file=@test-image.jpg" \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/upload
  ```
  **Expected:** 파일 업로드 성공 및 URL 반환

### 6.2 정적 파일 서빙
- [ ] `/uploads/` 경로 접근 가능
- [ ] `/uploads/thumbnails/` 경로 접근 가능
- [ ] `/uploads/palettes/` 경로 접근 가능

### 6.3 관리자 옵션 업로드
- [ ] 캐릭터 옵션 이미지 업로드
- [ ] 썸네일 자동 생성
- [ ] 팔레트 이미지 처리
- [ ] Hair 카테고리 특수 처리 (중간머리/뒷머리)

## 🌐 Phase 7: CORS 및 네트워크 검증

### 7.1 CORS 헤더 확인
- [ ] 프리플라이트 요청 처리
- [ ] Access-Control-Allow-Origin 헤더
- [ ] Access-Control-Allow-Methods 헤더
- [ ] Access-Control-Allow-Headers 헤더

### 7.2 다양한 도메인에서 접근 테스트
- [ ] 브라우저에서 직접 접근
- [ ] 다른 도메인에서 AJAX 요청
- [ ] 모바일 브라우저에서 접근

## 🚨 Phase 8: 오류 처리 검증

### 8.1 404 에러 처리
- [ ] **GET** `/nonexistent-endpoint`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/nonexistent-endpoint
  ```
  **Expected:** `{"error": "Route not found"}`

### 8.2 인증 오류 처리
- [ ] 토큰 없이 관리자 API 호출
- [ ] 잘못된 토큰으로 API 호출
- [ ] 만료된 토큰으로 API 호출

### 8.3 유효성 검사 오류
- [ ] 잘못된 데이터로 POST 요청
- [ ] 필수 필드 누락으로 요청
- [ ] 잘못된 파일 형식으로 업로드

## 📊 Phase 9: 성능 및 모니터링

### 9.1 응답 시간 확인
- [ ] Health Check 응답 시간 < 500ms
- [ ] API 엔드포인트 평균 응답 시간 < 2초
- [ ] 파일 업로드 처리 시간 확인

### 9.2 CloudType 리소스 사용량
- [ ] CPU 사용률 모니터링
- [ ] 메모리 사용량 확인
- [ ] 네트워크 트래픽 확인

### 9.3 로그 모니터링
- [ ] 애플리케이션 로그 정상 출력
- [ ] 오류 로그 수집 확인
- [ ] 접근 로그 기록 확인

## 🔄 Phase 10: 지속적 모니터링

### 10.1 일일 체크
- [ ] 서비스 가용성 확인
- [ ] 오류 로그 검토
- [ ] 성능 지표 확인

### 10.2 주간 체크
- [ ] MongoDB Atlas 용량 확인
- [ ] 보안 업데이트 검토
- [ ] 백업 상태 확인

### 10.3 월간 체크
- [ ] SSL 인증서 만료일 확인
- [ ] 의존성 패키지 업데이트
- [ ] 성능 최적화 검토

## ❌ 문제 해결 가이드

### 연결 문제
1. **MongoDB 연결 실패**
   - Atlas IP 허용 목록 확인
   - 연결 문자열 검증
   - 네트워크 설정 재확인

2. **Firebase 연결 오류**
   - 환경변수 형식 확인
   - Private Key 줄바꿈 문자 확인
   - 프로젝트 ID 일치 여부 확인

3. **CORS 오류**
   - CloudType 도메인 CORS 허용 목록 확인
   - preflight 요청 처리 확인

### 성능 문제
1. **느린 응답**
   - 데이터베이스 인덱스 확인
   - 쿼리 최적화 필요
   - 캐싱 전략 검토

2. **메모리 부족**
   - 이미지 처리 최적화
   - 메모리 누수 검사
   - CloudType 플랜 업그레이드 고려

## ✅ 배포 완료 확인

모든 항목이 체크되면 배포가 성공적으로 완료된 것입니다!

- [ ] **Phase 1-10 모든 항목 완료**
- [ ] **문서화 업데이트 완료**
- [ ] **모니터링 설정 완료**
- [ ] **팀 공유 완료**

---

**배포 완료일**: ___________  
**배포 담당자**: ___________  
**CloudType URL**: ___________  
**MongoDB Atlas Cluster**: ___________
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # MongoDB Database
  mongodb:
    image: mongo:6.0
    container_name: ar-namecard-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD:-admin123}
      MONGO_INITDB_DATABASE: ${MONGO_DB_NAME:-ar_namecard}
    volumes:
      - mongodb_data:/data/db
      - mongodb_config:/data/configdb
      - ./mongodb-init:/docker-entrypoint-initdb.d:ro
    networks:
      - ar-namecard-network
    ports:
      - "127.0.0.1:27017:27017"  # Only accessible from localhost
    command: mongod --auth
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # AR Namecard API Server
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ar-namecard-api
    restart: unless-stopped
    depends_on:
      mongodb:
        condition: service_healthy
    environment:
      # Server Configuration
      NODE_ENV: production
      PORT: 3000
      HTTPS_PORT: 3443
      HOST: 0.0.0.0
      ENABLE_HTTPS: ${ENABLE_HTTPS:-false}
      
      # Database Configuration
      MONGODB_URI: mongodb://${MONGO_ROOT_USERNAME:-admin}:${MONGO_ROOT_PASSWORD:-admin123}@mongodb:27017/${MONGO_DB_NAME:-ar_namecard}?authSource=admin
      
      # JWT Configuration
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRES_IN: ${JWT_EXPIRES_IN:-24h}
      
      # File Upload Configuration
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10485760}
      UPLOAD_DIR: uploads
      
      # CORS Configuration
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      CORS_ALLOW_ALL: ${CORS_ALLOW_ALL:-false}
      
      # SSL Configuration
      SSL_KEY_PATH: ./ssl/server.key
      SSL_CERT_PATH: ./ssl/server.crt
      
      # Firebase Configuration
      FIREBASE_PROJECT_ID: ${FIREBASE_PROJECT_ID}
      FIREBASE_PRIVATE_KEY: ${FIREBASE_PRIVATE_KEY}
      FIREBASE_CLIENT_EMAIL: ${FIREBASE_CLIENT_EMAIL}
    volumes:
      - uploads_data:/app/uploads
      - ssl_certs:/app/ssl
      - public_files:/app/public
      - ./firebase-service-account.json:/app/firebase-service-account.json:ro
    networks:
      - ar-namecard-network
    ports:
      - "${API_HTTP_PORT:-3000}:3000"
      - "${API_HTTPS_PORT:-3443}:3443"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.ar-namecard.rule=Host(`${DOMAIN_NAME:-localhost}`)"
      - "traefik.http.routers.ar-namecard.tls=true"

  # Nginx Reverse Proxy (Optional)
  nginx:
    image: nginx:alpine
    container_name: ar-namecard-nginx
    restart: unless-stopped
    depends_on:
      api:
        condition: service_healthy
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ssl_certs:/etc/nginx/ssl:ro
      - uploads_data:/var/www/uploads:ro
    networks:
      - ar-namecard-network
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    profiles:
      - with-nginx

networks:
  ar-namecard-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  mongodb_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/data/mongodb
  mongodb_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/data/mongodb-config
  uploads_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/uploads
  ssl_certs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/ssl
  public_files:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/public
</file>

<file path="Dockerfile">
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including devDependencies for TypeScript)
RUN npm install

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# Create uploads directory
RUN mkdir -p uploads/thumbnails uploads/palettes

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })" || exit 1

# Start application
CMD ["npm", "start"]
</file>

<file path="HTTPS_SETUP.md">
# HTTPS 설정 가이드

## 8th Wall 및 다중 디바이스 접근을 위한 HTTPS 설정

### 🎯 목적
- 8th Wall WebAR 플랫폼에서 백엔드 API 접근
- 로컬 네트워크의 다른 PC/모바일에서 접근
- Firebase 인증을 포함한 전체 시스템 테스트

### 🚀 빠른 시작

#### 1. SSL 인증서 생성
```bash
npm run ssl:generate
```

#### 2. 환경 변수 설정
`.env` 파일에 다음 추가:
```bash
ENABLE_HTTPS=true
HOST=0.0.0.0
```

#### 3. HTTPS 서버 실행
```bash
npm run https
```

### 🌐 접근 URL

#### 로컬 접근
- HTTP: `http://localhost:3000`
- HTTPS: `https://localhost:3443`

#### 네트워크 접근 (예: 192.168.2.20)
- HTTP: `http://192.168.2.20:3000`
- HTTPS: `https://192.168.2.20:3443`

### 🔐 브라우저 보안 경고 해결

#### Chrome
1. 브라우저에서 "고급" 클릭
2. "localhost(안전하지 않음)로 이동" 클릭

#### Firefox
1. 브라우저에서 "고급" 클릭
2. "위험을 감수하고 계속" 클릭

#### Safari
1. "자세히" 클릭
2. "웹 사이트 방문" 클릭

### 📱 Firebase 설정

#### 1. Firebase Console 설정
1. [Firebase Console](https://console.firebase.google.com/) 접속
2. 프로젝트 → Authentication → 설정 → 승인된 도메인
3. 다음 도메인 추가:
   - `localhost`
   - `192.168.2.20` (실제 IP 주소)
   - 필요시 다른 로컬 IP 주소

#### 2. 8th Wall 프로젝트 설정
8th Wall 프로젝트에서 API 호출 시:
```javascript
// 동적 API 엔드포인트 설정
const API_BASE_URL = window.location.hostname === 'localhost' 
  ? 'https://localhost:3443'
  : 'https://192.168.2.20:3443';

// API 호출 예시
fetch(`${API_BASE_URL}/api/avatars/026`)
  .then(response => response.json())
  .then(data => console.log(data));
```

### 🛡️ 보안 및 CORS 설정

현재 허용된 도메인:
- `localhost` (HTTP/HTTPS)
- 로컬 네트워크 IP (192.168.x.x, 10.x.x.x, 172.16-31.x.x)
- `*.8thwall.com`
- `*.8thwall.app`

### 🔧 고급 설정

#### 커스텀 인증서 경로
`.env` 파일에서 인증서 경로 변경:
```bash
SSL_KEY_PATH=./custom/path/server.key
SSL_CERT_PATH=./custom/path/server.crt
```

#### 포트 변경
```bash
PORT=3000
HTTPS_PORT=3443
```

### 🐛 문제 해결

#### 1. "ERR_CERT_AUTHORITY_INVALID" 오류
- 브라우저에서 "고급" → "계속" 클릭
- 또는 로컬 CA 설정으로 신뢰할 수 있는 인증서 생성

#### 2. 방화벽 문제
macOS:
```bash
sudo pfctl -f /etc/pf.conf
```

Windows:
- Windows Defender 방화벽에서 포트 3443 허용

#### 3. 8th Wall에서 접근 불가
- Mixed Content 정책 확인
- HTTPS 사용 여부 확인
- Firebase 승인된 도메인 확인

### 📚 참고 자료

- [8th Wall Documentation](https://www.8thwall.com/docs)
- [Firebase Authentication](https://firebase.google.com/docs/auth)
- [Node.js HTTPS](https://nodejs.org/api/https.html)

### 🎉 테스트 페이지

- **커스터마이징**: `https://localhost:3443/test/customize`
- **Firebase 로그인**: `https://localhost:3443/test/login`
- **API 문서**: `https://localhost:3443/api-docs`
</file>

<file path="Readme.md">
# AR Namecard Backend API

AR 명함 서비스를 위한 Node.js + TypeScript + MongoDB 백엔드 API

## 🚀 빠른 시작

### 필요 환경
- Node.js 18+
- MongoDB 실행 중
- npm

### 설치 및 실행

```bash
# 의존성 설치
npm install

# 개발 서버 실행
npm run dev

# 빌드
npm run build

# 프로덕션 서버 실행
npm start
```

## ⚙️ 환경 변수 설정

`.env` 파일을 생성하고 다음 내용을 추가하세요:

```env
# 서버 설정
PORT=3000
HTTPS_PORT=3443
HOST=0.0.0.0
NODE_ENV=development
ENABLE_HTTPS=false

# 데이터베이스 설정
MONGODB_URI=mongodb://localhost:27017/ar_namecard

# JWT 설정
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=24h

# 파일 업로드 설정
MAX_FILE_SIZE=10485760
UPLOAD_DIR=uploads

# CORS 설정
FRONTEND_URL=http://localhost:3000

# SSL 설정 (HTTPS용)
SSL_KEY_PATH=./ssl/server.key
SSL_CERT_PATH=./ssl/server.crt

# Firebase 설정 (선택사항)
# FIREBASE_PROJECT_ID=your-firebase-project-id
# FIREBASE_PRIVATE_KEY=your-firebase-private-key
```

## 🌐 네트워크 및 HTTPS 설정

### HTTP 전용 모드 (기본)
```bash
npm run dev
```

### HTTPS 모드 (8th Wall 호환)

#### 1. SSL 인증서 생성
```bash
# 기본 SSL 인증서 생성
npm run ssl:generate

# 개선된 SSL 인증서 생성 (권장)
npm run ssl:fix

# mkcert 사용 (브라우저 경고 없음, 최고 권장)
npm run ssl:mkcert
```

#### 2. HTTPS 서버 실행
```bash
# 환경 변수로 실행
npm run https

# 또는 .env에 ENABLE_HTTPS=true 설정 후
npm run dev
```

### 로컬 네트워크 접근

#### 접근 URL
- **로컬**: `http://localhost:3000` / `https://localhost:3443`
- **네트워크**: `http://[IP]:3000` / `https://[IP]:3443`

#### 브라우저 보안 경고 해결
- **Chrome**: "고급" → "localhost(안전하지 않음)로 이동"
- **Firefox**: "고급" → "위험을 감수하고 계속"
- **Safari**: "자세히" → "웹사이트 방문"

## 📚 API 문서 및 테스트

### Swagger UI
서버 실행 후 다음 URL에서 API 문서를 확인할 수 있습니다:
- **로컬**: `http://localhost:3000/api-docs`
- **네트워크**: `http://[IP]:3000/api-docs`

### 테스트 페이지
다음 테스트 페이지들이 제공됩니다:

| 페이지 | URL | 설명 |
|--------|-----|------|
| 로그인 테스트 | `/test/login` | Firebase 인증 테스트 |
| 사용자 관리 | `/test/user` | 사용자 CRUD 테스트 |
| 아바타 관리 | `/test/avatar` | 아바타 카테고리 및 옵션 관리 |
| 아이템 관리 | `/test/item` | 아이템 카테고리 및 스프라이트 관리 |
| CORS 테스트 | `/test/cors-test` | 네트워크 접근 및 CORS 테스트 |

### CORS 테스트
다른 PC에서 접근 테스트:
```
http://[서버IP]:3000/test/cors-test
```

## 🛠 사용 가능한 스크립트

```bash
# 개발 및 빌드
npm run dev          # 개발 서버 (nodemon)
npm run build        # TypeScript 컴파일
npm start            # 프로덕션 서버

# HTTPS 관련
npm run https        # HTTPS 개발 서버
npm run http-only    # HTTP 전용 서버
npm run ssl:generate # 기본 SSL 인증서 생성
npm run ssl:fix      # 개선된 SSL 인증서 생성
npm run ssl:mkcert   # mkcert 기반 신뢰 인증서 생성

# 데이터베이스 관리
npm run migrate:firebase    # Firebase 데이터 마이그레이션
npm run create:admin       # 관리자 계정 생성
npm run update:admin       # 관리자 권한 업데이트
```

## 🔐 인증 시스템

### JWT 토큰 인증
대부분의 API는 JWT 토큰이 필요합니다:
```http
Authorization: Bearer <your-jwt-token>
```

### Firebase 인증
Google OAuth를 통한 Firebase 인증도 지원합니다:
- Firebase Console에서 승인된 도메인에 서버 IP 추가 필요
- 로컬 네트워크 접근 시 `http://[IP]:3000` 도메인 추가

## 🛠 API 엔드포인트

### 사용자 관리 (Users)
```http
GET    /api/users/:id        # 사용자 정보 조회
PUT    /api/users/:id        # 사용자 정보 수정
POST   /api/users            # 사용자 생성
GET    /api/users            # 사용자 목록 (관리자)
```

### 아바타 관리 (Avatars)
```http
GET    /api/avatars/:id                    # 아바타 정보 조회 (상세)
PUT    /api/avatars/:id                    # 아바타 정보 수정
GET    /api/avatars/categories             # 아바타 카테고리 목록
GET    /api/avatars/categories/:id/options # 카테고리별 옵션 목록

# 관리자 전용
POST   /api/admin/avatars/categories       # 카테고리 생성
PUT    /api/admin/avatars/categories/:id   # 카테고리 수정
DELETE /api/admin/avatars/categories/:id   # 카테고리 삭제
POST   /api/admin/avatars/options          # 옵션 생성 (다중 업로드 지원)
```

### 스티커 관리 (Stickers)
```http
GET    /api/stickers                  # 스티커 목록 조회
GET    /api/stickers/:id              # 스티커 상세 조회

# 관리자 전용
POST   /api/admin/stickers/categories # 카테고리 생성
POST   /api/admin/stickers           # 스티커 생성 (스프라이트 지원)
```

### 캐릭터 관리 (Characters)
```http
GET    /api/characters                # 캐릭터 카테고리 목록
GET    /api/characters/:id            # 캐릭터 카테고리 상세 조회
```

### 관리자 기능 (Admin)
```http
GET    /api/admin/users          # 전체 사용자 목록
PUT    /api/admin/users/:id      # 사용자 권한 관리
```

### 헬스 체크
```http
GET    /api/health               # 서버 상태 확인
```

## 📊 데이터 모델

### User (사용자)
```typescript
{
  id: string;           // 사용자 ID
  nameEn?: string;      // 영문 이름
  email: string;        // 이메일 (필수, 고유)
  nameKr: string;       // 한글 이름 (필수)
  role?: string;        // 역할 (기본값: 'User')
  part?: string;        // 소속 부서
  phone: string;        // 전화번호 (필수)
  isNamecardActive: boolean; // 명함 활성화 여부
  arId: string;         // AR 명함 ID (3자리, 고유)
  isAdmin: boolean;     // 관리자 여부
}
```

### AvatarWithUser (아바타 + 사용자 통합)
```typescript
{
  // 사용자 정보
  id: string;
  nameKr?: string;
  email?: string;
  arId?: string;
  
  // 아바타 선택 정보 (상세)
  avatarSelections: {
    [category]: {
      id: string;
      name: string;
      imageUrl: string;
      thumbnailUrl: string;
    }
  };
  
  // 역할 및 아이템 (상세)
  role?: { id, name, imageUrl, thumbnailUrl };
  item1?: { id, name, imageUrl, thumbnailUrl, category };
  item2?: { id, name, imageUrl, thumbnailUrl, category };
  item3?: { id, name, imageUrl, thumbnailUrl, category };
  
  avatarImgUrl?: string;
  message: string;
}
```

### AvatarCategory (아바타 카테고리)
```typescript
{
  name: string;         // 카테고리 이름
  type: string;         // 카테고리 타입 (고유)
  options: [{           // 아바타 옵션 배열
    name: string;
    imageUrl: string;
    thumbnailUrl: string;
    thumbnailSource: 'user' | 'auto';
    color?: string;
    order: number;
  }];
  order: number;        // 순서
}
```

### ItemCategory (아이템 카테고리)
```typescript
{
  name: string;         // 카테고리 이름
  type: string;         // 카테고리 타입 (고유)
  items: [{             // 아이템 배열
    name: string;
    imageUrl: string;
    thumbnailUrl: string;
    thumbnailSource: 'user' | 'auto';
    animation?: {       // 스프라이트 애니메이션
      frames: number;   // 프레임 수
      columns: number;  // 열 수
      duration: number; // 지속 시간
      type: string;     // 애니메이션 타입
    };
    order: number;
  }];
  order: number;        // 순서
}
```

## 📁 프로젝트 구조

```
backend/
├── src/
│   ├── config/
│   │   ├── database.ts         # MongoDB 연결
│   │   ├── cors.ts            # CORS 설정 (8th Wall 지원)
│   │   └── swagger.ts         # Swagger 설정
│   ├── controllers/
│   │   ├── userController.ts
│   │   ├── avatarController.ts
│   │   ├── itemController.ts
│   │   ├── adminController.ts
│   │   └── firebaseAuthController.ts
│   ├── middleware/
│   │   ├── auth.ts            # JWT 인증
│   │   └── upload.ts          # 파일 업로드
│   ├── models/
│   │   ├── User.ts
│   │   ├── UserCustomization.ts
│   │   ├── AvatarCategory.ts
│   │   └── ItemCategory.ts
│   ├── routes/                # API 라우트
│   ├── scripts/               # 유틸리티 스크립트
│   ├── utils/
│   │   └── thumbnailGenerator.ts # 썸네일 생성 (Sharp)
│   └── index.ts               # 서버 엔트리포인트
├── public/test/               # 테스트 페이지들
├── uploads/                   # 업로드 파일
├── ssl/                       # SSL 인증서
├── scripts/                   # SSL 생성 스크립트
├── dist/                      # 빌드 결과
├── .env                       # 환경 변수
├── package.json
├── tsconfig.json
├── HTTPS_SETUP.md            # HTTPS 설정 가이드
└── README.md
```

## 🎯 특별 기능

### 썸네일 자동 생성
- **Sharp 라이브러리** 사용으로 300px 썸네일 자동 생성
- **스프라이트 애니메이션** 첫 번째 프레임 추출
- 사용자 업로드 썸네일과 자동 생성 썸네일 모두 지원

### 다중 파일 업로드
- 아바타/아이템 옵션 **여러 개 동시 업로드**
- **개별 설정**: 이름, 색상, 순서 개별 지정
- **일괄 설정**: 공통 속성 자동 적용
- **드래그 앤 드롭** 지원

### 파일 관리 시스템
- 수정/삭제 시 **관련 파일 자동 삭제**
- 썸네일 재생성 기능
- 파일 경로 유틸리티 제공

### 8th Wall 호환
- **HTTPS 필수** 지원
- **Mixed Content** 정책 준수
- 모든 8th Wall 도메인 CORS 허용

## 🧪 테스트 방법

### 1. 기본 연결 테스트
```bash
curl http://localhost:3000/api/health
```

### 2. Swagger UI 테스트
1. 브라우저에서 `http://localhost:3000/api-docs` 접속
2. **Avatars** 섹션이 기본으로 확장됨
3. 각 API의 "Try it out" 버튼으로 테스트

### 3. 네트워크 접근 테스트
1. 다른 PC에서 `http://[서버IP]:3000/test/cors-test` 접속
2. 모든 API 테스트 실행
3. CORS 허용/차단 상태 실시간 확인

### 4. 관리자 페이지 테스트
- **사용자 관리**: `/test/user`
- **아바타 관리**: `/test/avatar` (다중 업로드, 썸네일 생성)
- **아이템 관리**: `/test/item` (스프라이트 애니메이션)

## 🔧 개발 도구

- **TypeScript**: 정적 타입 검사
- **Express**: 웹 프레임워크  
- **MongoDB + Mongoose**: 데이터베이스
- **JWT**: 인증
- **Firebase Admin**: Firebase 인증
- **Multer**: 파일 업로드
- **Sharp**: 이미지 처리 및 썸네일 생성
- **Swagger**: API 문서화
- **Express-validator**: 데이터 유효성 검사
- **CORS**: 크로스 오리진 설정

## 🚨 문제 해결

### SSL 인증서 오류 (ERR_SSL_KEY_USAGE_INCOMPATIBLE)
```bash
# 개선된 인증서 생성
npm run ssl:fix

# 또는 mkcert 사용 (권장)
brew install mkcert
npm run ssl:mkcert
```

### CORS 오류
```bash
# 개발 모드에서 모든 도메인 허용
echo "CORS_ALLOW_ALL=true" >> .env
```

### 포트 충돌
```bash
# 사용 중인 포트 확인
lsof -i :3000

# 프로세스 종료
kill -9 [PID]
```

### MongoDB 연결 오류
```bash
# MongoDB 실행 확인
brew services start mongodb/brew/mongodb-community
```

## 📞 지원

문제가 발생하면 다음을 확인하세요:
1. MongoDB 실행 상태
2. 환경 변수 설정 (.env 파일)
3. 포트 사용 상태
4. 네트워크 방화벽 설정
5. SSL 인증서 유효성

---

**AR Namecard Backend API v1.0.0**  
Node.js + TypeScript + MongoDB 기반의 완전한 AR 명함 백엔드 솔루션
</file>

<file path="simple-compose.yml">
version: '3.8'

services:
  # MongoDB Database
  mongodb:
    image: mongo:6.0
    container_name: ar-namecard-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: hnine0426
      MONGO_INITDB_DATABASE: ar_namecard
    volumes:
      - /volume1/docker/ar-namecard/data/mongodb:/data/db
    networks:
      - ar-namecard-network
    ports:
      - "127.0.0.1:27017:27017"
    command: mongod --auth

  # AR Namecard API Server
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ar-namecard-api
    restart: unless-stopped
    depends_on:
      - mongodb
    environment:
      NODE_ENV: production
      PORT: 3000
      HTTPS_PORT: 3443
      HOST: 0.0.0.0
      ENABLE_HTTPS: false
      MONGODB_URI: mongodb://admin:hnine0426@mongodb:27017/ar_namecard?authSource=admin
      JWT_SECRET: super-secure-jwt-secret-for-production
      JWT_EXPIRES_IN: 24h
      MAX_FILE_SIZE: 10485760
      UPLOAD_DIR: uploads
      FRONTEND_URL: http://192.168.1.93:3000
      CORS_ALLOW_ALL: true
    volumes:
      - /volume1/docker/ar-namecard/uploads:/app/uploads
      - /volume1/docker/ar-namecard/ssl:/app/ssl
      - /volume1/docker/ar-namecard/public:/app/public
    networks:
      - ar-namecard-network
    ports:
      - "3000:3000"
      - "3443:3443"

networks:
  ar-namecard-network:
    driver: bridge
</file>

<file path="SYNOLOGY_DEPLOYMENT.md">
# 시놀로지 NAS 배포 가이드

## 📋 개요

이 가이드는 AR Namecard API를 시놀로지 NAS 서버 (192.168.1.93)에 Docker를 사용하여 배포하는 방법을 설명합니다.

## 🎯 배포 목표

- **고가용성**: Docker Compose를 통한 서비스 관리
- **데이터 보호**: MongoDB 데이터 영구 저장
- **보안**: HTTPS 지원 및 방화벽 설정
- **모니터링**: 로깅 및 헬스체크
- **백업**: 자동화된 백업 시스템

## 🛠 사전 준비

### 1. 시놀로지 NAS 설정

#### Container Manager 설치
1. Package Center에서 "Container Manager" 설치
2. Docker 서비스 활성화

#### SSH 접근 설정
1. 제어판 > 터미널 및 SNMP > SSH 서비스 활성화
2. SSH 키 설정 (권장)

```bash
# 로컬에서 SSH 키 생성
ssh-keygen -t rsa -b 4096 -C "your-email@example.com"

# 공개키를 NAS에 복사
ssh-copy-id admin@192.168.1.93
```

### 2. 네트워크 설정

#### 포트 개방 (제어판 > 보안 > 방화벽)
- **3000**: HTTP API
- **3443**: HTTPS API
- **80**: HTTP (Nginx, 선택사항)
- **443**: HTTPS (Nginx, 선택사항)

#### 도메인 설정 (선택사항)
- DNS에 `ar-namecard.local` 추가
- 또는 `/etc/hosts`에 `192.168.1.93 ar-namecard.local` 추가

## 🚀 배포 과정

### 1. 초기 배포

```bash
# 배포 스크립트 실행
./deploy.sh

# 또는 수동 배포
./deploy.sh deploy
```

배포 과정:
1. ✅ 사전 요구사항 확인
2. 🔗 NAS 연결 테스트
3. 📁 디렉토리 구조 생성
4. 🏗️ 애플리케이션 빌드
5. 📤 파일 전송
6. ⚙️ 환경 설정
7. 🔐 SSL 인증서 생성
8. 🐳 Docker 서비스 배포
9. ✅ 배포 검증

### 2. 환경 변수 설정

배포 후 `.env` 파일을 편집하여 실제 환경에 맞게 설정:

```bash
ssh admin@192.168.1.93
cd /volume1/docker/ar-namecard/app
nano .env
```

**필수 변경 사항:**
- `JWT_SECRET`: 강력한 비밀키로 변경
- `MONGO_ROOT_PASSWORD`: MongoDB 관리자 비밀번호
- `FIREBASE_*`: Firebase 프로젝트 설정
- `FRONTEND_URL`: 프론트엔드 도메인

### 3. Firebase 설정

Firebase 서비스 계정 키 파일을 NAS에 업로드:

```bash
# 로컬에서 Firebase 키 파일 복사
scp firebase-service-account.json admin@192.168.1.93:/volume1/docker/ar-namecard/app/
```

## 📊 서비스 관리

### 상태 확인

```bash
# 서비스 상태 확인
./deploy.sh status

# 로그 확인
./deploy.sh logs

# SSH로 직접 확인
ssh admin@192.168.1.93 'cd /volume1/docker/ar-namecard/app && docker-compose ps'
```

### 서비스 제어

```bash
# 서비스 재시작
./deploy.sh restart

# 서비스 중지
./deploy.sh stop

# 애플리케이션만 업데이트
./deploy.sh update
```

### 직접 관리 (SSH)

```bash
ssh admin@192.168.1.93
cd /volume1/docker/ar-namecard/app

# 서비스 상태 확인
docker-compose ps

# 로그 보기 (실시간)
docker-compose logs -f

# 특정 서비스 로그
docker-compose logs -f api
docker-compose logs -f mongodb

# 서비스 재시작
docker-compose restart

# 설정 변경 후 재배포
docker-compose up -d --build
```

## 💾 백업 및 복구

### 백업 생성

```bash
# 전체 백업
./backup.sh backup

# 백업 목록 확인
./backup.sh list
```

### 백업 복구

```bash
# MongoDB 복구
./backup.sh restore-db 20250121_143000

# 업로드 파일 복구
./backup.sh restore-uploads 20250121_143000

# 백업 무결성 확인
./backup.sh verify 20250121_143000
```

### 자동 백업 설정

crontab에 자동 백업 스케줄 추가:

```bash
ssh admin@192.168.1.93
crontab -e

# 매일 새벽 2시 백업
0 2 * * * /volume1/docker/ar-namecard/backup.sh backup

# 매주 일요일 오래된 백업 정리 (30일 이상)
0 3 * * 0 /volume1/docker/ar-namecard/backup.sh cleanup 30
```

## 🔧 문제 해결

### 일반적인 문제

#### 1. 컨테이너가 시작되지 않음

```bash
# 로그 확인
docker-compose logs

# 포트 충돌 확인
netstat -tlnp | grep :3000

# 디스크 공간 확인
df -h
```

#### 2. MongoDB 연결 실패

```bash
# MongoDB 컨테이너 상태 확인
docker-compose logs mongodb

# MongoDB 접속 테스트
docker-compose exec mongodb mongosh -u admin -p
```

#### 3. SSL 인증서 문제

```bash
# 인증서 재생성
cd /volume1/docker/ar-namecard
openssl req -x509 -newkey rsa:4096 -keyout ssl/server.key -out ssl/server.crt -days 365 -nodes \
    -subj '/C=KR/ST=Seoul/L=Seoul/O=AR-Namecard/CN=192.168.1.93'
```

#### 4. 파일 권한 문제

```bash
# 권한 수정
sudo chown -R admin:administrators /volume1/docker/ar-namecard
sudo chmod -R 755 /volume1/docker/ar-namecard
```

### 성능 최적화

#### MongoDB 최적화

```bash
# MongoDB 메모리 사용량 제한 (docker-compose.yml)
services:
  mongodb:
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
```

#### 로그 로테이션

```bash
# Docker 로그 제한 설정
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

## 📈 모니터링

### 시스템 리소스 모니터링

```bash
# CPU 및 메모리 사용량
docker stats

# 디스크 사용량
df -h /volume1/docker/ar-namecard

# 네트워크 연결
netstat -tlnp | grep :3000
```

### 애플리케이션 모니터링

```bash
# API 헬스체크
curl http://192.168.1.93:3000/api/health

# API 응답 시간 테스트
curl -w "@curl-format.txt" -o /dev/null -s http://192.168.1.93:3000/api/health
```

### 로그 분석

```bash
# 오류 로그 검색
docker-compose logs | grep -i error

# 특정 시간대 로그
docker-compose logs --since="2024-01-21T10:00:00"

# 로그 통계
docker-compose logs | grep "GET /api" | wc -l
```

## 🔒 보안 고려사항

### 네트워크 보안

1. **방화벽 설정**: 필요한 포트만 개방
2. **VPN 접근**: 외부 접근 시 VPN 사용 권장
3. **SSL/TLS**: HTTPS 강제 사용

### 데이터 보안

1. **데이터베이스 암호화**: MongoDB 암호화 활성화
2. **백업 암호화**: 중요 데이터 백업 시 암호화
3. **접근 제어**: 최소 권한 원칙 적용

### 애플리케이션 보안

1. **환경변수**: 중요 정보는 환경변수로 관리
2. **JWT 보안**: 강력한 JWT 시크릿 사용
3. **CORS 설정**: 허용된 도메인만 접근 허용

## 📚 추가 자료

### 유용한 명령어

```bash
# 전체 시스템 상태 확인
./deploy.sh status && ./backup.sh list

# 완전한 재배포
./deploy.sh stop && ./deploy.sh deploy

# 개발 모드로 로컬 테스트
npm run dev

# 프로덕션 빌드 테스트
npm run build && npm start
```

### 디렉토리 구조

```
/volume1/docker/ar-namecard/
├── app/                        # 애플리케이션 코드
│   ├── dist/                   # 컴파일된 TypeScript
│   ├── node_modules/           # Node.js 의존성
│   ├── .env                    # 환경 변수
│   ├── docker-compose.yml      # Docker 구성
│   └── firebase-service-account.json
├── data/                       # 데이터베이스 파일
│   ├── mongodb/                # MongoDB 데이터
│   └── mongodb-config/         # MongoDB 설정
├── uploads/                    # 업로드된 파일
├── ssl/                        # SSL 인증서
├── public/                     # 정적 파일
├── backups/                    # 백업 파일
│   ├── mongodb/                # DB 백업
│   ├── uploads/                # 파일 백업
│   ├── config/                 # 설정 백업
│   └── ssl/                    # SSL 백업
└── logs/                       # 로그 파일
```

### 연락처 및 지원

문제 발생 시:
1. 로그 확인 후 문제 분석
2. 공식 문서 참조
3. 개발팀 문의

---

**배포 완료 후 확인사항:**
- ✅ API 엔드포인트 정상 작동: `http://192.168.1.93:3000/api/health`
- ✅ HTTPS 접근 가능: `https://192.168.1.93:3443/api/health`
- ✅ Swagger 문서 접근: `http://192.168.1.93:3000/api-docs`
- ✅ MongoDB 연결 정상
- ✅ 파일 업로드 기능 정상
- ✅ 백업 시스템 동작
</file>

<file path="test-firebase-upload.js">
const fs = require('fs');
const path = require('path');

// Create a simple test image file
const testImagePath = path.join(__dirname, 'test-image.txt');
const testContent = 'This is a test file for Firebase Storage upload';

fs.writeFileSync(testImagePath, testContent);

console.log('Test file created:', testImagePath);
console.log('File content:', fs.readFileSync(testImagePath, 'utf8'));

// Test if all required environment variables are available
const requiredEnvVars = [
  'FIREBASE_PROJECT_ID',
  'FIREBASE_CLIENT_EMAIL', 
  'FIREBASE_PRIVATE_KEY',
  'FIREBASE_STORAGE_BUCKET'
];

console.log('\n📋 Environment Variables Check:');
requiredEnvVars.forEach(varName => {
  const value = process.env[varName];
  if (value) {
    console.log(`✅ ${varName}: ${varName === 'FIREBASE_PRIVATE_KEY' ? '[REDACTED]' : value}`);
  } else {
    console.log(`❌ ${varName}: NOT SET`);
  }
});

console.log('\n🔗 Testing MongoDB connection and Firebase configuration...');
console.log('Server should be running on: http://localhost:3002');
console.log('MongoDB URI:', process.env.MONGODB_URI || 'NOT SET');
</file>

<file path="test-image.txt">
This is a test file for Firebase Storage upload
</file>

<file path="test-upload.js">
const FormData = require('form-data');
const fs = require('fs');
const axios = require('axios').default;
const path = require('path');

// 간단한 테스트 이미지 파일 생성 (1px 투명 PNG)
const createTestImage = () => {
  const pngData = Buffer.from([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
    0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
    0x0B, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0x63, 0x60, 0x00, 0x02, 0x00,
    0x00, 0x05, 0x00, 0x01, 0xE2, 0x26, 0x05, 0x9B, 0x00, 0x00, 0x00, 0x00,
    0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
  ]);
  
  const testImagePath = path.join(__dirname, 'test-image.png');
  fs.writeFileSync(testImagePath, pngData);
  return testImagePath;
};

async function testUpload() {
  try {
    console.log('🔍 Firebase Storage 업로드 테스트 시작...');
    
    // 테스트 이미지 생성
    const testImagePath = createTestImage();
    console.log('✅ 테스트 이미지 생성 완료:', testImagePath);
    
    // FormData 준비
    const form = new FormData();
    form.append('file', fs.createReadStream(testImagePath), {
      filename: 'test-image.png',
      contentType: 'image/png'
    });
    
    console.log('📤 업로드 요청 전송 중...');
    
    const response = await axios.post('http://localhost:3002/api/upload', form, {
      headers: {
        ...form.getHeaders(),
        'Content-Type': 'multipart/form-data'
      },
      timeout: 30000
    });
    
    if (response.status === 200) {
      console.log('🎉 업로드 성공!');
      console.log('📋 응답 데이터:', response.data);
      console.log('🔗 Firebase Storage URL:', response.data.url);
    } else {
      console.log('❌ 업로드 실패:', response.status, response.statusText);
    }
    
    // 테스트 파일 정리
    fs.unlinkSync(testImagePath);
    console.log('🧹 테스트 파일 정리 완료');
    
  } catch (error) {
    console.error('💥 업로드 테스트 오류:', error.response?.data || error.message);
    
    // 상세 에러 정보
    if (error.response) {
      console.error('📊 에러 상태:', error.response.status);
      console.error('📋 에러 데이터:', error.response.data);
    }
  }
}

testUpload();
</file>

<file path="test.txt">
Firebase Storage upload test file
</file>

</files>
