This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  test/
    avatar_new.html
    avatar.html
    cors-test.html
    customize.html
    item.html
    login.html
    user.html
scripts/
  generate-ssl-cert-fixed.js
  generate-ssl-cert.js
  migrate-avatar-colors.js
  migrate-uploads-to-firebase.ts
  setup-mkcert.js
  update-db-urls-to-firebase.ts
src/
  config/
    cors.ts
    database.ts
    firebase-storage.ts
    swagger.ts
  controllers/
    adminAvatarController.ts
    adminController.ts
    adminItemController.ts
    authController.ts
    avatarController.ts
    firebaseAuthController.ts
    itemController.ts
    userController.ts
  middleware/
    auth.ts
    upload.ts
  models/
    AvatarCategory.ts
    index.ts
    ItemCategory.ts
    User.ts
    UserCustomization.ts
  routes/
    adminAvatarRoutes.ts
    adminItemRoutes.ts
    adminRoutes.ts
    authRoutes.ts
    avatarRoutes.ts
    charactersRoutes.ts
    firebaseAuthRoutes.ts
    itemRoutes.ts
    userRoutes.ts
  scripts/
    config/
      firebase-admin.ts
    types/
      firebase-user.ts
    utils/
      arId-generator.ts
      data-mapper.ts
    create-admin.ts
    firebase-migration.ts
    update-admin-permissions.ts
  utils/
    paletteImageProcessor.ts
    thumbnailGenerator.ts
  index.ts
ssl/
  server.crt
  server.crt.backup
.gitignore
backup.sh
CORS_SETUP.md
deploy.sh
DEPLOYMENT_CHECKLIST.md
docker-compose.yml
Dockerfile
HTTPS_SETUP.md
Readme.md
simple-compose.yml
SYNOLOGY_DEPLOYMENT.md
test-firebase-upload.js
test-image.txt
test-upload.js
test.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/test/avatar_new.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìºë¦­í„° ì˜µì…˜ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ - AR ëª…í•¨ (ìƒˆ ì»¬ëŸ¬ ì˜µì…˜)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input,
        select,
        textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"],
        input[type="email"],
        input[type="tel"],
        input[type="color"],
        textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: 'â–¶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-options {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .option-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .option-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        .option-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .option-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        /* ì»¬ëŸ¬ ì˜µì…˜ ê´€ë ¨ ìŠ¤íƒ€ì¼ */
        .color-option-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #f9f9f9;
        }

        .color-option-preview {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            margin-top: 10px;
        }

        .palette-preview {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            margin-top: 5px;
        }

        .color-options-display {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .color-option-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 15px;
            font-size: 12px;
        }

        .color-option-display img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
        }

        .color-option-display .palette-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¨ ìºë¦­í„° ì˜µì…˜ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ í˜ì´ì§€ (ìƒˆ ì»¬ëŸ¬ ì˜µì…˜)</h1>

        <!-- ì¸ì¦ ì„¹ì…˜ -->
        <div class="section auth-section">
            <h3>ğŸ” ê´€ë¦¬ì ì¸ì¦</h3>
            <p>ìºë¦­í„° ì˜µì…˜ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="ê´€ë¦¬ì JWT í† í° ì…ë ¥" style="width: 400px;">
                <button onclick="setAuthToken()">í† í° ì„¤ì •</button>
                <button onclick="getAdminToken()" class="btn-success">ê´€ë¦¬ì í† í° ìƒì„±</button>
                <button onclick="clearAuthToken()" class="btn-secondary">í† í° ì´ˆê¸°í™”</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- ì¹´í…Œê³ ë¦¬ ê´€ë¦¬ ì„¹ì…˜ -->
        <div class="section">
            <h3>ğŸ“ ìºë¦­í„° ì˜µì…˜ ì¹´í…Œê³ ë¦¬ ê´€ë¦¬</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</button>
                <button onclick="loadCategories()" class="btn-secondary">ìƒˆë¡œê³ ì¹¨</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- ì¹´í…Œê³ ë¦¬ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">

                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">ì¹´í…Œê³ ë¦¬ ì´ë¦„ *</label>
                        <input type="text" id="categoryName" required placeholder="ì˜ˆ: ì–¼êµ´í˜•, ëˆˆ, ì½”, ì…">
                    </div>

                    <div class="form-group">
                        <label for="categoryType">ì¹´í…Œê³ ë¦¬ íƒ€ì… *</label>
                        <input type="text" id="categoryType" required placeholder="ì˜ˆ: face, eyes, nose, mouth">
                    </div>
                </div>

                <div class="form-group">
                    <label for="categoryOrder">ìˆœì„œ</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>

                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ìºë¦­í„° ì˜µì…˜ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="optionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeOptionModal()">&times;</span>
            <h3 id="optionModalTitle">ğŸ­ ìƒˆ ìºë¦­í„° ì˜µì…˜ ì¶”ê°€</h3>
            <form id="optionForm" enctype="multipart/form-data">
                <input type="hidden" id="optionCategoryId">
                <input type="hidden" id="optionId">

                <div class="form-row">
                    <div class="form-group">
                        <label for="optionName">ì˜µì…˜ ì´ë¦„ *</label>
                        <input type="text" id="optionName" required placeholder="ì˜ˆ: ë‘¥ê·¼ ì–¼êµ´, ë‚ ì¹´ë¡œìš´ ëˆˆ">
                    </div>

                    <div class="form-group">
                        <label for="optionOrder">ìˆœì„œ</label>
                        <input type="number" id="optionOrder" min="0" value="0">
                    </div>
                </div>

                <!-- ì»¬ëŸ¬ ì˜µì…˜ ê´€ë¦¬ ì„¹ì…˜ -->
                <div class="form-group">
                    <label>ì»¬ëŸ¬ ì˜µì…˜ ê´€ë¦¬ *</label>
                    <small>ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ì˜ ì´ë¯¸ì§€ê°€ ë©”ì¸ ì´ë¯¸ì§€ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.</small>
                    <div id="colorOptionsContainer">
                        <!-- ì»¬ëŸ¬ ì˜µì…˜ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                    </div>
                    <button type="button" onclick="addColorOption()" class="btn-success" style="margin-top: 10px;">ì»¬ëŸ¬ ì˜µì…˜
                        ì¶”ê°€</button>
                </div>

                <div class="form-group">
                    <label for="optionThumbnail">ì¸ë„¤ì¼ ì´ë¯¸ì§€ (300x300px ê¶Œì¥)</label>
                    <input type="file" id="optionThumbnail" accept="image/*">
                    <small>ì¸ë„¤ì¼ì„ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ì²« ë²ˆì§¸ ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ì—ì„œ ìë™ ìƒì„±ë©ë‹ˆë‹¤.</small>
                    <div id="thumbnailPreview"></div>
                </div>

                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeOptionModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success" id="submitOptionBtn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let expandedCategories = new Set();
        let colorOptionIndex = 0;

        // ì¸ì¦ í† í° ì„¤ì •
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', 'í† í°ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', 'âœ… ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');

            loadCategories();
        }

        // ê´€ë¦¬ì í† í° ìƒì„±
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', 'ê´€ë¦¬ì í† í°ì„ ìƒì„±í•˜ëŠ” ì¤‘...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);

                    showStatus('authStatus', 'success', `âœ… ê´€ë¦¬ì í† í°ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìš©ì: ${data.user.nameKr})`);

                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `âŒ í† í° ìƒì„± ì‹¤íŒ¨: ${data.message || 'ê´€ë¦¬ì ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}`);
                }

            } catch (error) {
                console.error('í† í° ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('authStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // í† í° ì´ˆê¸°í™”
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', 'ğŸ”„ í† í°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');

            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í† í° ë³µì›
        window.addEventListener('load', function () {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', 'âœ… ì €ì¥ëœ í† í°ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                loadCategories();
            }
        });

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', 'âŒ ë¨¼ì € ê´€ë¦¬ì í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `âœ… ${categories.length}ê°œì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    showStatus('categoryStatus', 'error', `âŒ ${data.message || 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨'}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('categoryStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>ë“±ë¡ëœ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            categories.forEach(category => {
                const categoryId = category._id || category.id;
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateOptionModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">ì˜µì…˜ ì¶”ê°€</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">ìˆ˜ì •</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">ì‚­ì œ</button>
                        </div>
                    </div>
                    <div class="category-options">
                        <p><strong>ì˜µì…˜ ìˆ˜:</strong> ${category.options ? category.options.length : 0}ê°œ</p>
                        <div class="options-grid" id="options-${categoryId}">
                            ${renderOptions(category.options || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');

            card.classList.toggle('collapsed');

            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // ì˜µì…˜ ë Œë”ë§
        function renderOptions(options, categoryId) {
            if (!options || options.length === 0) {
                return '<p>ë“±ë¡ëœ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                const colorOptionsDisplay = option.color && Array.isArray(option.color) ?
                    `<div class="color-options-display">
                        ${option.color.map(colorOpt => {
                        const imageUrl = colorOpt.paletteImageUrl || colorOpt.imageUrl;
                        return `<div class="color-option-display">
                                <img src="${imageUrl}" alt="${colorOpt.colorName}" class="palette-circle">
                            </div>`;
                    }).join('')}
                    </div>` :
                    '<div style="font-size: 12px; color: #666;">ì»¬ëŸ¬ ì˜µì…˜ ì—†ìŒ</div>';

                return `
                    <div class="option-card">
                        <div class="option-image-container">
                            ${option.thumbnailUrl ? `<img src="${option.thumbnailUrl}" alt="${option.name}" class="option-image">` : '<div class="option-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">ì¸ë„¤ì¼ ì—†ìŒ</div>'}
                        </div>
                        <div class="option-name">${option.name}</div>
                        ${colorOptionsDisplay}
                        <div class="thumbnail-source">ì¸ë„¤ì¼: ${option.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'}</div>
                        <div class="option-actions">
                            <button onclick="openEditOptionModal('${categoryId}', '${optionId}', '${option.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">ìˆ˜ì •</button>
                            <button onclick="deleteOption('${categoryId}', '${optionId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">ì‚­ì œ</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${optionId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">ì¸ë„¤ì¼ ì¬ìƒì„±</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ì»¬ëŸ¬ ì˜µì…˜ ì¶”ê°€
        function addColorOption() {
            colorOptionIndex++;
            const container = document.getElementById('colorOptionsContainer');
            const colorOptionDiv = document.createElement('div');
            colorOptionDiv.className = 'color-option-item';
            colorOptionDiv.setAttribute('data-index', colorOptionIndex);
            
            // í˜„ì¬ ì¹´í…Œê³ ë¦¬ í™•ì¸
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';
            
            // hair ì¹´í…Œê³ ë¦¬ìš© ì¶”ê°€ í•„ë“œ
            const hairFields = isHairCategory ? `
                <div class="form-group hair-resource-group" style="border: 2px dashed #e74c3c; padding: 15px; border-radius: 5px; background: #fef5f5;">
                    <label>ğŸ’‡â€â™€ï¸ ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ (í•„ìˆ˜) *</label>
                    <input type="file" class="hair-middle-image" accept="image/*" onchange="previewHairResourceImage(this, 'middle')">
                    <div class="hair-middle-preview"></div>
                </div>
                <div class="form-group hair-resource-group" style="border: 2px dashed #3498db; padding: 15px; border-radius: 5px; background: #f0f8ff;">
                    <label>ğŸ’‡â€â™€ï¸ ë’·ë¨¸ë¦¬ ì´ë¯¸ì§€ (ì„ íƒ)</label>
                    <input type="file" class="hair-back-image" accept="image/*" onchange="previewHairResourceImage(this, 'back')">
                    <div class="hair-back-preview"></div>
                    <small style="color: #666;">ì—†ìœ¼ë©´ ì¤‘ê°„ë¨¸ë¦¬ë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤</small>
                </div>
            ` : '';

            colorOptionDiv.innerHTML = `
                <div class="form-row">
                    <div class="form-group">
                        <label>ì»¬ëŸ¬ ì´ë¦„ *</label>
                        <input type="text" class="color-name" placeholder="ì˜ˆ: ë¹¨ê°•, íŒŒë‘" required>
                    </div>
                    <div class="form-group">
                        <label>ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (128x128)</label>
                        <input type="file" class="palette-image" accept="image/*" onchange="previewPaletteImage(this)">
                        <small>íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë¥¼ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ì´ë¯¸ì§€ë¥¼ ë™ê·¸ë—ê²Œ í‘œì‹œí•©ë‹ˆë‹¤.</small>
                        <div class="palette-preview-container"></div>
                    </div>
                    ${!isHairCategory ? `
                    <div class="form-group">
                        <label>ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ íŒŒì¼ *</label>
                        <input type="file" class="color-image" accept="image/*" required onchange="previewColorImage(this)">
                        <div class="color-preview"></div>
                    </div>
                    ` : `
                    <div class="form-group" style="background: #fff3cd; padding: 10px; border-radius: 5px; border: 1px solid #ffeaa7;">
                        <div style="color: #856404; font-size: 14px;">
                            ğŸ’¡ <strong>Hair ì¹´í…Œê³ ë¦¬ ì•ˆë‚´:</strong><br>
                            ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ê°€ ê¸°ë³¸ ì´ë¯¸ì§€ë¡œ ìë™ ì„¤ì •ë©ë‹ˆë‹¤.<br>
                            ë³„ë„ì˜ ê¸°ë³¸ ì´ë¯¸ì§€ ì—…ë¡œë“œëŠ” ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
                        </div>
                    </div>
                    `}
                    
                    ${hairFields}
                    
                    <div class="form-group" style="width: auto;">
                        <button type="button" onclick="removeColorOption(${colorOptionIndex})" class="btn-danger" style="margin-top: 24px;">ì‚­ì œ</button>
                    </div>
                </div>
            `;
            container.appendChild(colorOptionDiv);
        }

        // ì»¬ëŸ¬ ì˜µì…˜ ì‚­ì œ
        function removeColorOption(index) {
            const colorOption = document.querySelector(`[data-index="${index}"]`);
            if (colorOption) {
                colorOption.remove();
            }

            // ìµœì†Œ í•˜ë‚˜ì˜ ì»¬ëŸ¬ ì˜µì…˜ì€ ìœ ì§€
            const remainingOptions = document.querySelectorAll('.color-option-item');
            if (remainingOptions.length === 0) {
                addColorOption();
            }
        }

        // ì»¬ëŸ¬ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        function previewColorImage(input) {
            const previewDiv = input.parentNode.querySelector('.color-preview');
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    previewDiv.innerHTML = `<img src="${e.target.result}" alt="ë¯¸ë¦¬ë³´ê¸°" class="color-option-preview">`;
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                previewDiv.innerHTML = '';
            }
        }

        // Hair ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        function previewHairResourceImage(input, type) {
            const file = input.files[0];
            const colorOption = input.closest('.color-option-item');
            const preview = colorOption.querySelector(`.hair-${type}-preview`);
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `
                        <img src="${e.target.result}" alt="${type === 'middle' ? 'ì¤‘ê°„ë¨¸ë¦¬' : 'ë’·ë¨¸ë¦¬'} ë¯¸ë¦¬ë³´ê¸°" 
                             style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                        <br><small style="color: #666;">${file.name}</small>
                    `;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        }

        // íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        function previewPaletteImage(input) {
            const previewContainer = input.parentNode.querySelector('.palette-preview-container');
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    previewContainer.innerHTML = `<img src="${e.target.result}" alt="íŒ”ë ˆíŠ¸ ë¯¸ë¦¬ë³´ê¸°" class="palette-circle" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-top: 5px;">`;
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                previewContainer.innerHTML = '';
            }
        }

        // ì»¬ëŸ¬ ì˜µì…˜ ë°ì´í„° ìˆ˜ì§‘
        function collectColorOptions() {
            const colorOptions = [];
            const colorOptionItems = document.querySelectorAll('.color-option-item');
            
            console.log(`ğŸ” collectColorOptions ì‹œì‘ - ì´ ${colorOptionItems.length}ê°œ ì˜µì…˜ ì•„ì´í…œ ë°œê²¬`);
            
            // ì¹´í…Œê³ ë¦¬ íƒ€ì… í™•ì¸
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            colorOptionItems.forEach((item, index) => {
                const colorName = item.querySelector('.color-name').value.trim();
                // Hair ì¹´í…Œê³ ë¦¬ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ê¸°ë³¸ ì´ë¯¸ì§€ íŒŒì¼ ìˆ˜ì§‘
                const imageFile = !isHairCategory ? item.querySelector('.color-image')?.files[0] : null;
                const paletteFile = item.querySelector('.palette-image').files[0];
                const existingImageUrl = item.getAttribute('data-image-url'); // ìˆ˜ì • ëª¨ë“œìš©
                const existingPaletteUrl = item.getAttribute('data-palette-url'); // ìˆ˜ì • ëª¨ë“œìš©
                
                // ê¸°ì¡´ resourceImages ë°ì´í„° í™•ì¸ (ìˆ˜ì • ëª¨ë“œìš©)
                let existingResourceImages = null;
                if (isHairCategory) {
                    const middlePreview = item.querySelector('.hair-middle-preview img');
                    const backPreview = item.querySelector('.hair-back-preview img');
                    if (middlePreview || backPreview) {
                        existingResourceImages = {};
                        if (middlePreview) existingResourceImages.hairMiddleImageUrl = middlePreview.src;
                        if (backPreview) existingResourceImages.hairBackImageUrl = backPreview.src;
                    }
                }

                // hair ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° ì¶”ê°€ ê²€ì¦ ë° ë°ì´í„° ìˆ˜ì§‘
                let hairMiddleFile = null;
                let hairBackFile = null;
                
                if (isHairCategory) {
                    const middleInput = item.querySelector('.hair-middle-image');
                    const backInput = item.querySelector('.hair-back-image');
                    
                    console.log(`ğŸ” Hair ë””ë²„ê¹… - ì»¬ëŸ¬ ${index}:`, {
                        colorName,
                        middleInput: middleInput ? 'found' : 'not found',
                        backInput: backInput ? 'found' : 'not found',
                        middleFiles: middleInput?.files?.length || 0,
                        backFiles: backInput?.files?.length || 0
                    });
                    
                    hairMiddleFile = middleInput?.files[0];
                    hairBackFile = backInput?.files[0];
                    
                    // ì¤‘ê°„ë¨¸ë¦¬ í•„ìˆ˜ ê²€ì¦ (ìƒˆë¡œ ì¶”ê°€í•˜ëŠ” ê²½ìš°ë§Œ)
                    if (!hairMiddleFile && !existingResourceImages) {
                        throw new Error(`ì»¬ëŸ¬ ì˜µì…˜ "${colorName}"ì— ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.`);
                    }
                }

                // Hair ì¹´í…Œê³ ë¦¬: colorName + ì¤‘ê°„ë¨¸ë¦¬ íŒŒì¼ì´ ìˆìœ¼ë©´ ë¨
                // ì¼ë°˜ ì¹´í…Œê³ ë¦¬: colorName + (imageFile || existingImageUrl) í•„ìš”
                const isValidColorOption = colorName && (
                    isHairCategory ? (hairMiddleFile || existingResourceImages) : (imageFile || existingImageUrl)
                );
                
                // ë””ë²„ê¹… ë¡œê·¸
                if (isHairCategory) {
                    console.log(`ğŸ” Hair ì˜µì…˜ ê²€ì¦ - ì»¬ëŸ¬ ${index}:`, {
                        colorName,
                        hasMiddleFile: !!hairMiddleFile,
                        hasExistingData: !!existingResourceImages,
                        isValid: isValidColorOption
                    });
                }
                
                if (isValidColorOption) {
                    const colorOption = {
                        colorName: colorName,
                        imageFile: imageFile,
                        paletteFile: paletteFile,
                        imageUrl: existingImageUrl,
                        paletteImageUrl: existingPaletteUrl
                    };
                    
                    // hair ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° hair íŒŒì¼ë“¤ ë° ê¸°ì¡´ ë°ì´í„° ì¶”ê°€
                    if (isHairCategory) {
                        colorOption.hairMiddleFile = hairMiddleFile;
                        colorOption.hairBackFile = hairBackFile;
                        if (existingResourceImages) {
                            colorOption.resourceImages = existingResourceImages;
                        }
                    }
                    
                    colorOptions.push(colorOption);
                } else {
                    console.log(`âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ì»¬ëŸ¬ ì˜µì…˜ - ì»¬ëŸ¬ ${index}:`, {
                        colorName,
                        hasImageFile: !!imageFile,
                        hasExistingImageUrl: !!existingImageUrl,
                        hasMiddleFile: !!hairMiddleFile,
                        hasExistingResourceImages: !!existingResourceImages,
                        isHairCategory
                    });
                }
            });

            console.log(`ğŸ” collectColorOptions ì™„ë£Œ - ìˆ˜ì§‘ëœ ìœ íš¨í•œ ì˜µì…˜: ${colorOptions.length}ê°œ`);
            return colorOptions;
        }

        // ì»¬ëŸ¬ ì˜µì…˜ ë¡œë“œ (ìˆ˜ì • ëª¨ë“œìš©)
        function loadColorOptions(colorOptions) {
            const container = document.getElementById('colorOptionsContainer');
            container.innerHTML = '';
            colorOptionIndex = 0;

            if (!colorOptions || colorOptions.length === 0) {
                addColorOption();
                return;
            }

            // ì¹´í…Œê³ ë¦¬ íƒ€ì… í™•ì¸
            const categoryId = document.getElementById('optionCategoryId').value;
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            colorOptions.forEach((colorOption, index) => {
                console.log(`ğŸ” loadColorOptions - ì»¬ëŸ¬ ì˜µì…˜ ${index}:`, {
                    colorName: colorOption.colorName,
                    imageUrl: colorOption.imageUrl,
                    resourceImages: colorOption.resourceImages,
                    isHairCategory
                });
                
                colorOptionIndex++;
                const colorOptionDiv = document.createElement('div');
                colorOptionDiv.className = 'color-option-item';
                colorOptionDiv.setAttribute('data-index', colorOptionIndex);
                colorOptionDiv.setAttribute('data-image-url', colorOption.imageUrl);
                if (colorOption.paletteImageUrl) {
                    colorOptionDiv.setAttribute('data-palette-url', colorOption.paletteImageUrl);
                }

                const palettePreview = colorOption.paletteImageUrl ?
                    `<img src="${colorOption.paletteImageUrl}" alt="í˜„ì¬ íŒ”ë ˆíŠ¸" class="palette-circle" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-top: 5px;" onerror="this.style.display='none'; this.nextElementSibling.textContent='íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨';">
                     <div style="font-size: 12px; color: #666; margin-top: 5px;">í˜„ì¬ íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€</div>` : '';

                // hair ì¹´í…Œê³ ë¦¬ìš© ê¸°ì¡´ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°
                const resourceImages = colorOption.resourceImages || {};
                const backHair = resourceImages.hairBackImageUrl || null;      // ë’·ë¨¸ë¦¬
                const middleHair = resourceImages.hairMiddleImageUrl || null;  // ì¤‘ê°„ë¨¸ë¦¬

                const hairFields = isHairCategory ? `
                    <div class="form-group hair-resource-group" style="border: 2px dashed #e74c3c; padding: 15px; border-radius: 5px; background: #fef5f5;">
                        <label>ğŸ’‡â€â™€ï¸ ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ (í•„ìˆ˜) *</label>
                        <input type="file" class="hair-middle-image" accept="image/*" onchange="previewHairResourceImage(this, 'middle')">
                        <div class="hair-middle-preview">
                            ${middleHair ? `
                                <img src="${middleHair}" alt="í˜„ì¬ ì¤‘ê°„ë¨¸ë¦¬" 
                                     style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                                <br><small style="color: #666;">í˜„ì¬ ì¤‘ê°„ë¨¸ë¦¬</small>
                                <br><small style="color: #999;">ìƒˆ íŒŒì¼ ì„ íƒ ì‹œ êµì²´ë©ë‹ˆë‹¤</small>
                            ` : ''}
                        </div>
                    </div>
                    <div class="form-group hair-resource-group" style="border: 2px dashed #3498db; padding: 15px; border-radius: 5px; background: #f0f8ff;">
                        <label>ğŸ’‡â€â™€ï¸ ë’·ë¨¸ë¦¬ ì´ë¯¸ì§€ (ì„ íƒ)</label>
                        <input type="file" class="hair-back-image" accept="image/*" onchange="previewHairResourceImage(this, 'back')">
                        <div class="hair-back-preview">
                            ${backHair ? `
                                <img src="${backHair}" alt="í˜„ì¬ ë’·ë¨¸ë¦¬" 
                                     style="max-width: 60px; max-height: 60px; border-radius: 3px; border: 1px solid #ddd; margin-top: 5px;">
                                <br><small style="color: #666;">í˜„ì¬ ë’·ë¨¸ë¦¬</small>
                                <br><small style="color: #999;">ìƒˆ íŒŒì¼ ì„ íƒ ì‹œ êµì²´ë©ë‹ˆë‹¤</small>
                            ` : '<div style="color: #999; text-align: center; padding: 10px;"><div>í˜„ì¬ ë’·ë¨¸ë¦¬ ì—†ìŒ</div><small>íŒŒì¼ ì„ íƒ ì‹œ ì¶”ê°€ë©ë‹ˆë‹¤</small></div>'}
                        </div>
                        <small style="color: #666;">ì—†ìœ¼ë©´ ì¤‘ê°„ë¨¸ë¦¬ë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤</small>
                    </div>
                ` : '';

                colorOptionDiv.innerHTML = `
                    <div class="form-row">
                        <div class="form-group">
                            <label>ì»¬ëŸ¬ ì´ë¦„ *</label>
                            <input type="text" class="color-name" placeholder="ì˜ˆ: ë¹¨ê°•, íŒŒë‘" value="${colorOption.colorName}" required>
                        </div>
                        ${!isHairCategory ? `
                        <div class="form-group">
                            <label>ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ íŒŒì¼</label>
                            <input type="file" class="color-image" accept="image/*" onchange="previewColorImage(this)">
                            <div class="color-preview">
                                <img src="${colorOption.imageUrl}" alt="í˜„ì¬ ì´ë¯¸ì§€" class="color-option-preview">
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">í˜„ì¬ ì´ë¯¸ì§€ (ìƒˆ íŒŒì¼ì„ ì„ íƒí•˜ë©´ êµì²´ë©ë‹ˆë‹¤)</div>
                            </div>
                        </div>
                        ` : `
                        <div class="form-group" style="background: #fff3cd; padding: 10px; border-radius: 5px; border: 1px solid #ffeaa7;">
                            <div style="color: #856404; font-size: 14px;">
                                ğŸ’¡ <strong>Hair ì¹´í…Œê³ ë¦¬ ì•ˆë‚´:</strong><br>
                                ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ê°€ ê¸°ë³¸ ì´ë¯¸ì§€ë¡œ ìë™ ì„¤ì •ë©ë‹ˆë‹¤.<br>
                                ë³„ë„ì˜ ê¸°ë³¸ ì´ë¯¸ì§€ ì—…ë¡œë“œëŠ” ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
                            </div>
                        </div>
                        `}
                        <div class="form-group">
                            <label>ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (128x128)</label>
                            <input type="file" class="palette-image" accept="image/*" onchange="previewPaletteImage(this)">
                            <small>íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë¥¼ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ì´ë¯¸ì§€ë¥¼ ë™ê·¸ë—ê²Œ í‘œì‹œí•©ë‹ˆë‹¤.</small>
                            <div class="palette-preview-container">${palettePreview}</div>
                        </div>
                        
                        ${hairFields}
                        
                        <div class="form-group" style="width: auto;">
                            <button type="button" onclick="removeColorOption(${colorOptionIndex})" class="btn-danger" style="margin-top: 24px;">ì‚­ì œ</button>
                        </div>
                    </div>
                `;
                container.appendChild(colorOptionDiv);
            });
        }

        // ì¹´í…Œê³ ë¦¬ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';

            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ì˜µì…˜ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateOptionModal(categoryId) {
            document.getElementById('optionModalTitle').textContent = 'ğŸ­ ìƒˆ ìºë¦­í„° ì˜µì…˜ ì¶”ê°€';
            document.getElementById('optionForm').reset();
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = '';
            document.getElementById('thumbnailPreview').innerHTML = '';

            // ì»¬ëŸ¬ ì˜µì…˜ ì´ˆê¸°í™”
            const container = document.getElementById('colorOptionsContainer');
            container.innerHTML = '';
            colorOptionIndex = 0;
            addColorOption(); // ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ ì¶”ê°€

            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì˜µì…˜ ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function openEditOptionModal(categoryId, optionId, optionName) {
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.options) {
                alert('ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const option = category.options.find(opt => (opt._id || opt.id) === optionId);
            if (!option) {
                alert('ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            console.log(`ğŸ” openEditOptionModal - ì˜µì…˜ ë°ì´í„°:`, {
                optionName: option.name,
                categoryType: category.type,
                colorOptions: option.color,
                hasResourceImages: option.color?.some(c => c.resourceImages)
            });

            document.getElementById('optionModalTitle').textContent = `ğŸ­ ìºë¦­í„° ì˜µì…˜ ìˆ˜ì •: ${optionName}`;
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = optionId;
            document.getElementById('optionName').value = option.name;
            document.getElementById('optionOrder').value = option.order || 0;

            // ì»¬ëŸ¬ ì˜µì…˜ ë¡œë“œ
            loadColorOptions(option.color || []);

            // ì¸ë„¤ì¼ ë¯¸ë¦¬ë³´ê¸°
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            thumbnailPreview.innerHTML = option.thumbnailUrl ?
                `<img src="${option.thumbnailUrl}" alt="í˜„ì¬ ì¸ë„¤ì¼" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>í˜„ì¬ ì¸ë„¤ì¼ (${option.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'})</small>` :
                '<p>í˜„ì¬ ì¸ë„¤ì¼ ì—†ìŒ</p>';

            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì˜µì…˜ ëª¨ë‹¬ ë‹«ê¸°
        function closeOptionModal() {
            const modal = document.getElementById('optionModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ì¸ë„¤ì¼ ë¯¸ë¦¬ë³´ê¸° ì²˜ë¦¬
        document.getElementById('optionThumbnail').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');

            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="ì¸ë„¤ì¼ ë¯¸ë¦¬ë³´ê¸°" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // ì¹´í…Œê³ ë¦¬ í¼ ì œì¶œ
        document.getElementById('categoryForm').addEventListener('submit', async function (e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;

            // ì œì¶œ ë²„íŠ¼ ì°¾ê¸° ë° ë¹„í™œì„±í™”
            const submitBtn = e.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? 'ìˆ˜ì • ì¤‘...' : 'ì €ì¥ ì¤‘...';

            try {
                const formData = {
                    name: document.getElementById('categoryName').value,
                    type: document.getElementById('categoryType').value,
                    order: parseInt(document.getElementById('categoryOrder').value) || 0
                };

                const url = isEdit ?
                    `/api/admin/characters/categories/${categoryId}` :
                    '/api/admin/characters/categories';

                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì›
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // ì˜µì…˜ í¼ ì œì¶œ
        document.getElementById('optionForm').addEventListener('submit', async function (e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('optionCategoryId').value;
            const optionId = document.getElementById('optionId').value;
            const isEdit = !!optionId;
            const optionName = document.getElementById('optionName').value;

            // ì¹´í…Œê³ ë¦¬ íƒ€ì… í™•ì¸
            const category = categories.find(c => (c._id || c.id) === categoryId);
            const isHairCategory = category && category.type === 'hair';

            if (!optionName || optionName.trim() === '') {
                alert('ì˜µì…˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì»¬ëŸ¬ ì˜µì…˜ ìˆ˜ì§‘ ë° ê²€ì¦
            let colorOptions;
            try {
                colorOptions = collectColorOptions();
                if (colorOptions.length === 0) {
                    alert('ìµœì†Œ í•˜ë‚˜ì˜ ì»¬ëŸ¬ ì˜µì…˜ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }
            } catch (error) {
                alert(error.message);
                return;
            }

            // ì œì¶œ ë²„íŠ¼ ì°¾ê¸° ë° ë¹„í™œì„±í™”
            const submitBtn = document.getElementById('submitOptionBtn');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? 'ìˆ˜ì • ì¤‘...' : 'ì €ì¥ ì¤‘...';

            try {
                // ì´ë¯¸ì§€ ì—…ë¡œë“œ ë° ì»¬ëŸ¬ ì˜µì…˜ ì¤€ë¹„
                const uploadedColorOptions = [];
                for (let colorOption of colorOptions) {
                    if (isHairCategory && colorOption.hairMiddleFile) {
                        // Hair ì¹´í…Œê³ ë¦¬: ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ ì—…ë¡œë“œ
                        const imageFormData = new FormData();
                        imageFormData.append('file', colorOption.hairMiddleFile);

                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: imageFormData
                        });

                        if (uploadResponse.ok) {
                            const uploadData = await uploadResponse.json();
                            uploadedColorOptions.push({
                                colorName: colorOption.colorName,
                                imageUrl: uploadData.url, // ì¤‘ê°„ë¨¸ë¦¬ë¥¼ ê¸°ë³¸ ì´ë¯¸ì§€ë¡œ ì‚¬ìš©
                                paletteImageUrl: colorOption.paletteImageUrl || ''
                            });
                        } else {
                            throw new Error(`ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨: ${colorOption.colorName}`);
                        }
                    } else if (colorOption.imageFile) {
                        // ì¼ë°˜ ì¹´í…Œê³ ë¦¬: ìƒˆ ì´ë¯¸ì§€ ì—…ë¡œë“œ
                        const imageFormData = new FormData();
                        imageFormData.append('file', colorOption.imageFile);

                        const uploadResponse = await fetch('/api/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: imageFormData
                        });

                        if (uploadResponse.ok) {
                            const uploadData = await uploadResponse.json();
                            uploadedColorOptions.push({
                                colorName: colorOption.colorName,
                                imageUrl: uploadData.url,
                                paletteImageUrl: colorOption.paletteImageUrl || ''
                            });
                        } else {
                            throw new Error(`ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨: ${colorOption.colorName}`);
                        }
                    } else if (colorOption.imageUrl) {
                        // ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€
                        uploadedColorOptions.push({
                            colorName: colorOption.colorName,
                            imageUrl: colorOption.imageUrl,
                            paletteImageUrl: colorOption.paletteImageUrl || ''
                        });
                    }
                }

                console.log(`ğŸ” uploadedColorOptions ìƒì„± ì™„ë£Œ:`, uploadedColorOptions);

                // ì˜µì…˜ ë°ì´í„° ì¤€ë¹„
                const formData = new FormData();
                formData.append('name', optionName);
                formData.append('colorOptions', JSON.stringify(uploadedColorOptions));
                formData.append('order', document.getElementById('optionOrder').value);

                const thumbnailFile = document.getElementById('optionThumbnail').files[0];
                if (thumbnailFile) {
                    formData.append('thumbnail', thumbnailFile);
                }

                // íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë“¤ ë° hair íŒŒì¼ë“¤ ì¶”ê°€
                colorOptions.forEach((colorOption, index) => {
                    if (colorOption.paletteFile) {
                        formData.append('palette', colorOption.paletteFile);
                    }
                    
                    // Hair ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° ê° ì»¬ëŸ¬ë³„ hair íŒŒì¼ë“¤ ì¶”ê°€
                    if (isHairCategory) {
                        console.log(`ğŸ“¤ FormData ì¶”ê°€ - ì»¬ëŸ¬ ${index}:`, {
                            colorName: colorOption.colorName,
                            hasMiddleFile: !!colorOption.hairMiddleFile,
                            hasBackFile: !!colorOption.hairBackFile,
                            middleFileName: colorOption.hairMiddleFile?.name,
                            backFileName: colorOption.hairBackFile?.name
                        });
                        
                        if (colorOption.hairMiddleFile) {
                            formData.append(`hair_${index}_middle`, colorOption.hairMiddleFile);
                            console.log(`âœ… ì¤‘ê°„ë¨¸ë¦¬ íŒŒì¼ ì¶”ê°€: hair_${index}_middle`);
                        }
                        if (colorOption.hairBackFile) {
                            formData.append(`hair_${index}_back`, colorOption.hairBackFile);
                            console.log(`âœ… ë’·ë¨¸ë¦¬ íŒŒì¼ ì¶”ê°€: hair_${index}_back`);
                        }
                    }
                });

                const url = isEdit ?
                    `/api/admin/characters/categories/${categoryId}/options/${optionId}` :
                    `/api/admin/characters/categories/${categoryId}/options`;

                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ì˜µì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeOptionModal();
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì˜µì…˜ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì›
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // ì¹´í…Œê³ ë¦¬ ìˆ˜ì •
        function editCategory(categoryId) {
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);

            if (!category) {
                alert('ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ì¹´í…Œê³ ë¦¬ ìˆ˜ì •';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;

            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ì‚­ì œ
        async function deleteCategory(categoryId) {
            if (!confirm('ì •ë§ë¡œ ì´ ì¹´í…Œê³ ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ì˜µì…˜ë„ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    loadCategories();
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì˜µì…˜ ì‚­ì œ
        async function deleteOption(categoryId, optionId) {
            if (!confirm('ì •ë§ë¡œ ì´ ì˜µì…˜ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì˜µì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì˜µì…˜ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // íŠ¹ì • ì¹´í…Œê³ ë¦¬ì˜ ì˜µì…˜ë§Œ ì—…ë°ì´íŠ¸
        async function updateCategoryOptions(categoryId) {
            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        categories[categoryIndex] = data;

                        const optionsGrid = document.getElementById(`options-${categoryId}`);
                        if (optionsGrid) {
                            optionsGrid.innerHTML = renderOptions(data.options || [], categoryId);
                        }
                    }
                } else {
                    console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', data.message);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            }
        }

        // ì¸ë„¤ì¼ ì¬ìƒì„±
        async function regenerateThumbnail(categoryId, optionId) {
            if (!confirm('ì´ ì˜µì…˜ì˜ ì¸ë„¤ì¼ì„ ì¬ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}/thumbnail/regenerate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¸ë„¤ì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¬ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ì¸ë„¤ì¼ ì¬ìƒì„± ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¸ë„¤ì¼ ì¬ìƒì„± ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function (event) {
            const categoryModal = document.getElementById('categoryModal');
            const optionModal = document.getElementById('optionModal');

            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === optionModal) {
                closeOptionModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/avatar.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì•„ë°”íƒ€ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ - AR ëª…í•¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], input[type="color"], textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: 'â–¶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-options {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .option-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .option-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        .option-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .option-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .multi-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background-color: #fafafa;
        }

        .multi-upload-container.dragover {
            border-color: #007bff;
            background-color: #e3f2fd;
        }

        .file-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .file-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: white;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .file-preview {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-info {
            flex: 1;
        }

        .file-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .remove-file {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-file:hover {
            background-color: #c82333;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .batch-input {
            flex: 1;
            min-width: 150px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #28a745;
            transition: width 0.3s ease;
        }

        .upload-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¨ ì•„ë°”íƒ€ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ í˜ì´ì§€</h1>

        <!-- ì¸ì¦ ì„¹ì…˜ -->
        <div class="section auth-section">
            <h3>ğŸ” ê´€ë¦¬ì ì¸ì¦</h3>
            <p>ì•„ë°”íƒ€ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="ê´€ë¦¬ì JWT í† í° ì…ë ¥" style="width: 400px;">
                <button onclick="setAuthToken()">í† í° ì„¤ì •</button>
                <button onclick="getAdminToken()" class="btn-success">ê´€ë¦¬ì í† í° ìƒì„±</button>
                <button onclick="clearAuthToken()" class="btn-secondary">í† í° ì´ˆê¸°í™”</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- ì¹´í…Œê³ ë¦¬ ê´€ë¦¬ ì„¹ì…˜ -->
        <div class="section">
            <h3>ğŸ“ ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ê´€ë¦¬</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</button>
                <button onclick="loadCategories()" class="btn-secondary">ìƒˆë¡œê³ ì¹¨</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- ì¹´í…Œê³ ë¦¬ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">ì¹´í…Œê³ ë¦¬ ì´ë¦„ *</label>
                        <input type="text" id="categoryName" required placeholder="ì˜ˆ: ì–¼êµ´í˜•, ëˆˆ, ì½”, ì…">
                    </div>
                    
                    <div class="form-group">
                        <label for="categoryType">ì¹´í…Œê³ ë¦¬ íƒ€ì… *</label>
                        <input type="text" id="categoryType" required placeholder="ì˜ˆ: face, eyes, nose, mouth">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="categoryOrder">ìˆœì„œ</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ì•„ë°”íƒ€ ì˜µì…˜ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="optionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeOptionModal()">&times;</span>
            <h3 id="optionModalTitle">ğŸ­ ìƒˆ ì•„ë°”íƒ€ ì˜µì…˜ ì¶”ê°€</h3>
            <form id="optionForm" enctype="multipart/form-data">
                <input type="hidden" id="optionCategoryId">
                <input type="hidden" id="optionId">
                
                <!-- ë‹¨ì¼ ì˜µì…˜ ì¶”ê°€ ëª¨ë“œ -->
                <div id="singleOptionMode">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="optionName">ì˜µì…˜ ì´ë¦„ *</label>
                            <input type="text" id="optionName" required placeholder="ì˜ˆ: ë‘¥ê·¼ ì–¼êµ´, ë‚ ì¹´ë¡œìš´ ëˆˆ">
                        </div>
                        
                        <div class="form-group">
                            <label for="optionColor">ìƒ‰ìƒ</label>
                            <input type="color" id="optionColor" value="#000000">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="optionOrder">ìˆœì„œ</label>
                        <input type="number" id="optionOrder" min="0" value="0">
                    </div>
                    
                    <div class="form-group">
                        <label for="optionImage">ì•„ë°”íƒ€ ì´ë¯¸ì§€ * (512x512px ê¶Œì¥)</label>
                        <input type="file" id="optionImage" accept="image/*">
                        <div id="imagePreview"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="optionThumbnail">ì¸ë„¤ì¼ ì´ë¯¸ì§€ (300x300px ê¶Œì¥)</label>
                        <input type="file" id="optionThumbnail" accept="image/*">
                        <small>ì¸ë„¤ì¼ì„ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ ìë™ ìƒì„±ë©ë‹ˆë‹¤.</small>
                        <div id="thumbnailPreview"></div>
                    </div>
                </div>

                <!-- ë‹¤ì¤‘ ì˜µì…˜ ì¶”ê°€ ëª¨ë“œ -->
                <div id="multiOptionMode" style="display: none;">
                    <div class="form-group">
                        <label>ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)</label>
                        <div class="multi-upload-container" id="multiUploadContainer">
                            <p>ì—¬ê¸°ì— íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                            <input type="file" id="multiOptionImages" accept="image/*" multiple style="display: none;">
                            <button type="button" onclick="document.getElementById('multiOptionImages').click()" class="btn-success">íŒŒì¼ ì„ íƒ</button>
                        </div>
                    </div>

                    <!-- ì¼ê´„ ì„¤ì • -->
                    <div class="form-group">
                        <label>ì¼ê´„ ì„¤ì •</label>
                        <div class="batch-controls">
                            <input type="color" id="batchColor" value="#000000" class="batch-input" placeholder="ê³µí†µ ìƒ‰ìƒ">
                            <input type="number" id="batchOrderStart" min="0" value="0" class="batch-input" placeholder="ì‹œì‘ ìˆœì„œ">
                            <button type="button" onclick="applyBatchSettings()" class="btn-secondary">ì¼ê´„ ì ìš©</button>
                        </div>
                    </div>

                    <!-- íŒŒì¼ ëª©ë¡ -->
                    <div id="fileItemsContainer" class="file-items"></div>

                    <!-- ì—…ë¡œë“œ ì§„í–‰ë¥  -->
                    <div id="uploadProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="upload-status" id="uploadStatus"></div>
                    </div>
                </div>
                
                <!-- ëª¨ë“œ ì „í™˜ ë²„íŠ¼ -->
                <div style="text-align: center; margin: 20px 0;">
                    <button type="button" id="toggleModeBtn" onclick="toggleUploadMode()" class="btn-secondary">ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ</button>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeOptionModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success" id="submitOptionBtn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let isMultiMode = false;
        let selectedFiles = [];
        let uploadProgress = 0;
        let expandedCategories = new Set(); // ì—´ë¦° ì¹´í…Œê³ ë¦¬ ìƒíƒœ ì¶”ì 

        // ì¸ì¦ í† í° ì„¤ì •
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', 'í† í°ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', 'âœ… ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // í† í° ì„¤ì • í›„ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìë™ ë¡œë“œ
            loadCategories();
        }

        // ê´€ë¦¬ì í† í° ìƒì„±
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', 'ê´€ë¦¬ì í† í°ì„ ìƒì„±í•˜ëŠ” ì¤‘...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `âœ… ê´€ë¦¬ì í† í°ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìš©ì: ${data.user.nameKr})`);
                    
                    // í† í° ìƒì„± í›„ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìë™ ë¡œë“œ
                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `âŒ í† í° ìƒì„± ì‹¤íŒ¨: ${data.message || 'ê´€ë¦¬ì ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}`);
                }

            } catch (error) {
                console.error('í† í° ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('authStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // í† í° ì´ˆê¸°í™”
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', 'ğŸ”„ í† í°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìˆ¨ê¸°ê¸°
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í† í° ë³µì›
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', 'âœ… ì €ì¥ëœ í† í°ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                loadCategories();
            }

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ì„¤ì •
            setupDragAndDrop();
        });

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', 'âŒ ë¨¼ì € ê´€ë¦¬ì í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `âœ… ${categories.length}ê°œì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    showStatus('categoryStatus', 'error', `âŒ ${data.message || 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨'}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('categoryStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>ë“±ë¡ëœ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            categories.forEach(category => {
                // ID í•„ë“œ í™•ì¸ - _id ë˜ëŠ” id ì‚¬ìš©
                const categoryId = category._id || category.id;
                console.log('Category object:', category);
                console.log('Category ID:', categoryId);
                
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateOptionModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">ì˜µì…˜ ì¶”ê°€</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">ìˆ˜ì •</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">ì‚­ì œ</button>
                        </div>
                    </div>
                    <div class="category-options">
                        <p><strong>ì˜µì…˜ ìˆ˜:</strong> ${category.options ? category.options.length : 0}ê°œ</p>
                        <div class="options-grid" id="options-${categoryId}">
                            ${renderOptions(category.options || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');
            
            card.classList.toggle('collapsed');
            
            // ìƒíƒœ ì¶”ì 
            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // ì˜µì…˜ ë Œë”ë§
        function renderOptions(options, categoryId) {
            if (!options || options.length === 0) {
                return '<p>ë“±ë¡ëœ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                return `
                    <div class="option-card">
                        <div class="option-image-container">
                            ${option.thumbnailUrl ? `<img src="${option.thumbnailUrl}" alt="${option.name}" class="option-image">` : '<div class="option-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">ì¸ë„¤ì¼ ì—†ìŒ</div>'}
                        </div>
                        <div class="option-name">${option.name}</div>
                        <div class="thumbnail-source">ì¸ë„¤ì¼: ${option.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'}</div>
                        <div class="option-actions">
                            <button onclick="openEditOptionModal('${categoryId}', '${optionId}', '${option.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">ìˆ˜ì •</button>
                            <button onclick="deleteOption('${categoryId}', '${optionId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">ì‚­ì œ</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${optionId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">ì¸ë„¤ì¼ ì¬ìƒì„±</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ì—…ë¡œë“œ ëª¨ë“œ ì „í™˜
        function toggleUploadMode() {
            isMultiMode = !isMultiMode;
            const singleMode = document.getElementById('singleOptionMode');
            const multiMode = document.getElementById('multiOptionMode');
            const toggleBtn = document.getElementById('toggleModeBtn');
            const submitBtn = document.getElementById('submitOptionBtn');

            // ë‹¨ì¼ ëª¨ë“œì˜ í•„ìˆ˜ ì…ë ¥ í•„ë“œë“¤
            const singleModeRequiredFields = [
                document.getElementById('optionName'),
                document.getElementById('optionImage')
            ];

            if (isMultiMode) {
                singleMode.style.display = 'none';
                multiMode.style.display = 'block';
                toggleBtn.textContent = 'ë‹¨ì¼ ì—…ë¡œë“œ ëª¨ë“œ';
                submitBtn.textContent = 'ì¼ê´„ ì—…ë¡œë“œ';
                
                // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ì œê±°
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.removeAttribute('required');
                    }
                });
            } else {
                singleMode.style.display = 'block';
                multiMode.style.display = 'none';
                toggleBtn.textContent = 'ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ';
                submitBtn.textContent = 'ì €ì¥';
                
                // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ë³µì›
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.setAttribute('required', 'required');
                    }
                });
                
                // ì„ íƒëœ íŒŒì¼ë“¤ ì´ˆê¸°í™”
                selectedFiles = [];
                document.getElementById('fileItemsContainer').innerHTML = '';
            }
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
        function setupDragAndDrop() {
            const container = document.getElementById('multiUploadContainer');
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.classList.add('dragover');
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                addFiles(files);
            });

            container.addEventListener('click', () => {
                document.getElementById('multiOptionImages').click();
            });

            document.getElementById('multiOptionImages').addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                addFiles(files);
            });
        }

        // íŒŒì¼ ì¶”ê°€
        function addFiles(files) {
            files.forEach(file => {
                const fileId = Date.now() + Math.random();
                const fileData = {
                    id: fileId,
                    file: file,
                    name: file.name.replace(/\.[^/.]+$/, ""), // í™•ì¥ì ì œê±°
                    color: '#000000',
                    order: selectedFiles.length,
                    thumbnailFile: null
                };
                
                selectedFiles.push(fileData);
            });
            
            renderFileItems();
        }

        // íŒŒì¼ ì•„ì´í…œ ë Œë”ë§
        function renderFileItems() {
            const container = document.getElementById('fileItemsContainer');
            container.innerHTML = '';

            selectedFiles.forEach(fileData => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <img src="${URL.createObjectURL(fileData.file)}" alt="ë¯¸ë¦¬ë³´ê¸°" class="file-preview">
                    <div class="file-info">
                        <div class="form-group">
                            <label>ì˜µì…˜ ì´ë¦„</label>
                            <input type="text" value="${fileData.name}" onchange="updateFileName(${fileData.id}, this.value)">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>ìƒ‰ìƒ</label>
                                <input type="color" value="${fileData.color}" onchange="updateFileColor(${fileData.id}, this.value)">
                            </div>
                            <div class="form-group">
                                <label>ìˆœì„œ</label>
                                <input type="number" value="${fileData.order}" min="0" onchange="updateFileOrder(${fileData.id}, this.value)">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>ì¸ë„¤ì¼ (ì„ íƒì‚¬í•­)</label>
                            <input type="file" accept="image/*" onchange="updateFileThumbnail(${fileData.id}, this.files[0])">
                        </div>
                    </div>
                    <div class="file-actions">
                        <button type="button" class="remove-file" onclick="removeFile(${fileData.id})">ì‚­ì œ</button>
                    </div>
                `;
                container.appendChild(fileItem);
            });
        }

        // íŒŒì¼ ì •ë³´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
        function updateFileName(fileId, name) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.name = name;
        }

        function updateFileColor(fileId, color) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.color = color;
        }

        function updateFileOrder(fileId, order) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.order = parseInt(order);
        }

        function updateFileThumbnail(fileId, thumbnailFile) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.thumbnailFile = thumbnailFile;
        }

        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(f => f.id !== fileId);
            renderFileItems();
        }

        // ì¼ê´„ ì„¤ì • ì ìš©
        function applyBatchSettings() {
            const batchColor = document.getElementById('batchColor').value;
            const batchOrderStart = parseInt(document.getElementById('batchOrderStart').value) || 0;

            selectedFiles.forEach((fileData, index) => {
                fileData.color = batchColor;
                fileData.order = batchOrderStart + index;
            });

            renderFileItems();
        }

        // ì¹´í…Œê³ ë¦¬ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ì˜µì…˜ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateOptionModal(categoryId) {
            document.getElementById('optionModalTitle').textContent = 'ğŸ­ ìƒˆ ì•„ë°”íƒ€ ì˜µì…˜ ì¶”ê°€';
            document.getElementById('optionForm').reset();
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = '';
            document.getElementById('imagePreview').innerHTML = '';
            document.getElementById('thumbnailPreview').innerHTML = '';
            
            // ëª¨ë“œ ì´ˆê¸°í™” - ë‹¨ì¼ ëª¨ë“œë¡œ ì‹œì‘
            isMultiMode = false;
            document.getElementById('singleOptionMode').style.display = 'block';
            document.getElementById('multiOptionMode').style.display = 'none';
            document.getElementById('toggleModeBtn').textContent = 'ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ';
            document.getElementById('submitOptionBtn').textContent = 'ì €ì¥';
            
            // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ë³µì›
            const optionNameField = document.getElementById('optionName');
            const optionImageField = document.getElementById('optionImage');
            if (optionNameField) optionNameField.setAttribute('required', 'required');
            if (optionImageField) optionImageField.setAttribute('required', 'required');
            
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
            
            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì˜µì…˜ ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function openEditOptionModal(categoryId, optionId, optionName) {
            // ì˜µì…˜ ì •ë³´ë¥¼ ì°¾ê¸° ìœ„í•´ ì¹´í…Œê³ ë¦¬ì—ì„œ ì˜µì…˜ ì°¾ê¸°
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.options) {
                alert('ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const option = category.options.find(opt => (opt._id || opt.id) === optionId);
            if (!option) {
                alert('ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            document.getElementById('optionModalTitle').textContent = `ğŸ­ ì•„ë°”íƒ€ ì˜µì…˜ ìˆ˜ì •: ${optionName}`;
            document.getElementById('optionCategoryId').value = categoryId;
            document.getElementById('optionId').value = optionId;
            document.getElementById('optionName').value = option.name;
            document.getElementById('optionColor').value = option.color || '#000000';
            document.getElementById('optionOrder').value = option.order || 0;
            
            // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ë‹¨ì¼ ëª¨ë“œë§Œ ì‚¬ìš©
            isMultiMode = false;
            document.getElementById('singleOptionMode').style.display = 'block';
            document.getElementById('multiOptionMode').style.display = 'none';
            document.getElementById('toggleModeBtn').style.display = 'none'; // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ëª¨ë“œ ì „í™˜ ìˆ¨ê¹€
            document.getElementById('submitOptionBtn').textContent = 'ì €ì¥';
            
            // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ì´ë¯¸ì§€ê°€ í•„ìˆ˜ê°€ ì•„ë‹˜ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ ê°€ëŠ¥)
            const optionNameField = document.getElementById('optionName');
            const optionImageField = document.getElementById('optionImage');
            if (optionNameField) optionNameField.setAttribute('required', 'required');
            if (optionImageField) optionImageField.removeAttribute('required');
            
            // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
            const imagePreview = document.getElementById('imagePreview');
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            
            imagePreview.innerHTML = option.imageUrl ? 
                `<img src="${option.imageUrl}" alt="í˜„ì¬ ì´ë¯¸ì§€" class="image-preview">` : 
                '<p>í˜„ì¬ ì´ë¯¸ì§€ ì—†ìŒ</p>';
                
            thumbnailPreview.innerHTML = option.thumbnailUrl ? 
                `<img src="${option.thumbnailUrl}" alt="í˜„ì¬ ì¸ë„¤ì¼" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>í˜„ì¬ ì¸ë„¤ì¼ (${option.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'})</small>` : 
                '<p>í˜„ì¬ ì¸ë„¤ì¼ ì—†ìŒ</p>';
            
            const modal = document.getElementById('optionModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì˜µì…˜ ëª¨ë‹¬ ë‹«ê¸°
        function closeOptionModal() {
            const modal = document.getElementById('optionModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            
            // ëª¨ë“œ ì „í™˜ ë²„íŠ¼ ë‹¤ì‹œ í‘œì‹œ
            document.getElementById('toggleModeBtn').style.display = 'inline-block';
            
            // ì„ íƒëœ íŒŒì¼ë“¤ ì´ˆê¸°í™”
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
        }

        // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ì²˜ë¦¬
        document.getElementById('optionImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('imagePreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°" class="image-preview">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        document.getElementById('optionThumbnail').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="ì¸ë„¤ì¼ ë¯¸ë¦¬ë³´ê¸°" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('uploadStatus').textContent = `${current}/${total} ì—…ë¡œë“œ ì¤‘...`;
        }

        // ì¹´í…Œê³ ë¦¬ í¼ ì œì¶œ
        document.getElementById('categoryForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;
            
            const formData = {
                name: document.getElementById('categoryName').value,
                type: document.getElementById('categoryType').value,
                order: parseInt(document.getElementById('categoryOrder').value) || 0
            };

            try {
                const url = isEdit ? 
                    `/api/admin/characters/categories/${categoryId}` : 
                    '/api/admin/characters/categories';
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        });

        // ì˜µì…˜ í¼ ì œì¶œ
        document.getElementById('optionForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('optionCategoryId').value;
            const optionId = document.getElementById('optionId').value;
            const isEdit = !!optionId;

            if (isMultiMode && !isEdit) {
                // ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ - íŒŒì¼ ì„ íƒ ê²€ì¦
                if (selectedFiles.length === 0) {
                    alert('ì—…ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                // íŒŒì¼ë³„ ì´ë¦„ ê²€ì¦
                for (let fileData of selectedFiles) {
                    if (!fileData.name || fileData.name.trim() === '') {
                        alert('ëª¨ë“  íŒŒì¼ì˜ ì˜µì…˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                        return;
                    }
                }
                
                await handleMultipleUpload(categoryId);
            } else {
                // ë‹¨ì¼ ì—…ë¡œë“œ ëª¨ë“œ - ê¸°ì¡´ ê²€ì¦ ë¡œì§
                const optionName = document.getElementById('optionName').value;
                const imageFile = document.getElementById('optionImage').files[0];
                
                if (!optionName || optionName.trim() === '') {
                    alert('ì˜µì…˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (!isEdit && !imageFile) {
                    alert('ìƒˆ ì˜µì…˜ì„ ì¶”ê°€í•  ë•ŒëŠ” ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }
                
                await handleSingleUpload(categoryId, optionId, isEdit);
            }
        });

        // ë‹¨ì¼ ì—…ë¡œë“œ ì²˜ë¦¬
        async function handleSingleUpload(categoryId, optionId, isEdit) {
            const formData = new FormData();
            formData.append('name', document.getElementById('optionName').value);
            formData.append('color', document.getElementById('optionColor').value);
            formData.append('order', document.getElementById('optionOrder').value);

            const imageFile = document.getElementById('optionImage').files[0];
            const thumbnailFile = document.getElementById('optionThumbnail').files[0];

            if (!isEdit && !imageFile) {
                alert('ìƒˆ ì˜µì…˜ì„ ì¶”ê°€í•  ë•ŒëŠ” ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            if (imageFile) {
                formData.append('image', imageFile);
            }

            if (thumbnailFile) {
                formData.append('thumbnail', thumbnailFile);
            }

            try {
                const url = isEdit ? 
                    `/api/admin/characters/categories/${categoryId}/options/${optionId}` : 
                    `/api/admin/characters/categories/${categoryId}/options`;
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ì˜µì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeOptionModal();
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì˜µì…˜ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ë‹¤ì¤‘ ì—…ë¡œë“œ ì²˜ë¦¬
        async function handleMultipleUpload(categoryId) {
            if (selectedFiles.length === 0) {
                alert('ì—…ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const progressContainer = document.getElementById('uploadProgress');
            progressContainer.style.display = 'block';
            
            let successCount = 0;
            let failCount = 0;

            for (let i = 0; i < selectedFiles.length; i++) {
                const fileData = selectedFiles[i];
                updateProgress(i + 1, selectedFiles.length);

                const formData = new FormData();
                formData.append('name', fileData.name);
                formData.append('color', fileData.color);
                formData.append('order', fileData.order.toString());
                formData.append('image', fileData.file);
                
                if (fileData.thumbnailFile) {
                    formData.append('thumbnail', fileData.thumbnailFile);
                }

                try {
                    const response = await fetch(`/api/admin/characters/categories/${categoryId}/options`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${currentToken}`
                        },
                        body: formData
                    });

                    if (response.ok) {
                        successCount++;
                    } else {
                        failCount++;
                        console.error(`íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨: ${fileData.name}`);
                    }

                } catch (error) {
                    failCount++;
                    console.error(`íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜: ${fileData.name}`, error);
                }
            }

            progressContainer.style.display = 'none';
            
            if (successCount > 0) {
                alert(`âœ… ${successCount}ê°œì˜ ì˜µì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.${failCount > 0 ? ` (ì‹¤íŒ¨: ${failCount}ê°œ)` : ''}`);
                closeOptionModal();
                // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                await updateCategoryOptions(categoryId);
            } else {
                alert(`âŒ ëª¨ë“  ì—…ë¡œë“œê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
            }
        }

        // ì¹´í…Œê³ ë¦¬ ìˆ˜ì •
        function editCategory(categoryId) {
            console.log('editCategory called with categoryId:', categoryId);
            console.log('Available categories:', categories);
            
            // _id ë˜ëŠ” id í•„ë“œë¡œ ì¹´í…Œê³ ë¦¬ ì°¾ê¸°
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);
            console.log('Found category:', category);
            
            if (!category) {
                console.error('Category not found with ID:', categoryId);
                console.error('Available category IDs:', categories.map(c => c._id || c.id));
                alert('ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ì¹´í…Œê³ ë¦¬ ìˆ˜ì •';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ì‚­ì œ
        async function deleteCategory(categoryId) {
            console.log('deleteCategory called with categoryId:', categoryId);
            
            if (!confirm('ì •ë§ë¡œ ì´ ì¹´í…Œê³ ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ì˜µì…˜ë„ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    loadCategories();
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì˜µì…˜ ì‚­ì œ
        async function deleteOption(categoryId, optionId) {
            if (!confirm('ì •ë§ë¡œ ì´ ì˜µì…˜ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì˜µì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì˜µì…˜ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // íŠ¹ì • ì¹´í…Œê³ ë¦¬ì˜ ì˜µì…˜ë§Œ ì—…ë°ì´íŠ¸
        async function updateCategoryOptions(categoryId) {
            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    // ì „ì²´ categories ë°°ì—´ì—ì„œ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        // API ì‘ë‹µì´ ì§ì ‘ ì¹´í…Œê³ ë¦¬ ê°ì²´ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ dataë¥¼ ì‚¬ìš©
                        categories[categoryIndex] = data;
                        
                        // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì˜µì…˜ ê·¸ë¦¬ë“œë§Œ ì—…ë°ì´íŠ¸
                        const optionsGrid = document.getElementById(`options-${categoryId}`);
                        if (optionsGrid) {
                            optionsGrid.innerHTML = renderOptions(data.options || [], categoryId);
                        }
                    }
                } else {
                    console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', data.message);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            }
        }

        // ì¸ë„¤ì¼ ì¬ìƒì„±
        async function regenerateThumbnail(categoryId, optionId) {
            if (!confirm('ì´ ì˜µì…˜ì˜ ì¸ë„¤ì¼ì„ ì¬ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/characters/categories/${categoryId}/options/${optionId}/thumbnail/regenerate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¸ë„¤ì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¬ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryOptions(categoryId);
                } else {
                    alert(`âŒ ì¸ë„¤ì¼ ì¬ìƒì„± ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¸ë„¤ì¼ ì¬ìƒì„± ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            const categoryModal = document.getElementById('categoryModal');
            const optionModal = document.getElementById('optionModal');
            
            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === optionModal) {
                closeOptionModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/cors-test.html">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS í…ŒìŠ¤íŠ¸ í˜ì´ì§€</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #007bff;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        input[type="text"] {
            width: 300px;
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .network-info {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ CORS í…ŒìŠ¤íŠ¸ í˜ì´ì§€</h1>
        
        <div class="network-info">
            <h3>ğŸ“ í˜„ì¬ ì ‘ì† ì •ë³´</h3>
            <p><strong>í˜„ì¬ URL:</strong> <span id="currentUrl"></span></p>
            <p><strong>User Agent:</strong> <span id="userAgent"></span></p>
        </div>

        <div class="test-section">
            <h3>ğŸ”§ ì„œë²„ ì„¤ì •</h3>
            <label>API ì„œë²„ ì£¼ì†Œ:</label>
            <input type="text" id="serverUrl" value="http://192.168.2.20:3000" placeholder="http://ip:port">
            <button onclick="updateServerUrl()">ì„¤ì • ì ìš©</button>
        </div>

        <div class="test-section">
            <h3>ğŸ¥ ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸</h3>
            <button onclick="testBasicConnection()">ì—°ê²° í…ŒìŠ¤íŠ¸</button>
            <div id="connectionResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ” ì¸ì¦ í…ŒìŠ¤íŠ¸</h3>
            <button onclick="testAuthEndpoint()">ì¸ì¦ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸</button>
            <div id="authResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ‘¤ ì‚¬ìš©ì API í…ŒìŠ¤íŠ¸</h3>
            <button onclick="testUserAPI()">ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ</button>
            <div id="userResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ­ ì•„ë°”íƒ€ API í…ŒìŠ¤íŠ¸</h3>
            <button onclick="testAvatarAPI()">ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ</button>
            <div id="avatarResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ¯ ì•„ì´í…œ API í…ŒìŠ¤íŠ¸</h3>
            <button onclick="testItemAPI()">ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ</button>
            <div id="itemResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š ì „ì²´ í…ŒìŠ¤íŠ¸</h3>
            <button onclick="runAllTests()">ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰</button>
            <div id="allTestsResult" class="result"></div>
        </div>
    </div>

    <script>
        let serverUrl = 'http://192.168.2.20:3000';

        // í˜ì´ì§€ ë¡œë“œ ì‹œ í˜„ì¬ ì •ë³´ í‘œì‹œ
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('currentUrl').textContent = window.location.href;
            document.getElementById('userAgent').textContent = navigator.userAgent;
        });

        function updateServerUrl() {
            const input = document.getElementById('serverUrl');
            serverUrl = input.value.replace(/\/$/, ''); // ëì˜ ìŠ¬ë˜ì‹œ ì œê±°
            showResult('connectionResult', `ì„œë²„ ì£¼ì†Œê°€ ${serverUrl}ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${type}`;
        }

        async function testBasicConnection() {
            showResult('connectionResult', 'ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/health`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('connectionResult', 
                        `âœ… ì—°ê²° ì„±ê³µ!\nìƒíƒœ: ${response.status}\nì‘ë‹µ: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    showResult('connectionResult', 
                        `âš ï¸ ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜\nìƒíƒœ: ${response.status}\në©”ì‹œì§€: ${response.statusText}`, 
                        'error');
                }
            } catch (error) {
                showResult('connectionResult', 
                    `âŒ ì—°ê²° ì‹¤íŒ¨\nì˜¤ë¥˜: ${error.message}\n\nê°€ëŠ¥í•œ ì›ì¸:\n- ì„œë²„ê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ\n- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œ\n- CORS ì •ì±… ì°¨ë‹¨`, 
                    'error');
            }
        }

        async function testAuthEndpoint() {
            showResult('authResult', 'ì¸ì¦ í…ŒìŠ¤íŠ¸ ì¤‘...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/auth/test`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.text();
                showResult('authResult', 
                    `ìƒíƒœ: ${response.status}\nì‘ë‹µ: ${data}`, 
                    response.ok ? 'success' : 'error');
            } catch (error) {
                showResult('authResult', 
                    `âŒ ì¸ì¦ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨\nì˜¤ë¥˜: ${error.message}`, 
                    'error');
            }
        }

        async function testUserAPI() {
            showResult('userResult', 'ì‚¬ìš©ì API í…ŒìŠ¤íŠ¸ ì¤‘...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/users`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('userResult', 
                        `âœ… ì‚¬ìš©ì API ì„±ê³µ!\nì‚¬ìš©ì ìˆ˜: ${data.length || 0}\nì‘ë‹µ: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('userResult', 
                        `âš ï¸ ì‚¬ìš©ì API ì˜¤ë¥˜\nìƒíƒœ: ${response.status}\nì‘ë‹µ: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('userResult', 
                    `âŒ ì‚¬ìš©ì API ì‹¤íŒ¨\nì˜¤ë¥˜: ${error.message}`, 
                    'error');
            }
        }

        async function testAvatarAPI() {
            showResult('avatarResult', 'ì•„ë°”íƒ€ API í…ŒìŠ¤íŠ¸ ì¤‘...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/avatars/categories`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('avatarResult', 
                        `âœ… ì•„ë°”íƒ€ API ì„±ê³µ!\nì¹´í…Œê³ ë¦¬ ìˆ˜: ${data.length || 0}\nì‘ë‹µ: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('avatarResult', 
                        `âš ï¸ ì•„ë°”íƒ€ API ì˜¤ë¥˜\nìƒíƒœ: ${response.status}\nì‘ë‹µ: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('avatarResult', 
                    `âŒ ì•„ë°”íƒ€ API ì‹¤íŒ¨\nì˜¤ë¥˜: ${error.message}`, 
                    'error');
            }
        }

        async function testItemAPI() {
            showResult('itemResult', 'ì•„ì´í…œ API í…ŒìŠ¤íŠ¸ ì¤‘...', 'info');
            
            try {
                const response = await fetch(`${serverUrl}/api/stickers`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showResult('itemResult', 
                        `âœ… ì•„ì´í…œ API ì„±ê³µ!\nì¹´í…Œê³ ë¦¬ ìˆ˜: ${data.length || 0}\nì‘ë‹µ: ${JSON.stringify(data.slice(0, 2), null, 2)}${data.length > 2 ? '\n...' : ''}`, 
                        'success');
                } else {
                    const errorData = await response.text();
                    showResult('itemResult', 
                        `âš ï¸ ì•„ì´í…œ API ì˜¤ë¥˜\nìƒíƒœ: ${response.status}\nì‘ë‹µ: ${errorData}`, 
                        'error');
                }
            } catch (error) {
                showResult('itemResult', 
                    `âŒ ì•„ì´í…œ API ì‹¤íŒ¨\nì˜¤ë¥˜: ${error.message}`, 
                    'error');
            }
        }

        async function runAllTests() {
            showResult('allTestsResult', 'ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...', 'info');
            
            const tests = [
                { name: 'ê¸°ë³¸ ì—°ê²°', func: testBasicConnection },
                { name: 'ì¸ì¦', func: testAuthEndpoint },
                { name: 'ì‚¬ìš©ì API', func: testUserAPI },
                { name: 'ì•„ë°”íƒ€ API', func: testAvatarAPI },
                { name: 'ì•„ì´í…œ API', func: testItemAPI }
            ];
            
            let results = [];
            
            for (const test of tests) {
                try {
                    await test.func();
                    results.push(`âœ… ${test.name}: ì„±ê³µ`);
                } catch (error) {
                    results.push(`âŒ ${test.name}: ì‹¤íŒ¨ - ${error.message}`);
                }
                
                // ê° í…ŒìŠ¤íŠ¸ ê°„ ì ì‹œ ëŒ€ê¸°
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            showResult('allTestsResult', 
                `ì „ì²´ í…ŒìŠ¤íŠ¸ ì™„ë£Œ\n\n${results.join('\n')}`, 
                'info');
        }
    </script>
</body>
</html>
</file>

<file path="public/test/customize.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì•„ë°”íƒ€ ì»¤ìŠ¤í„°ë§ˆì´ì§• - AR ëª…í•¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: block;
            padding: 30px;
            padding-right: 430px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .right-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            position: fixed;
            top: 20px;
            right: 20px;
            width: 380px;
            height: fit-content;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 1000;
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
        }

        /* ì¸ì¦ ì„¹ì…˜ */
        .auth-section {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
        }

        .auth-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .auth-controls input {
            flex: 1;
            min-width: 300px;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .auth-controls input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .status {
            padding: 12px 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e17055 0%, #d63031 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #636e72 0%, #2d3436 100%);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ì•„ë°”íƒ€ ì„ íƒ ì˜ì—­ */
        .avatar-categories {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .avatar-category {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .avatar-category.selected {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #495057;
        }

        .category-selection {
            font-size: 0.9em;
            color: #667eea;
            font-weight: 500;
        }

        .avatar-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
        }

        .avatar-option {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 12px;
            overflow: hidden;
        }

        .avatar-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .avatar-option.selected {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .avatar-option.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 5px;
            right: 5px;
            background: #667eea;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .avatar-option img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 12px;
        }

        .avatar-option-name {
            text-align: center;
            font-size: 0.8em;
            margin-top: 5px;
            color: #495057;
            font-weight: 500;
        }

        /* ì•„ì´í…œ ì„ íƒ ì˜ì—­ */
        .item-categories {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .item-category {
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
        }

        .item-category.role-category {
            border-color: #e17055;
            background: #fff8f6;
        }

        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
        }

        .item-card {
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .item-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .item-card img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .item-card-name {
            padding: 8px;
            text-align: center;
            font-size: 0.8em;
            color: #495057;
            font-weight: 500;
        }

        /* ìŠ¬ë¡¯ ì‹œìŠ¤í…œ */
        .item-slots {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .item-slot {
            width: 100px;
            height: 100px;
            border: 3px dashed #dee2e6;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
            background: #f8f9fa;
        }

        .item-slot.role-slot {
            border-color: #e17055;
            background: #fff8f6;
        }

        .item-slot.dragover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: scale(1.05);
        }

        .item-slot.filled {
            border-color: #00b894;
            border-style: solid;
            background: white;
        }

        .item-slot-label {
            font-size: 0.7em;
            color: #6c757d;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .item-slot-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .item-slot img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
        }

        .item-slot-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e17055;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
        }

        .item-slot.filled:hover .item-slot-remove {
            display: block;
        }

        /* ë©”ì‹œì§€ ì…ë ¥ */
        .message-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            resize: none;
            font-family: inherit;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .message-counter {
            text-align: right;
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        /* ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ */
        .preview-section {
            text-align: center;
        }

        .preview-canvas {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            background: #f8f9fa;
            margin-bottom: 20px;
            max-width: 100%;
        }

        .preview-placeholder {
            width: 350px;
            height: 350px;
            border: 3px dashed #dee2e6;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 1.1em;
            margin: 0 auto 20px;
        }

        .selected-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .selected-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .selected-item img {
            width: 30px;
            height: 30px;
            object-fit: cover;
            border-radius: 4px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .right-panel {
                position: static;
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
                padding-right: 20px;
            }
            
            .right-panel {
                position: static;
                width: 100%;
                max-height: none;
                margin-top: 30px;
                right: auto;
                top: auto;
            }
            
            .auth-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .auth-controls input {
                min-width: auto;
            }
            
            .item-slots {
                flex-wrap: wrap;
            }
            
            .avatar-options {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            }
            
            .item-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ ì•„ë°”íƒ€ ì»¤ìŠ¤í„°ë§ˆì´ì§•</h1>
            <p>ë‚˜ë§Œì˜ ì•„ë°”íƒ€ì™€ ì•„ì´í…œì„ ì„ íƒí•˜ì—¬ ê°œì„± ë„˜ì¹˜ëŠ” ëª…í•¨ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”</p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <!-- ì¸ì¦ ì„¹ì…˜ -->
                <div class="section auth-section">
                    <div class="section-title">ğŸ” ì‚¬ìš©ì ì¸ì¦</div>
                    <p style="margin-bottom: 15px;">ì»¤ìŠ¤í„°ë§ˆì´ì§• ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
                    <div class="auth-controls">
                        <input type="text" id="userToken" placeholder="ì‚¬ìš©ì JWT í† í° ì…ë ¥">
                        <button class="btn btn-primary" onclick="setUserToken()">í† í° ì„¤ì •</button>
                        <button class="btn btn-success" onclick="getUserToken()">í…ŒìŠ¤íŠ¸ í† í° ìƒì„±</button>
                        <button class="btn btn-secondary" onclick="clearUserToken()">í† í° ì´ˆê¸°í™”</button>
                    </div>
                    <div id="authStatus"></div>
                </div>

                <!-- ì•„ë°”íƒ€ ì„ íƒ ì„¹ì…˜ -->
                <div class="section">
                    <div class="section-title">ğŸ‘¤ ì•„ë°”íƒ€ ì„ íƒ</div>
                    <div id="avatarStatus"></div>
                    <div id="avatarCategories" class="avatar-categories"></div>
                </div>

                <!-- ì—­í•  ì•„ì´í…œ ì„ íƒ ì„¹ì…˜ -->
                <div class="section">
                    <div class="section-title">ğŸ’¼ ì—­í•  ì„ íƒ</div>
                    <div id="roleStatus"></div>
                    <div id="roleSlot" class="item-slots">
                        <div class="item-slot role-slot" data-slot="role">
                            <div class="item-slot-label">ì—­í• </div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">ì—­í• ì„ ì„ íƒí•˜ì„¸ìš”</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('role')">Ã—</button>
                        </div>
                    </div>
                    <div id="roleCategory" class="item-category role-category"></div>
                </div>

                <!-- ì¼ë°˜ ì•„ì´í…œ ì„ íƒ ì„¹ì…˜ -->
                <div class="section">
                    <div class="section-title">ğŸ® ì•„ì´í…œ ì„ íƒ</div>
                    <div id="itemStatus"></div>
                    <div class="item-slots">
                        <div class="item-slot" data-slot="item1">
                            <div class="item-slot-label">ì•„ì´í…œ 1</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item1')">Ã—</button>
                        </div>
                        <div class="item-slot" data-slot="item2">
                            <div class="item-slot-label">ì•„ì´í…œ 2</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item2')">Ã—</button>
                        </div>
                        <div class="item-slot" data-slot="item3">
                            <div class="item-slot-label">ì•„ì´í…œ 3</div>
                            <div class="item-slot-content">
                                <span style="font-size: 0.8em; color: #6c757d;">ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”</span>
                            </div>
                            <button class="item-slot-remove" onclick="removeFromSlot('item3')">Ã—</button>
                        </div>
                    </div>
                    <div id="itemCategories" class="item-categories"></div>
                </div>

                <!-- ë©”ì‹œì§€ ì…ë ¥ ì„¹ì…˜ -->
                <div class="section">
                    <div class="section-title">ğŸ’¬ í•œì¤„ ë©”ì‹œì§€</div>
                    <textarea id="userMessage" class="message-input" placeholder="í•˜ê³  ì‹¶ì€ ë§ì„ í•œ ì¤„ë¡œ ì ì–´ì£¼ì„¸ìš”..." maxlength="100" rows="3"></textarea>
                    <div class="message-counter">
                        <span id="messageCount">0</span> / 100
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <!-- ë¯¸ë¦¬ë³´ê¸° ì„¹ì…˜ -->
                <div class="preview-section">
                    <h3 style="margin-bottom: 20px; color: #495057;">ğŸ–¼ï¸ ë¯¸ë¦¬ë³´ê¸°</h3>
                    <div id="previewContainer">
                        <div class="preview-placeholder">
                            ì•„ë°”íƒ€ë¥¼ ì„ íƒí•˜ë©´<br>ì—¬ê¸°ì— ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤
                        </div>
                    </div>
                    <canvas id="avatarCanvas" class="preview-canvas" width="350" height="350" style="display: none;"></canvas>
                    
                    <div class="selected-items">
                        <div id="selectedAvatarInfo"></div>
                        <div id="selectedItemsInfo"></div>
                    </div>
                    
                    <button class="btn btn-success" id="saveCustomization" onclick="saveCustomization()" style="width: 100%; margin-top: 20px;" disabled>
                        ğŸ’¾ ì €ì¥í•˜ê¸°
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let currentUserToken = '';
        let avatarCategories = [];
        let itemCategories = [];
        let avatarSelections = {}; // { categoryType: optionId }
        let roleSelection = ''; // role ì•„ì´í…œ ID
        let itemSelections = { item1: '', item2: '', item3: '' }; // ìŠ¬ë¡¯ë³„ ì•„ì´í…œ ID
        let userMessage = '';
        let isLoading = false;

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.addEventListener('load', function() {
            initializeApp();
        });

        // ì•± ì´ˆê¸°í™”
        function initializeApp() {
            // ì €ì¥ëœ í† í° ë³µì›
            const savedToken = localStorage.getItem('userToken');
            if (savedToken) {
                document.getElementById('userToken').value = savedToken;
                currentUserToken = savedToken;
                showStatus('authStatus', 'success', 'âœ… ì €ì¥ëœ í† í°ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                loadData();
            }

            // ë©”ì‹œì§€ ì¹´ìš´í„° ì„¤ì •
            const messageInput = document.getElementById('userMessage');
            messageInput.addEventListener('input', function() {
                const count = this.value.length;
                document.getElementById('messageCount').textContent = count;
                userMessage = this.value;
                updateSaveButton();
            });

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
            setupDragAndDrop();
        }

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // í† í° ì„¤ì •
        function setUserToken() {
            const token = document.getElementById('userToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', 'í† í°ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const setButton = document.querySelector('button[onclick="setUserToken()"]');
            const originalText = setButton.textContent;
            
            try {
                // ë²„íŠ¼ ë¹„í™œì„±í™” ë° ë¡œë”© ìƒíƒœ í‘œì‹œ
                setButton.disabled = true;
                setButton.textContent = 'ì„¤ì • ì¤‘...';
                
                currentUserToken = token;
                localStorage.setItem('userToken', token);
                showStatus('authStatus', 'success', 'âœ… ì‚¬ìš©ì í† í°ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                loadData();
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì› (loadDataê°€ ì™„ë£Œëœ í›„)
                setTimeout(() => {
                    setButton.disabled = false;
                    setButton.textContent = originalText;
                }, 1000);
            }
        }

        // í…ŒìŠ¤íŠ¸ í† í° ìƒì„±
        async function getUserToken() {
            const tokenButton = document.querySelector('button[onclick="getUserToken()"]');
            const originalText = tokenButton.textContent;
            
            try {
                // ë²„íŠ¼ ë¹„í™œì„±í™” ë° ë¡œë”© ìƒíƒœ í‘œì‹œ
                tokenButton.disabled = true;
                tokenButton.textContent = 'í† í° ìƒì„± ì¤‘...';
                
                showStatus('authStatus', 'loading', 'í…ŒìŠ¤íŠ¸ í† í°ì„ ìƒì„±í•˜ëŠ” ì¤‘...');

                const response = await fetch('/api/auth/test-token/002', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('userToken').value = token;
                    currentUserToken = token;
                    localStorage.setItem('userToken', token);
                    
                    showStatus('authStatus', 'success', `âœ… í…ŒìŠ¤íŠ¸ í† í°ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìš©ì: ${data.user.nameKr})`);
                    loadData();
                } else {
                    showStatus('authStatus', 'error', `âŒ í† í° ìƒì„± ì‹¤íŒ¨: ${data.message}`);
                }
            } catch (error) {
                console.error('í† í° ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('authStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì›
                tokenButton.disabled = false;
                tokenButton.textContent = originalText;
            }
        }

        // í† í° ì´ˆê¸°í™”
        function clearUserToken() {
            currentUserToken = '';
            localStorage.removeItem('userToken');
            document.getElementById('userToken').value = '';
            showStatus('authStatus', 'success', 'ğŸ”„ í† í°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ë°ì´í„° ì´ˆê¸°í™”
            avatarCategories = [];
            itemCategories = [];
            avatarSelections = {};
            roleSelection = '';
            itemSelections = { item1: '', item2: '', item3: '' };
            
            // UI ì´ˆê¸°í™”
            document.getElementById('avatarCategories').innerHTML = '';
            document.getElementById('roleCategory').innerHTML = '';
            document.getElementById('itemCategories').innerHTML = '';
            updatePreview();
            updateSaveButton();
        }

        // ë°ì´í„° ë¡œë“œ
        async function loadData() {
            if (!currentUserToken) {
                showStatus('authStatus', 'error', 'âŒ ë¨¼ì € ì‚¬ìš©ì í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                console.log('ğŸ” ë°ì´í„° ë¡œë“œ ì‹œì‘');
                
                // 1. ì•„ë°”íƒ€ ë° ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë¡œë“œ
                console.log('ğŸ” ì¹´í…Œê³ ë¦¬ ë°ì´í„° ë¡œë“œ ì‹œì‘');
                await Promise.all([
                    loadAvatarCategories(),
                    loadItemCategories()
                ]);
                console.log('âœ… ì¹´í…Œê³ ë¦¬ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');

                // 2. ê¸°ì¡´ ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ (ì¹´í…Œê³ ë¦¬ ë¡œë“œ ì™„ë£Œ í›„)
                console.log('ğŸ” ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ ì‹œì‘');
                await loadUserCustomization();
                console.log('âœ… ëª¨ë“  ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
            } catch (error) {
                console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
            }
        }

        // ì €ì¥ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateSaveButton() {
            const saveButton = document.getElementById('saveCustomization');
            const hasAvatarSelection = Object.keys(avatarSelections).length > 0;
            const hasToken = !!currentUserToken;
            
            saveButton.disabled = !hasAvatarSelection || !hasToken || isLoading;
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
        function setupDragAndDrop() {
            const slots = document.querySelectorAll('.item-slot');
            
            slots.forEach(slot => {
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragleave', handleDragLeave);
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const itemId = e.dataTransfer.getData('text/plain');
            const slotType = e.currentTarget.getAttribute('data-slot');
            
            if (itemId && slotType) {
                // ë“œë˜ê·¸ëœ ì•„ì´í…œì˜ íƒ€ì… í™•ì¸
                const draggedItemData = e.dataTransfer.getData('application/json');
                if (draggedItemData) {
                    try {
                        const itemData = JSON.parse(draggedItemData);
                        
                        // Role ì•„ì´í…œì€ Role ìŠ¬ë¡¯ì—ë§Œ, ì¼ë°˜ ì•„ì´í…œì€ ì¼ë°˜ ìŠ¬ë¡¯ì—ë§Œ
                        if (itemData.slotType === 'role' && slotType !== 'role') {
                            alert('âŒ ì—­í•  ì•„ì´í…œì€ ì—­í•  ìŠ¬ë¡¯ì—ë§Œ ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                            return;
                        }
                        
                        if (itemData.slotType !== 'role' && slotType === 'role') {
                            alert('âŒ ì¼ë°˜ ì•„ì´í…œì€ ì—­í•  ìŠ¬ë¡¯ì— ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                            return;
                        }
                    } catch (error) {
                        console.error('ë“œë˜ê·¸ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
                    }
                }
                
                addToSlot(slotType, itemId);
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        // ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ë¡œë“œ
        async function loadAvatarCategories() {
            showStatus('avatarStatus', 'loading', 'ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
            
            try {
                const response = await fetch('/api/admin/characters/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    avatarCategories = data.categories.sort((a, b) => (a.order || 0) - (b.order || 0));
                    renderAvatarCategories();
                    showStatus('avatarStatus', 'success', `âœ… ${avatarCategories.length}ê°œì˜ ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    let errorMessage = 'ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ë¡œë“œ ì‹¤íŒ¨';
                    if (response.status === 401) {
                        errorMessage = 'ì¸ì¦ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.';
                    } else if (response.status === 403) {
                        errorMessage = 'ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.';
                    }
                    showStatus('avatarStatus', 'error', `âŒ ${data.message || errorMessage}`);
                }
            } catch (error) {
                console.error('ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('avatarStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderAvatarCategories() {
            const container = document.getElementById('avatarCategories');
            container.innerHTML = '';

            if (avatarCategories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">ë“±ë¡ëœ ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            avatarCategories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'avatar-category';
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <div class="category-name">${category.name}</div>
                        <div class="category-selection" id="selection-${category.type}">ì„ íƒ ì•ˆí•¨</div>
                    </div>
                    <div class="avatar-options" id="options-${category.type}">
                        ${renderAvatarOptions(category.options || [], category.type)}
                    </div>
                `;
                container.appendChild(categoryDiv);
            });
        }

        // ì•„ë°”íƒ€ ì˜µì…˜ ë Œë”ë§
        function renderAvatarOptions(options, categoryType) {
            if (!options || options.length === 0) {
                return '<p style="text-align: center; color: #6c757d; padding: 20px;">ë“±ë¡ëœ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            }

            return options.map(option => {
                const optionId = option._id || option.id;
                const isSelected = avatarSelections[categoryType] === optionId;
                
                return `
                    <div class="avatar-option ${isSelected ? 'selected' : ''}" 
                         data-category="${categoryType}" 
                         data-option="${optionId}"
                         onclick="selectAvatarOption('${categoryType}', '${optionId}')">
                        ${option.thumbnailUrl || option.imageUrl ? 
                            `<img src="${option.thumbnailUrl || option.imageUrl}" alt="${option.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjRjNGNEY2Ii8+CjxwYXRoIGQ9Ik0yOCAzMkM5LjUgMzIgMzIgMTggNDAgMThTNTcuNSAzMiA0MCAzMlMxOC41IDMyIDI4IDMyWiIgZmlsbD0iI0Q1RDhEQyIvPgo8cGF0aCBkPSJNMTYgNjRDMTYgNDkuNSAyNi41IDQwIDQwIDQwUzY0IDQ5LjUgNjQgNjRWNjRIMTZWNjRaIiBmaWxsPSIjRDVEOERDIi8+Cjwvc3ZnPg=='">`
                            : `<div style="width: 100%; height: 80px; background: #f8f9fa; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;">ì´ë¯¸ì§€ ì—†ìŒ</div>`
                        }
                        <div class="avatar-option-name">${option.name}</div>
                    </div>
                `;
            }).join('');
        }

        // ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë¡œë“œ
        async function loadItemCategories() {
            showStatus('itemStatus', 'loading', 'ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
            showStatus('roleStatus', 'loading', 'ì—­í•  ì•„ì´í…œì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
            
            try {
                const response = await fetch('/api/admin/stickers/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    itemCategories = data.categories.sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    // Role ì¹´í…Œê³ ë¦¬ì™€ ì¼ë°˜ ì¹´í…Œê³ ë¦¬ ë¶„ë¦¬
                    const roleCategories = itemCategories.filter(cat => cat.type === 'role');
                    const generalCategories = itemCategories.filter(cat => cat.type !== 'role');
                    
                    renderRoleCategory(roleCategories[0]); // Role ì¹´í…Œê³ ë¦¬ëŠ” í•˜ë‚˜ë§Œ ìˆë‹¤ê³  ê°€ì •
                    renderItemCategories(generalCategories);
                    
                    showStatus('itemStatus', 'success', `âœ… ${generalCategories.length}ê°œì˜ ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                    showStatus('roleStatus', 'success', `âœ… ì—­í•  ì•„ì´í…œì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    let errorMessage = 'ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë¡œë“œ ì‹¤íŒ¨';
                    if (response.status === 401) {
                        errorMessage = 'ì¸ì¦ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.';
                    } else if (response.status === 403) {
                        errorMessage = 'ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.';
                    }
                    showStatus('itemStatus', 'error', `âŒ ${data.message || errorMessage}`);
                    showStatus('roleStatus', 'error', `âŒ ${data.message || errorMessage}`);
                }
            } catch (error) {
                console.error('ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('itemStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
                showStatus('roleStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // Role ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderRoleCategory(category) {
            const container = document.getElementById('roleCategory');
            container.innerHTML = '';

            if (!category || !category.items || category.items.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">ë“±ë¡ëœ ì—­í•  ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = `
                <div class="category-header">
                    <div class="category-name">${category.name}</div>
                </div>
                <div class="item-grid">
                    ${renderItemCards(category.items, 'role')}
                </div>
            `;
        }

        // ì¼ë°˜ ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderItemCategories(categories) {
            const container = document.getElementById('itemCategories');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 20px;">ë“±ë¡ëœ ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            categories.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'item-category';
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <div class="category-name">${category.name}</div>
                    </div>
                    <div class="item-grid">
                        ${renderItemCards(category.items || [], 'item')}
                    </div>
                `;
                container.appendChild(categoryDiv);
            });
        }

        // ì•„ì´í…œ ì¹´ë“œ ë Œë”ë§
        function renderItemCards(items, slotType) {
            if (!items || items.length === 0) {
                return '<p style="text-align: center; color: #6c757d; padding: 20px;">ë“±ë¡ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            }

            return items.map(item => {
                const itemId = item._id || item.id;
                const imageUrl = item.thumbnailUrl || item.imageUrl;
                
                return `
                    <div class="item-card" 
                         data-item-id="${itemId}" 
                         data-slot-type="${slotType}"
                         draggable="true"
                         ondragstart="handleItemDragStart(event)"
                         onclick="handleItemClick(event, '${itemId}', '${slotType}')">
                        ${imageUrl ? 
                            `<img src="${imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTAwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNDAiIHI9IjE1IiBmaWxsPSIjRDVEOERDIi8+Cjx0ZXh0IHg9IjUwIiB5PSI2NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjNkM3NTdEIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5JVEVNPC90ZXh0Pgo8L3N2Zz4K'">`
                            : `<div style="width: 100%; height: 80px; background: #f8f9fa; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;">ì´ë¯¸ì§€ ì—†ìŒ</div>`
                        }
                        <div class="item-card-name">${item.name}</div>
                    </div>
                `;
            }).join('');
        }

        // ì•„ì´í…œ ë“œë˜ê·¸ ì‹œì‘
        function handleItemDragStart(event) {
            const itemId = event.currentTarget.getAttribute('data-item-id');
            const slotType = event.currentTarget.getAttribute('data-slot-type');
            
            event.dataTransfer.setData('text/plain', itemId);
            event.dataTransfer.setData('application/json', JSON.stringify({
                itemId: itemId,
                slotType: slotType
            }));
        }

        // ì•„ì´í…œ í´ë¦­ ì²˜ë¦¬ (ëª¨ë°”ì¼ ëŒ€ì‘)
        function handleItemClick(event, itemId, slotType) {
            // ë¹ˆ ìŠ¬ë¡¯ ì°¾ê¸°
            let targetSlot = null;
            
            if (slotType === 'role') {
                targetSlot = 'role';
            } else {
                // ì¼ë°˜ ì•„ì´í…œì˜ ê²½ìš° ë¹ˆ ìŠ¬ë¡¯ ì°¾ê¸°
                for (let i = 1; i <= 3; i++) {
                    if (!itemSelections[`item${i}`]) {
                        targetSlot = `item${i}`;
                        break;
                    }
                }
            }
            
            if (targetSlot) {
                addToSlot(targetSlot, itemId);
            } else {
                alert('ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¬ë¡¯ì´ ì—†ìŠµë‹ˆë‹¤. ê¸°ì¡´ ì•„ì´í…œì„ ì œê±°í•œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            }
        }

        // ì•„ë°”íƒ€ ì˜µì…˜ ì„ íƒ
        function selectAvatarOption(categoryType, optionId) {
            // ì´ì „ ì„ íƒ í•´ì œ
            const prevOption = document.querySelector(`[data-category="${categoryType}"][data-option="${avatarSelections[categoryType]}"]`);
            if (prevOption) {
                prevOption.classList.remove('selected');
            }

            // ìƒˆë¡œìš´ ì„ íƒ
            avatarSelections[categoryType] = optionId;
            
            // UI ì—…ë°ì´íŠ¸
            const newOption = document.querySelector(`[data-category="${categoryType}"][data-option="${optionId}"]`);
            if (newOption) {
                newOption.classList.add('selected');
            }

            // ì¹´í…Œê³ ë¦¬ ì„ íƒ ìƒíƒœ ì—…ë°ì´íŠ¸
            const selectionElement = document.getElementById(`selection-${categoryType}`);
            if (selectionElement) {
                const category = avatarCategories.find(cat => cat.type === categoryType);
                const option = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                if (option) {
                    selectionElement.textContent = option.name;
                    selectionElement.parentElement.parentElement.classList.add('selected');
                }
            }

            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updatePreview();
            updateSaveButton();
        }

        // ìŠ¬ë¡¯ì— ì•„ì´í…œ ì¶”ê°€
        function addToSlot(slotType, itemId) {
            // í•´ë‹¹ ì•„ì´í…œ ì •ë³´ ì°¾ê¸°
            const item = findItemById(itemId);
            if (!item) {
                console.error('Item not found:', itemId);
                return;
            }

            // ìŠ¬ë¡¯ì— ì•„ì´í…œ ì„¤ì •
            if (slotType === 'role') {
                roleSelection = itemId;
            } else {
                itemSelections[slotType] = itemId;
            }

            // ìŠ¬ë¡¯ UI ì—…ë°ì´íŠ¸
            updateSlotUI(slotType, item);
            
            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updateSelectedItemsInfo();
            updateSaveButton();
        }

        // ìŠ¬ë¡¯ì—ì„œ ì•„ì´í…œ ì œê±°
        function removeFromSlot(slotType) {
            if (slotType === 'role') {
                roleSelection = '';
            } else {
                itemSelections[slotType] = '';
            }

            // ìŠ¬ë¡¯ UI ì—…ë°ì´íŠ¸
            clearSlotUI(slotType);
            
            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updateSelectedItemsInfo();
            updateSaveButton();
        }

        // ìŠ¬ë¡¯ UI ì—…ë°ì´íŠ¸
        function updateSlotUI(slotType, item) {
            const slot = document.querySelector(`[data-slot="${slotType}"]`);
            if (!slot) return;

            const slotContent = slot.querySelector('.item-slot-content');
            if (!slotContent) return;

            const imageUrl = item.thumbnailUrl || item.imageUrl;
            
            slotContent.innerHTML = `
                <img src="${imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjMwIiBjeT0iMzAiIHI9IjEwIiBmaWxsPSIjRDVEOERDIi8+Cjx0ZXh0IHg9IjMwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjgiIGZpbGw9IiM2Qzc1N0QiIHRleHQtYW5jaG9yPSJtaWRkbGUiPklURU08L3RleHQ+Cjwvc3ZnPgo='">
                <div style="font-size: 0.7em; color: #495057; margin-top: 5px; text-align: center;">${item.name}</div>
            `;
            
            slot.classList.add('filled');
        }

        // ìŠ¬ë¡¯ UI ì´ˆê¸°í™”
        function clearSlotUI(slotType) {
            const slot = document.querySelector(`[data-slot="${slotType}"]`);
            if (!slot) return;

            const slotContent = slot.querySelector('.item-slot-content');
            if (!slotContent) return;

            let defaultText = '';
            if (slotType === 'role') {
                defaultText = 'ì—­í• ì„ ì„ íƒí•˜ì„¸ìš”';
            } else {
                defaultText = 'ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”';
            }

            slotContent.innerHTML = `<span style="font-size: 0.8em; color: #6c757d;">${defaultText}</span>`;
            slot.classList.remove('filled');
        }

        // ì•„ì´í…œ IDë¡œ ì•„ì´í…œ ì°¾ê¸°
        function findItemById(itemId) {
            for (const category of itemCategories) {
                if (category.items) {
                    for (const item of category.items) {
                        if ((item._id || item.id) === itemId) {
                            return item;
                        }
                    }
                }
            }
            return null;
        }

        // ì„ íƒëœ ì•„ì´í…œ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateSelectedItemsInfo() {
            const container = document.getElementById('selectedItemsInfo');
            if (!container) return;

            const selectedItems = [];
            
            // Role ì•„ì´í…œ ì¶”ê°€
            if (roleSelection) {
                const roleItem = findItemById(roleSelection);
                if (roleItem) {
                    selectedItems.push({
                        type: 'role',
                        name: roleItem.name,
                        imageUrl: roleItem.thumbnailUrl || roleItem.imageUrl
                    });
                }
            }

            // ì¼ë°˜ ì•„ì´í…œ ì¶”ê°€
            for (const [slotType, itemId] of Object.entries(itemSelections)) {
                if (itemId) {
                    const item = findItemById(itemId);
                    if (item) {
                        selectedItems.push({
                            type: slotType,
                            name: item.name,
                            imageUrl: item.thumbnailUrl || item.imageUrl
                        });
                    }
                }
            }

            if (selectedItems.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-size: 0.9em;">ì„ íƒëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = selectedItems.map(item => `
                <div class="selected-item">
                    <img src="${item.imageUrl}" alt="${item.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjE1IiBjeT0iMTUiIHI9IjUiIGZpbGw9IiNENUQ4REMiLz4KPC9zdmc+Cg=='">
                    <div>
                        <strong>${item.type === 'role' ? 'ì—­í• ' : item.type.toUpperCase()}:</strong> ${item.name}
                    </div>
                </div>
            `).join('');
        }

        // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updatePreview() {
            const canvas = document.getElementById('avatarCanvas');
            const previewContainer = document.getElementById('previewContainer');
            const placeholder = previewContainer.querySelector('.preview-placeholder');
            
            // ì•„ë°”íƒ€ ì„ íƒì´ ì—†ìœ¼ë©´ placeholder í‘œì‹œ
            if (Object.keys(avatarSelections).length === 0) {
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
                canvas.style.display = 'none';
                updateSelectedAvatarInfo();
                return;
            }
            
            // Canvas í‘œì‹œ, placeholder ìˆ¨ê¹€
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            canvas.style.display = 'block';
            
            // ì•„ë°”íƒ€ í•©ì„±
            composeAvatar();
        }

        // ì•„ë°”íƒ€ í•©ì„±
        async function composeAvatar() {
            const canvas = document.getElementById('avatarCanvas');
            const ctx = canvas.getContext('2d');
            
            // Canvas ì´ˆê¸°í™”
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë°°ê²½ ì„¤ì • (íˆ¬ëª… ë°°ê²½)
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            try {
                // ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ë¥¼ order ìˆœì„œëŒ€ë¡œ ì •ë ¬
                const sortedCategories = avatarCategories
                    .filter(category => avatarSelections[category.type])
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
                
                // ìˆœì„œëŒ€ë¡œ ì´ë¯¸ì§€ ë ˆì´ì–´ë§
                for (const category of sortedCategories) {
                    const optionId = avatarSelections[category.type];
                    const option = category.options?.find(opt => (opt._id || opt.id) === optionId);
                    
                    if (option && (option.imageUrl || option.thumbnailUrl)) {
                        const imageUrl = option.imageUrl || option.thumbnailUrl;
                        await drawImageOnCanvas(ctx, imageUrl, canvas.width, canvas.height);
                    }
                }
                
                // ì„ íƒëœ ì•„ë°”íƒ€ ì •ë³´ ì—…ë°ì´íŠ¸
                updateSelectedAvatarInfo();
                
            } catch (error) {
                console.error('ì•„ë°”íƒ€ í•©ì„± ì˜¤ë¥˜:', error);
                
                // ì—ëŸ¬ ë°œìƒ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
                ctx.fillStyle = '#f8d7da';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#721c24';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨', canvas.width / 2, canvas.height / 2);
                ctx.fillText('ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”', canvas.width / 2, canvas.height / 2 + 25);
            }
        }

        // Canvasì— ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        function drawImageOnCanvas(ctx, imageUrl, canvasWidth, canvasHeight) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // CORS ë¬¸ì œ í•´ê²°
                
                img.onload = function() {
                    try {
                        // ì´ë¯¸ì§€ë¥¼ Canvas í¬ê¸°ì— ë§ì¶° ê·¸ë¦¬ê¸°
                        const aspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvasWidth / canvasHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (aspectRatio > canvasAspectRatio) {
                            // ì´ë¯¸ì§€ê°€ Canvasë³´ë‹¤ ê°€ë¡œë¡œ ê¸¸ ê²½ìš°
                            drawWidth = canvasWidth;
                            drawHeight = canvasWidth / aspectRatio;
                            drawX = 0;
                            drawY = (canvasHeight - drawHeight) / 2;
                        } else {
                            // ì´ë¯¸ì§€ê°€ Canvasë³´ë‹¤ ì„¸ë¡œë¡œ ê¸¸ ê²½ìš°
                            drawWidth = canvasHeight * aspectRatio;
                            drawHeight = canvasHeight;
                            drawX = (canvasWidth - drawWidth) / 2;
                            drawY = 0;
                        }
                        
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = function() {
                    reject(new Error(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${imageUrl}`));
                };
                
                img.src = imageUrl;
            });
        }

        // ì„ íƒëœ ì•„ë°”íƒ€ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateSelectedAvatarInfo() {
            const container = document.getElementById('selectedAvatarInfo');
            if (!container) return;

            const selectedAvatars = [];
            
            for (const [categoryType, optionId] of Object.entries(avatarSelections)) {
                const category = avatarCategories.find(cat => cat.type === categoryType);
                const option = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                
                if (option) {
                    selectedAvatars.push({
                        categoryName: category.name,
                        optionName: option.name,
                        imageUrl: option.thumbnailUrl || option.imageUrl
                    });
                }
            }

            if (selectedAvatars.length === 0) {
                container.innerHTML = '<p style="color: #6c757d; font-size: 0.9em;">ì„ íƒëœ ì•„ë°”íƒ€ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            container.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #495057; font-size: 1em;">ì„ íƒëœ ì•„ë°”íƒ€</h4>
                    ${selectedAvatars.map(avatar => `
                        <div class="selected-item">
                            <img src="${avatar.imageUrl}" alt="${avatar.optionName}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjRjNGNEY2Ii8+CjxjaXJjbGUgY3g9IjE1IiBjeT0iMTUiIHI9IjUiIGZpbGw9IiNENUQ4REMiLz4KPC9zdmc+Cg=='">
                            <div>
                                <strong>${avatar.categoryName}:</strong> ${avatar.optionName}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Canvasì—ì„œ Blob ìƒì„±
        function getCanvasBlob() {
            return new Promise((resolve, reject) => {
                const canvas = document.getElementById('avatarCanvas');
                
                canvas.toBlob(
                    (blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Canvas to Blob ë³€í™˜ ì‹¤íŒ¨'));
                        }
                    },
                    'image/png',
                    0.9
                );
            });
        }

        // ì»¤ìŠ¤í„°ë§ˆì´ì§• ì €ì¥
        async function saveCustomization() {
            if (!currentUserToken) {
                alert('âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¨¼ì € í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (Object.keys(avatarSelections).length === 0) {
                alert('âŒ ì•„ë°”íƒ€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const saveButton = document.getElementById('saveCustomization');
            const originalText = saveButton.innerHTML;
            
            try {
                isLoading = true;
                saveButton.disabled = true;
                saveButton.innerHTML = 'ğŸ’¾ ì €ì¥ ì¤‘...<div class="loading-spinner" style="width: 16px; height: 16px; margin-left: 8px; display: inline-block; vertical-align: middle;"></div>';

                // 1. í•©ì„±ëœ ì•„ë°”íƒ€ ì´ë¯¸ì§€ ì—…ë¡œë“œ
                let avatarImgUrl = '';
                if (Object.keys(avatarSelections).length > 0) {
                    const blob = await getCanvasBlob();
                    avatarImgUrl = await uploadAvatarImage(blob);
                }

                // 2. ì‚¬ìš©ì ì»¤ìŠ¤í„°ë§ˆì´ì§• ë°ì´í„° ì €ì¥
                const customizationData = {
                    avatarSelections: avatarSelections,
                    avatarImgUrl: avatarImgUrl,
                    message: userMessage || '',
                    role: roleSelection || '',
                    item1: itemSelections.item1 || '',
                    item2: itemSelections.item2 || '',
                    item3: itemSelections.item3 || ''
                };

                await saveUserCustomization(customizationData);

                // ì„±ê³µ ë©”ì‹œì§€
                alert('âœ… ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                
            } catch (error) {
                console.error('ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            } finally {
                isLoading = false;
                saveButton.disabled = false;
                saveButton.innerHTML = originalText;
                updateSaveButton();
            }
        }

        // ì•„ë°”íƒ€ ì´ë¯¸ì§€ ì—…ë¡œë“œ
        async function uploadAvatarImage(blob) {
            const formData = new FormData();
            formData.append('avatar', blob, 'avatar.png');
            
            // ì‚¬ìš©ì ID ì¶”ì¶œ (JWT í† í°ì—ì„œ ì¶”ì¶œí•˜ê±°ë‚˜ ì„ì‹œë¡œ ì„¤ì •)
            const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';
            formData.append('userId', userId);

            const response = await fetch('/api/avatars/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`
                },
                body: formData
            });

            const data = await response.json();

            if (response.ok) {
                return data.avatarImgUrl;
            } else {
                throw new Error(data.error || 'ì•„ë°”íƒ€ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨');
            }
        }

        // ì‚¬ìš©ì ì»¤ìŠ¤í„°ë§ˆì´ì§• ë°ì´í„° ì €ì¥
        async function saveUserCustomization(customizationData) {
            // ì‚¬ìš©ì ID ì¶”ì¶œ
            const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';

            const response = await fetch(`/api/avatars/${userId}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(customizationData)
            });

            const data = await response.json();

            if (!response.ok) {
                console.error('Server error response:', data);
                console.error('Request data:', customizationData);
                throw new Error(data.error || data.message || 'ì‚¬ìš©ì ë°ì´í„° ì €ì¥ ì‹¤íŒ¨');
            }

            return data;
        }

        // JWT í† í°ì—ì„œ ì‚¬ìš©ì ID ì¶”ì¶œ (ê°„ë‹¨í•œ êµ¬í˜„)
        function extractUserIdFromToken(token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                return payload.userId || payload.id || payload.sub;
            } catch (error) {
                console.error('í† í° íŒŒì‹± ì˜¤ë¥˜:', error);
                return null;
            }
        }

        // ê¸°ì¡´ ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ
        async function loadUserCustomization() {
            if (!currentUserToken) return;

            try {
                const userId = extractUserIdFromToken(currentUserToken) || 'temp-user-id';
                
                const response = await fetch(`/api/avatars/${userId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentUserToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('ğŸ” ë¡œë“œëœ ì‚¬ìš©ì ë°ì´í„°:', data);
                    
                    // ì•„ë°”íƒ€ ì„ íƒ ë°ì´í„° ë³€í™˜
                    if (data.avatarSelections) {
                        avatarSelections = {};
                        for (const [categoryType, selectionData] of Object.entries(data.avatarSelections)) {
                            if (typeof selectionData === 'object' && selectionData.id) {
                                // ê°ì²´ í˜•íƒœì¸ ê²½ìš° IDë§Œ ì¶”ì¶œ
                                avatarSelections[categoryType] = selectionData.id;
                            } else if (typeof selectionData === 'string') {
                                // ì´ë¯¸ ID ë¬¸ìì—´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
                                avatarSelections[categoryType] = selectionData;
                            }
                        }
                        console.log('ğŸ” ë³€í™˜ëœ avatarSelections:', avatarSelections);
                    }
                    
                    // ë©”ì‹œì§€ ë°ì´í„°
                    if (data.message) {
                        userMessage = data.message;
                        document.getElementById('userMessage').value = data.message;
                        document.getElementById('messageCount').textContent = data.message.length;
                    }
                    
                    // ì—­í•  ë°ì´í„° ë³€í™˜
                    if (data.role) {
                        if (typeof data.role === 'object' && data.role.id) {
                            roleSelection = data.role.id;
                        } else if (typeof data.role === 'string') {
                            roleSelection = data.role;
                        }
                        console.log('ğŸ” ë³€í™˜ëœ roleSelection:', roleSelection);
                    }
                    
                    // ì•„ì´í…œ ë°ì´í„° ë³€í™˜
                    for (let i = 1; i <= 3; i++) {
                        const itemKey = `item${i}`;
                        const itemData = data[itemKey];
                        if (itemData) {
                            if (typeof itemData === 'object' && itemData.id) {
                                itemSelections[itemKey] = itemData.id;
                            } else if (typeof itemData === 'string') {
                                itemSelections[itemKey] = itemData;
                            }
                        }
                    }
                    console.log('ğŸ” ë³€í™˜ëœ itemSelections:', itemSelections);

                    // UI ì—…ë°ì´íŠ¸
                    updateUIFromLoadedData();
                    console.log('âœ… ê¸°ì¡´ ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ ë° UI ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                } else if (response.status === 404) {
                    // 404ëŠ” ì •ìƒì ì¸ ìƒí™© - ì‚¬ìš©ì ë°ì´í„°ê°€ ì—†ìŒ
                    console.log('ìƒˆë¡œìš´ ì‚¬ìš©ì - ê¸°ì¡´ ë°ì´í„° ì—†ìŒ');
                } else {
                    // ë‹¤ë¥¸ ì˜¤ë¥˜ë“¤ë§Œ ë¡œê¹…
                    console.warn('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
            }
        }

        // ë¡œë“œëœ ë°ì´í„°ë¡œ UI ì—…ë°ì´íŠ¸
        function updateUIFromLoadedData() {
            console.log('ğŸ” updateUIFromLoadedData ì‹œì‘');
            
            // ì•„ë°”íƒ€ ì„ íƒ ìƒíƒœ ì—…ë°ì´íŠ¸
            for (const [categoryType, optionId] of Object.entries(avatarSelections)) {
                console.log(`ğŸ” ì•„ë°”íƒ€ ì„ íƒ ì—…ë°ì´íŠ¸: ${categoryType} = ${optionId}`);
                const option = document.querySelector(`[data-category="${categoryType}"][data-option="${optionId}"]`);
                if (option) {
                    option.classList.add('selected');
                    console.log(`âœ… ì•„ë°”íƒ€ ì„ íƒ UI ì—…ë°ì´íŠ¸ ì„±ê³µ: ${categoryType}`);
                    
                    const selectionElement = document.getElementById(`selection-${categoryType}`);
                    if (selectionElement) {
                        const category = avatarCategories.find(cat => cat.type === categoryType);
                        const optionData = category?.options?.find(opt => (opt._id || opt.id) === optionId);
                        if (optionData) {
                            selectionElement.textContent = optionData.name;
                            selectionElement.parentElement.parentElement.classList.add('selected');
                        }
                    }
                } else {
                    console.warn(`âŒ ì•„ë°”íƒ€ ì„ íƒ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${categoryType} = ${optionId}`);
                }
            }

            // ì•„ì´í…œ ìŠ¬ë¡¯ ì—…ë°ì´íŠ¸
            if (roleSelection) {
                console.log(`ğŸ” ì—­í•  ì•„ì´í…œ ì—…ë°ì´íŠ¸: ${roleSelection}`);
                const roleItem = findItemById(roleSelection);
                if (roleItem) {
                    updateSlotUI('role', roleItem);
                    console.log(`âœ… ì—­í•  ì•„ì´í…œ UI ì—…ë°ì´íŠ¸ ì„±ê³µ`);
                } else {
                    console.warn(`âŒ ì—­í•  ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${roleSelection}`);
                }
            }

            for (const [slotType, itemId] of Object.entries(itemSelections)) {
                if (itemId) {
                    console.log(`ğŸ” ì¼ë°˜ ì•„ì´í…œ ì—…ë°ì´íŠ¸: ${slotType} = ${itemId}`);
                    const item = findItemById(itemId);
                    if (item) {
                        updateSlotUI(slotType, item);
                        console.log(`âœ… ì¼ë°˜ ì•„ì´í…œ UI ì—…ë°ì´íŠ¸ ì„±ê³µ: ${slotType}`);
                    } else {
                        console.warn(`âŒ ì¼ë°˜ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${slotType} = ${itemId}`);
                    }
                }
            }

            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updatePreview();
            updateSelectedItemsInfo();
            updateSaveButton();
            console.log('âœ… updateUIFromLoadedData ì™„ë£Œ');
        }
    </script>
</body>

</html>
</file>

<file path="public/test/item.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤í‹°ì»¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ - AR ëª…í•¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], input[type="number"], textarea {
            width: 200px;
        }

        input[type="file"] {
            width: 300px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .category-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
        }

        .category-title::before {
            content: 'â–¶';
            font-size: 12px;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        .category-card:not(.collapsed) .category-title::before {
            transform: rotate(90deg);
        }

        .category-card.collapsed .category-items {
            display: none;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .item-card {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            background: #fafafa;
        }

        .item-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .thumbnail-source {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .category-items {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .multi-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            background-color: #fafafa;
        }

        .multi-upload-container.dragover {
            border-color: #007bff;
            background-color: #e3f2fd;
        }

        .file-items {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .file-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: white;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .file-preview {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-info {
            flex: 1;
        }

        .file-actions {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .remove-file {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-file:hover {
            background-color: #c82333;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .batch-input {
            flex: 1;
            min-width: 150px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #28a745;
            transition: width 0.3s ease;
        }

        .upload-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .animation-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .animation-preview {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px auto;
            background-size: cover;
            background-repeat: no-repeat;
        }

        .form-section {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            background-color: #f9f9f9;
        }

        .form-section h4 {
            margin-top: 0;
            color: #333;
        }

        input:disabled, select:disabled {
            background-color: #f5f5f5;
            color: #666;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ® ìŠ¤í‹°ì»¤ ê´€ë¦¬ í…ŒìŠ¤íŠ¸ í˜ì´ì§€</h1>

        <!-- ì¸ì¦ ì„¹ì…˜ -->
        <div class="section auth-section">
            <h3>ğŸ” ê´€ë¦¬ì ì¸ì¦</h3>
            <p>ìŠ¤í‹°ì»¤ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="ê´€ë¦¬ì JWT í† í° ì…ë ¥" style="width: 400px;">
                <button onclick="setAuthToken()">í† í° ì„¤ì •</button>
                <button onclick="getAdminToken()" class="btn-success">ê´€ë¦¬ì í† í° ìƒì„±</button>
                <button onclick="clearAuthToken()" class="btn-secondary">í† í° ì´ˆê¸°í™”</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- ì¹´í…Œê³ ë¦¬ ê´€ë¦¬ ì„¹ì…˜ -->
        <div class="section">
            <h3>ğŸ“ ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ê´€ë¦¬</h3>
            <div class="controls">
                <button onclick="openCreateCategoryModal()" class="btn-success">ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</button>
                <button onclick="loadCategories()" class="btn-secondary">ìƒˆë¡œê³ ì¹¨</button>
            </div>
            <div id="categoryStatus"></div>
            <div id="categoriesContainer"></div>
        </div>
    </div>

    <!-- ì¹´í…Œê³ ë¦¬ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="categoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCategoryModal()">&times;</span>
            <h3 id="categoryModalTitle">ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€</h3>
            <form id="categoryForm">
                <input type="hidden" id="categoryId">
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="categoryName">ì¹´í…Œê³ ë¦¬ ì´ë¦„ *</label>
                        <input type="text" id="categoryName" required placeholder="ì˜ˆ: ìš´ë™, ìŒë£Œ, ìŒì‹, ì·¨ë¯¸">
                    </div>
                    
                    <div class="form-group">
                        <label for="categoryType">ì¹´í…Œê³ ë¦¬ íƒ€ì… *</label>
                        <input type="text" id="categoryType" required placeholder="ì˜ˆ: exercise, drink, food, hobby">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="categoryOrder">ìˆœì„œ</label>
                    <input type="number" id="categoryOrder" min="0" value="0">
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCategoryModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ìŠ¤í‹°ì»¤ ìƒì„±/ìˆ˜ì • ëª¨ë‹¬ -->
    <div id="itemModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeItemModal()">&times;</span>
            <h3 id="itemModalTitle">ğŸ® ìƒˆ ìŠ¤í‹°ì»¤ ì¶”ê°€</h3>
            <form id="itemForm" enctype="multipart/form-data">
                <input type="hidden" id="itemCategoryId">
                <input type="hidden" id="itemId">
                
                <!-- ë‹¨ì¼ ìŠ¤í‹°ì»¤ ì¶”ê°€ ëª¨ë“œ -->
                <div id="singleItemMode">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="itemName">ìŠ¤í‹°ì»¤ ì´ë¦„ *</label>
                            <input type="text" id="itemName" required placeholder="ì˜ˆ: ë‹¬ë¦¬ê¸°, ì»¤í”¼, í–„ë²„ê±°">
                        </div>
                        
                        <div class="form-group">
                            <label for="itemOrder">ìˆœì„œ</label>
                            <input type="number" id="itemOrder" min="0" value="0">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="itemImage">ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€ * (ìŠ¤í”„ë¼ì´íŠ¸ ì‹œí€€ìŠ¤ ë˜ëŠ” ë‹¨ì¼ ì´ë¯¸ì§€)</label>
                        <input type="file" id="itemImage" accept="image/*">
                        <div id="imagePreview"></div>
                    </div>
                    
                    <div class="form-section">
                        <h4>ğŸ¬ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì • (ì„ íƒì‚¬í•­)</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="itemFrames">ì´ í”„ë ˆì„ ìˆ˜</label>
                                <input type="number" id="itemFrames" min="1" placeholder="ì˜ˆ: 16">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemColumns">ì»¬ëŸ¼ ìˆ˜</label>
                                <input type="number" id="itemColumns" min="1" max="64" value="16" placeholder="ê¸°ë³¸ê°’: 16">
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="itemDuration">ì• ë‹ˆë©”ì´ì…˜ ì§€ì†ì‹œê°„ (ms)</label>
                                <input type="number" id="itemDuration" min="1" placeholder="ì˜ˆ: 1000">
                            </div>
                            
                            <div class="form-group">
                                <label for="itemAnimationType">ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…</label>
                                <select id="itemAnimationType" onchange="handleAnimationTypeChange()">
                                    <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                                    <option value="none">ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ (ìŠ¤í‹¸ ì´ë¯¸ì§€)</option>
                                    <option value="loop">ë°˜ë³µ (loop)</option>
                                    <option value="once">í•œ ë²ˆ (once)</option>
                                    <option value="pingpong">ì™•ë³µ (pingpong)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="itemThumbnail">ì¸ë„¤ì¼ ì´ë¯¸ì§€ (300x300px ê¶Œì¥)</label>
                        <input type="file" id="itemThumbnail" accept="image/*">
                        <small>ì¸ë„¤ì¼ì„ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ ìë™ ìƒì„±ë©ë‹ˆë‹¤.</small>
                        <div id="thumbnailPreview"></div>
                    </div>
                </div>

                <!-- ë‹¤ì¤‘ ìŠ¤í‹°ì»¤ ì¶”ê°€ ëª¨ë“œ -->
                <div id="multiItemMode" style="display: none;">
                    <div class="form-group">
                        <label>ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)</label>
                        <div class="multi-upload-container" id="multiUploadContainer">
                            <p>ì—¬ê¸°ì— íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
                            <input type="file" id="multiItemImages" accept="image/*" multiple style="display: none;">
                            <button type="button" onclick="document.getElementById('multiItemImages').click()" class="btn-success">íŒŒì¼ ì„ íƒ</button>
                        </div>
                    </div>

                    <!-- ì¼ê´„ ì„¤ì • -->
                    <div class="form-section">
                        <h4>ğŸ”§ ì¼ê´„ ì„¤ì •</h4>
                        <div class="batch-controls">
                            <input type="number" id="batchOrderStart" min="0" value="0" class="batch-input" placeholder="ì‹œì‘ ìˆœì„œ">
                            <input type="number" id="batchFrames" min="1" class="batch-input" placeholder="ê³µí†µ í”„ë ˆì„ ìˆ˜">
                            <input type="number" id="batchColumns" min="1" max="64" value="16" class="batch-input" placeholder="ê³µí†µ ì»¬ëŸ¼ ìˆ˜">
                            <input type="number" id="batchDuration" min="1" class="batch-input" placeholder="ê³µí†µ ì§€ì†ì‹œê°„ (ms)">
                            <select id="batchAnimationType" class="batch-input" onchange="handleBatchAnimationTypeChange()">
                                <option value="">ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…</option>
                                <option value="none">ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ (ìŠ¤í‹¸ ì´ë¯¸ì§€)</option>
                                <option value="loop">ë°˜ë³µ (loop)</option>
                                <option value="once">í•œ ë²ˆ (once)</option>
                                <option value="pingpong">ì™•ë³µ (pingpong)</option>
                            </select>
                            <button type="button" onclick="applyBatchSettings()" class="btn-secondary">ì¼ê´„ ì ìš©</button>
                        </div>
                    </div>

                    <!-- íŒŒì¼ ëª©ë¡ -->
                    <div id="fileItemsContainer" class="file-items"></div>

                    <!-- ì—…ë¡œë“œ ì§„í–‰ë¥  -->
                    <div id="uploadProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="upload-status" id="uploadStatus"></div>
                    </div>
                </div>
                
                <!-- ëª¨ë“œ ì „í™˜ ë²„íŠ¼ -->
                <div style="text-align: center; margin: 20px 0;">
                    <button type="button" id="toggleModeBtn" onclick="toggleUploadMode()" class="btn-secondary">ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ</button>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeItemModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success" id="submitItemBtn">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let categories = [];
        let isMultiMode = false;
        let selectedFiles = [];
        let uploadProgress = 0;
        let expandedCategories = new Set(); // ì—´ë¦° ì¹´í…Œê³ ë¦¬ ìƒíƒœ ì¶”ì 

        // ì¸ì¦ í† í° ì„¤ì •
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', 'í† í°ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', 'âœ… ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // í† í° ì„¤ì • í›„ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìë™ ë¡œë“œ
            loadCategories();
        }

        // ê´€ë¦¬ì í† í° ìƒì„±
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', 'ê´€ë¦¬ì í† í°ì„ ìƒì„±í•˜ëŠ” ì¤‘...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `âœ… ê´€ë¦¬ì í† í°ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìš©ì: ${data.user.nameKr})`);
                    
                    // í† í° ìƒì„± í›„ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìë™ ë¡œë“œ
                    loadCategories();
                } else {
                    showStatus('authStatus', 'error', `âŒ í† í° ìƒì„± ì‹¤íŒ¨: ${data.message || 'ê´€ë¦¬ì ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}`);
                }

            } catch (error) {
                console.error('í† í° ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('authStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // í† í° ì´ˆê¸°í™”
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', 'ğŸ”„ í† í°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ì¹´í…Œê³ ë¦¬ ëª©ë¡ ìˆ¨ê¸°ê¸°
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í† í° ë³µì›
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', 'âœ… ì €ì¥ëœ í† í°ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                loadCategories();
            }

            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ì„¤ì •
            setupDragAndDrop();
        });

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ
        async function loadCategories() {
            if (!currentToken) {
                showStatus('categoryStatus', 'error', 'âŒ ë¨¼ì € ê´€ë¦¬ì í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                showStatus('categoryStatus', 'loading', 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

                const response = await fetch('/api/admin/stickers/categories', {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    categories = data.categories;
                    renderCategories();
                    showStatus('categoryStatus', 'success', `âœ… ${categories.length}ê°œì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    showStatus('categoryStatus', 'error', `âŒ ${data.message || 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨'}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('categoryStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¹´í…Œê³ ë¦¬ ë Œë”ë§
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';

            if (categories.length === 0) {
                container.innerHTML = '<p>ë“±ë¡ëœ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            categories.forEach(category => {
                // ID í•„ë“œ í™•ì¸ - _id ë˜ëŠ” id ì‚¬ìš©
                const categoryId = category._id || category.id;
                console.log('Category object:', category);
                console.log('Category ID:', categoryId);
                
                const categoryCard = document.createElement('div');
                const isExpanded = expandedCategories.has(categoryId);
                categoryCard.className = `category-card ${isExpanded ? '' : 'collapsed'}`;
                categoryCard.setAttribute('data-category-id', categoryId);
                categoryCard.innerHTML = `
                    <div class="category-header" onclick="toggleCategory(this)">
                        <div class="category-title">${category.name} (${category.type})</div>
                        <div>
                            <button onclick="event.stopPropagation(); openCreateItemModal('${categoryId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">ìŠ¤í‹°ì»¤ ì¶”ê°€</button>
                            <button onclick="event.stopPropagation(); editCategory('${categoryId}')" class="btn-warning" style="padding: 5px 10px; font-size: 12px;">ìˆ˜ì •</button>
                            <button onclick="event.stopPropagation(); deleteCategory('${categoryId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">ì‚­ì œ</button>
                        </div>
                    </div>
                    <div class="category-items">
                        <p><strong>ìŠ¤í‹°ì»¤ ìˆ˜:</strong> ${category.items ? category.items.length : 0}ê°œ</p>
                        <div class="items-grid" id="items-${categoryId}">
                            ${renderItems(category.items || [], categoryId)}
                        </div>
                    </div>
                `;
                container.appendChild(categoryCard);
            });
        }

        function toggleCategory(headerElement) {
            const card = headerElement.closest('.category-card');
            const categoryId = card.getAttribute('data-category-id');
            
            card.classList.toggle('collapsed');
            
            // ìƒíƒœ ì¶”ì 
            if (card.classList.contains('collapsed')) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
        }

        // ìŠ¤í‹°ì»¤ ë Œë”ë§
        function renderItems(items, categoryId) {
            if (!items || items.length === 0) {
                return '<p>ë“±ë¡ëœ ìŠ¤í‹°ì»¤ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            }

            return items.map(item => {
                const itemId = item._id || item.id;
                const hasAnimation = item.animation && item.animation.frames > 1;
                
                return `
                    <div class="item-card">
                        <div class="item-image-container">
                            ${item.thumbnailUrl ? `<img src="${item.thumbnailUrl}" alt="${item.name}" class="item-image">` : '<div class="item-image" style="background-color: #ddd; display: flex; align-items: center; justify-content: center;">ì¸ë„¤ì¼ ì—†ìŒ</div>'}
                        </div>
                        <div class="item-name">${item.name}</div>
                        ${hasAnimation ? `<div class="animation-info">ğŸ¬ ${item.animation.frames}í”„ë ˆì„ / ${item.animation.duration}ms</div>` : ''}
                        <div class="thumbnail-source">ì¸ë„¤ì¼: ${item.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'}</div>
                        <div class="item-actions">
                            <button onclick="openEditItemModal('${categoryId}', '${itemId}', '${item.name}')" class="btn-warning" style="padding: 3px 8px; font-size: 11px;">ìˆ˜ì •</button>
                            <button onclick="deleteItem('${categoryId}', '${itemId}')" class="btn-danger" style="padding: 3px 8px; font-size: 11px;">ì‚­ì œ</button>
                            <button onclick="regenerateThumbnail('${categoryId}', '${itemId}')" class="btn-secondary" style="padding: 3px 8px; font-size: 11px;">ì¸ë„¤ì¼ ì¬ìƒì„±</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… ë³€ê²½ ì²˜ë¦¬ (ë‹¨ì¼ ëª¨ë“œ)
        function handleAnimationTypeChange() {
            const animationType = document.getElementById('itemAnimationType').value;
            const framesField = document.getElementById('itemFrames');
            const columnsField = document.getElementById('itemColumns');
            const durationField = document.getElementById('itemDuration');
            
            if (animationType === 'none') {
                // ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ - ìŠ¤í‹¸ ì´ë¯¸ì§€
                framesField.value = '1';
                columnsField.value = '1';
                durationField.value = '';
                
                // í•„ë“œ ë¹„í™œì„±í™”
                framesField.disabled = true;
                columnsField.disabled = true;
                durationField.disabled = true;
            } else if (animationType === '') {
                // ì„ íƒ ì•ˆí•¨ - ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›
                framesField.value = '';
                columnsField.value = '16';
                durationField.value = '';
                
                // í•„ë“œ í™œì„±í™”
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
            } else {
                // ì• ë‹ˆë©”ì´ì…˜ ìˆìŒ - í•„ë“œ í™œì„±í™”
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
                
                // ê¸°ë³¸ê°’ ì„¤ì • (ë¹„ì–´ìˆëŠ” ê²½ìš°)
                if (!framesField.value) framesField.value = '16';
                if (!columnsField.value) columnsField.value = '16';
                if (!durationField.value) durationField.value = '1000';
            }
        }

        // ì¼ê´„ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… ë³€ê²½ ì²˜ë¦¬
        function handleBatchAnimationTypeChange() {
            const animationType = document.getElementById('batchAnimationType').value;
            const framesField = document.getElementById('batchFrames');
            const columnsField = document.getElementById('batchColumns');
            const durationField = document.getElementById('batchDuration');
            
            if (animationType === 'none') {
                // ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ - ìŠ¤í‹¸ ì´ë¯¸ì§€
                framesField.value = '1';
                columnsField.value = '1';
                durationField.value = '';
                
                // í•„ë“œ ë¹„í™œì„±í™”
                framesField.disabled = true;
                columnsField.disabled = true;
                durationField.disabled = true;
            } else if (animationType === '') {
                // ì„ íƒ ì•ˆí•¨ - ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›
                framesField.value = '';
                columnsField.value = '16';
                durationField.value = '';
                
                // í•„ë“œ í™œì„±í™”
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
            } else {
                // ì• ë‹ˆë©”ì´ì…˜ ìˆìŒ - í•„ë“œ í™œì„±í™”
                framesField.disabled = false;
                columnsField.disabled = false;
                durationField.disabled = false;
                
                // ê¸°ë³¸ê°’ ì„¤ì • (ë¹„ì–´ìˆëŠ” ê²½ìš°)
                if (!framesField.value) framesField.value = '16';
                if (!columnsField.value) columnsField.value = '16';
                if (!durationField.value) durationField.value = '1000';
            }
        }

        // íŠ¹ì • ì¹´í…Œê³ ë¦¬ì˜ ìŠ¤í‹°ì»¤ë§Œ ì—…ë°ì´íŠ¸
        async function updateCategoryItems(categoryId) {
            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    // ì „ì²´ categories ë°°ì—´ì—ì„œ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸
                    const categoryIndex = categories.findIndex(c => (c._id || c.id) === categoryId);
                    if (categoryIndex !== -1) {
                        // API ì‘ë‹µì´ ì§ì ‘ ì¹´í…Œê³ ë¦¬ ê°ì²´ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ dataë¥¼ ì‚¬ìš©
                        categories[categoryIndex] = data;
                        
                        // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ìŠ¤í‹°ì»¤ ê·¸ë¦¬ë“œë§Œ ì—…ë°ì´íŠ¸
                        const itemsGrid = document.getElementById(`items-${categoryId}`);
                        if (itemsGrid) {
                            itemsGrid.innerHTML = renderItems(data.items || [], categoryId);
                        }
                    }
                } else {
                    console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', data.message);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            }
        }

        // ì—…ë¡œë“œ ëª¨ë“œ ì „í™˜
        function toggleUploadMode() {
            isMultiMode = !isMultiMode;
            const singleMode = document.getElementById('singleItemMode');
            const multiMode = document.getElementById('multiItemMode');
            const toggleBtn = document.getElementById('toggleModeBtn');
            const submitBtn = document.getElementById('submitItemBtn');

            // ë‹¨ì¼ ëª¨ë“œì˜ í•„ìˆ˜ ì…ë ¥ í•„ë“œë“¤
            const singleModeRequiredFields = [
                document.getElementById('itemName'),
                document.getElementById('itemImage')
            ];

            if (isMultiMode) {
                singleMode.style.display = 'none';
                multiMode.style.display = 'block';
                toggleBtn.textContent = 'ë‹¨ì¼ ì—…ë¡œë“œ ëª¨ë“œ';
                submitBtn.textContent = 'ì¼ê´„ ì—…ë¡œë“œ';
                
                // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ì œê±°
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.removeAttribute('required');
                    }
                });
            } else {
                singleMode.style.display = 'block';
                multiMode.style.display = 'none';
                toggleBtn.textContent = 'ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ';
                submitBtn.textContent = 'ì €ì¥';
                
                // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ë³µì›
                singleModeRequiredFields.forEach(field => {
                    if (field) {
                        field.setAttribute('required', 'required');
                    }
                });
                
                // ì„ íƒëœ íŒŒì¼ë“¤ ì´ˆê¸°í™”
                selectedFiles = [];
                document.getElementById('fileItemsContainer').innerHTML = '';
            }
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
        function setupDragAndDrop() {
            const container = document.getElementById('multiUploadContainer');
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.classList.add('dragover');
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                addFiles(files);
            });

            container.addEventListener('click', () => {
                document.getElementById('multiItemImages').click();
            });

            document.getElementById('multiItemImages').addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                addFiles(files);
            });
        }

        // íŒŒì¼ ì¶”ê°€
        function addFiles(files) {
            files.forEach(file => {
                const fileId = Date.now() + Math.random();
                const fileData = {
                    id: fileId,
                    file: file,
                    name: file.name.replace(/\.[^/.]+$/, ""), // í™•ì¥ì ì œê±°
                    order: selectedFiles.length,
                    thumbnailFile: null,
                    // ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
                    frames: null,
                    columns: 16,
                    duration: null,
                    animationType: ''
                };
                
                selectedFiles.push(fileData);
            });
            
            renderFileItems();
        }

        // íŒŒì¼ ìŠ¤í‹°ì»¤ ë Œë”ë§
        function renderFileItems() {
            const container = document.getElementById('fileItemsContainer');
            container.innerHTML = '';

            selectedFiles.forEach(fileData => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <img src="${URL.createObjectURL(fileData.file)}" alt="ë¯¸ë¦¬ë³´ê¸°" class="file-preview">
                    <div class="file-info">
                        <div class="form-group">
                            <label>ìŠ¤í‹°ì»¤ ì´ë¦„</label>
                            <input type="text" value="${fileData.name}" onchange="updateFileName(${fileData.id}, this.value)">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>ìˆœì„œ</label>
                                <input type="number" value="${fileData.order}" min="0" onchange="updateFileOrder(${fileData.id}, this.value)">
                            </div>
                            <div class="form-group">
                                <label>í”„ë ˆì„ ìˆ˜</label>
                                <input type="number" value="${fileData.frames || ''}" min="1" onchange="updateFileFrames(${fileData.id}, this.value)" placeholder="ì• ë‹ˆë©”ì´ì…˜ì¸ ê²½ìš°" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>ì»¬ëŸ¼ ìˆ˜</label>
                                <input type="number" value="${fileData.columns}" min="1" max="64" onchange="updateFileColumns(${fileData.id}, this.value)" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                            <div class="form-group">
                                <label>ì§€ì†ì‹œê°„ (ms)</label>
                                <input type="number" value="${fileData.duration || ''}" min="1" onchange="updateFileDuration(${fileData.id}, this.value)" placeholder="ì• ë‹ˆë©”ì´ì…˜ì¸ ê²½ìš°" ${fileData.animationType === 'none' ? 'disabled' : ''}>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…</label>
                                <select onchange="updateFileAnimationType(${fileData.id}, this.value)">
                                    <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                                    <option value="none" ${fileData.animationType === 'none' ? 'selected' : ''}>ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ (ìŠ¤í‹¸ ì´ë¯¸ì§€)</option>
                                    <option value="loop" ${fileData.animationType === 'loop' ? 'selected' : ''}>ë°˜ë³µ (loop)</option>
                                    <option value="once" ${fileData.animationType === 'once' ? 'selected' : ''}>í•œ ë²ˆ (once)</option>
                                    <option value="pingpong" ${fileData.animationType === 'pingpong' ? 'selected' : ''}>ì™•ë³µ (pingpong)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>ì¸ë„¤ì¼ (ì„ íƒì‚¬í•­)</label>
                                <input type="file" accept="image/*" onchange="updateFileThumbnail(${fileData.id}, this.files[0])">
                            </div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button type="button" class="remove-file" onclick="removeFile(${fileData.id})">ì‚­ì œ</button>
                    </div>
                `;
                container.appendChild(fileItem);
            });
        }

        // íŒŒì¼ ì •ë³´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
        function updateFileName(fileId, name) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.name = name;
        }

        function updateFileOrder(fileId, order) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.order = parseInt(order);
        }

        function updateFileFrames(fileId, frames) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.frames = frames ? parseInt(frames) : null;
        }

        function updateFileColumns(fileId, columns) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.columns = parseInt(columns);
        }

        function updateFileDuration(fileId, duration) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.duration = duration ? parseInt(duration) : null;
        }

        function updateFileAnimationType(fileId, animationType) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) {
                fileData.animationType = animationType;
                
                // ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ ì„ íƒ ì‹œ í”„ë ˆì„ ìˆ˜ì™€ ì»¬ëŸ¼ ìˆ˜ ìë™ ì„¤ì •
                if (animationType === 'none') {
                    fileData.frames = 1;
                    fileData.columns = 1;
                    fileData.duration = null;
                } else if (animationType !== '' && animationType !== 'none') {
                    // ì• ë‹ˆë©”ì´ì…˜ ìˆìŒ ì„ íƒ ì‹œ ê¸°ë³¸ê°’ ì„¤ì •
                    if (!fileData.frames) fileData.frames = 16;
                    if (!fileData.columns) fileData.columns = 16;
                    if (!fileData.duration) fileData.duration = 1000;
                }
                
                // í™”ë©´ ë‹¤ì‹œ ë Œë”ë§
                renderFileItems();
            }
        }

        function updateFileThumbnail(fileId, thumbnailFile) {
            const fileData = selectedFiles.find(f => f.id === fileId);
            if (fileData) fileData.thumbnailFile = thumbnailFile;
        }

        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(f => f.id !== fileId);
            renderFileItems();
        }

        // ì¼ê´„ ì„¤ì • ì ìš©
        function applyBatchSettings() {
            const batchOrderStart = parseInt(document.getElementById('batchOrderStart').value) || 0;
            const batchFrames = document.getElementById('batchFrames').value;
            const batchColumns = parseInt(document.getElementById('batchColumns').value) || 16;
            const batchDuration = document.getElementById('batchDuration').value;
            const batchAnimationType = document.getElementById('batchAnimationType').value;

            selectedFiles.forEach((fileData, index) => {
                fileData.order = batchOrderStart + index;
                fileData.columns = batchColumns;
                if (batchFrames) fileData.frames = parseInt(batchFrames);
                if (batchDuration) fileData.duration = parseInt(batchDuration);
                if (batchAnimationType) fileData.animationType = batchAnimationType;
            });

            renderFileItems();
        }

        // ì¹´í…Œê³ ë¦¬ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateCategoryModal() {
            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€';
            document.getElementById('categoryForm').reset();
            document.getElementById('categoryId').value = '';
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ìŠ¤í‹°ì»¤ ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateItemModal(categoryId) {
            document.getElementById('itemModalTitle').textContent = 'ğŸ® ìƒˆ ìŠ¤í‹°ì»¤ ì¶”ê°€';
            document.getElementById('itemForm').reset();
            document.getElementById('itemCategoryId').value = categoryId;
            document.getElementById('itemId').value = '';
            document.getElementById('imagePreview').innerHTML = '';
            document.getElementById('thumbnailPreview').innerHTML = '';
            
            // ëª¨ë“œ ì´ˆê¸°í™” - ë‹¨ì¼ ëª¨ë“œë¡œ ì‹œì‘
            isMultiMode = false;
            document.getElementById('singleItemMode').style.display = 'block';
            document.getElementById('multiItemMode').style.display = 'none';
            document.getElementById('toggleModeBtn').textContent = 'ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ';
            document.getElementById('submitItemBtn').textContent = 'ì €ì¥';
            
            // ë‹¨ì¼ ëª¨ë“œ í•„ë“œë“¤ì˜ required ì†ì„± ë³µì›
            const itemNameField = document.getElementById('itemName');
            const itemImageField = document.getElementById('itemImage');
            if (itemNameField) itemNameField.setAttribute('required', 'required');
            if (itemImageField) itemImageField.setAttribute('required', 'required');
            
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
            
            const modal = document.getElementById('itemModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ìŠ¤í‹°ì»¤ ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function openEditItemModal(categoryId, itemId, itemName) {
            // ìŠ¤í‹°ì»¤ ì •ë³´ë¥¼ ì°¾ê¸° ìœ„í•´ ì¹´í…Œê³ ë¦¬ì—ì„œ ìŠ¤í‹°ì»¤ ì°¾ê¸°
            const category = categories.find(c => (c._id || c.id) === categoryId);
            if (!category || !category.items) {
                alert('ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ìŠ¤í‹°ì»¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const item = category.items.find(itm => (itm._id || itm.id) === itemId);
            if (!item) {
                alert('ìŠ¤í‹°ì»¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            document.getElementById('itemModalTitle').textContent = `ğŸ® ìŠ¤í‹°ì»¤ ìˆ˜ì •: ${itemName}`;
            document.getElementById('itemCategoryId').value = categoryId;
            document.getElementById('itemId').value = itemId;
            document.getElementById('itemName').value = item.name;
            document.getElementById('itemOrder').value = item.order || 0;
            
            // ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ ì„¤ì •
            if (item.animation) {
                document.getElementById('itemFrames').value = item.animation.frames || '';
                document.getElementById('itemColumns').value = item.animation.columns || 16;
                document.getElementById('itemDuration').value = item.animation.duration || '';
                document.getElementById('itemAnimationType').value = item.animation.type || '';
            } else {
                document.getElementById('itemFrames').value = '';
                document.getElementById('itemColumns').value = 16;
                document.getElementById('itemDuration').value = '';
                document.getElementById('itemAnimationType').value = '';
            }
            
            // ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…ì— ë”°ë¥¸ í•„ë“œ ìƒíƒœ ì´ˆê¸°í™”
            setTimeout(() => {
                handleAnimationTypeChange();
            }, 100);
            
            // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ë‹¨ì¼ ëª¨ë“œë§Œ ì‚¬ìš©
            isMultiMode = false;
            document.getElementById('singleItemMode').style.display = 'block';
            document.getElementById('multiItemMode').style.display = 'none';
            document.getElementById('toggleModeBtn').style.display = 'none'; // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ëª¨ë“œ ì „í™˜ ìˆ¨ê¹€
            document.getElementById('submitItemBtn').textContent = 'ì €ì¥';
            
            // ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” ì´ë¯¸ì§€ê°€ í•„ìˆ˜ê°€ ì•„ë‹˜ (ê¸°ì¡´ ì´ë¯¸ì§€ ìœ ì§€ ê°€ëŠ¥)
            const itemNameField = document.getElementById('itemName');
            const itemImageField = document.getElementById('itemImage');
            if (itemNameField) itemNameField.setAttribute('required', 'required');
            if (itemImageField) itemImageField.removeAttribute('required');
            
            // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
            const imagePreview = document.getElementById('imagePreview');
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            
            imagePreview.innerHTML = item.imageUrl ? 
                `<img src="${item.imageUrl}" alt="í˜„ì¬ ì´ë¯¸ì§€" class="image-preview">` : 
                '<p>í˜„ì¬ ì´ë¯¸ì§€ ì—†ìŒ</p>';
                
            thumbnailPreview.innerHTML = item.thumbnailUrl ? 
                `<img src="${item.thumbnailUrl}" alt="í˜„ì¬ ì¸ë„¤ì¼" class="image-preview" style="max-width: 100px; max-height: 100px;"><br><small>í˜„ì¬ ì¸ë„¤ì¼ (${item.thumbnailSource === 'user' ? 'ì‚¬ìš©ì ì œê³µ' : 'ìë™ ìƒì„±'})</small>` : 
                '<p>í˜„ì¬ ì¸ë„¤ì¼ ì—†ìŒ</p>';
            
            const modal = document.getElementById('itemModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ìŠ¤í‹°ì»¤ ëª¨ë‹¬ ë‹«ê¸°
        function closeItemModal() {
            const modal = document.getElementById('itemModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            
            // ëª¨ë“œ ì „í™˜ ë²„íŠ¼ ë‹¤ì‹œ í‘œì‹œ
            document.getElementById('toggleModeBtn').style.display = 'inline-block';
            
            // ì„ íƒëœ íŒŒì¼ë“¤ ì´ˆê¸°í™”
            selectedFiles = [];
            document.getElementById('fileItemsContainer').innerHTML = '';
        }

        // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ì²˜ë¦¬
        document.getElementById('itemImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('imagePreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°" class="image-preview">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        document.getElementById('itemThumbnail').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const preview = document.getElementById('thumbnailPreview');
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="ì¸ë„¤ì¼ ë¯¸ë¦¬ë³´ê¸°" class="image-preview" style="max-width: 100px; max-height: 100px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        });

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('uploadStatus').textContent = `${current}/${total} ì—…ë¡œë“œ ì¤‘...`;
        }

        // ì¹´í…Œê³ ë¦¬ í¼ ì œì¶œ
        document.getElementById('categoryForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('categoryId').value;
            const isEdit = !!categoryId;
            
            // ì œì¶œ ë²„íŠ¼ ì°¾ê¸° ë° ë¹„í™œì„±í™”
            const submitBtn = e.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? 'ìˆ˜ì • ì¤‘...' : 'ì €ì¥ ì¤‘...';
            
            try {
                const formData = {
                    name: document.getElementById('categoryName').value,
                    type: document.getElementById('categoryType').value,
                    order: parseInt(document.getElementById('categoryOrder').value) || 0
                };

                const url = isEdit ? 
                    `/api/admin/stickers/categories/${categoryId}` : 
                    '/api/admin/stickers/categories';
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeCategoryModal();
                    loadCategories();
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì›
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });

        // ìŠ¤í‹°ì»¤ í¼ ì œì¶œ
        document.getElementById('itemForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const categoryId = document.getElementById('itemCategoryId').value;
            const itemId = document.getElementById('itemId').value;
            const isEdit = !!itemId;

            if (isMultiMode && !isEdit) {
                // ë‹¤ì¤‘ ì—…ë¡œë“œ ëª¨ë“œ - íŒŒì¼ ì„ íƒ ê²€ì¦
                if (selectedFiles.length === 0) {
                    alert('ì—…ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                // íŒŒì¼ë³„ ì´ë¦„ ê²€ì¦
                for (let fileData of selectedFiles) {
                    if (!fileData.name || fileData.name.trim() === '') {
                        alert('ëª¨ë“  íŒŒì¼ì˜ ìŠ¤í‹°ì»¤ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                        return;
                    }
                }
                
                await handleMultipleUpload(categoryId);
            } else {
                // ë‹¨ì¼ ì—…ë¡œë“œ ëª¨ë“œ - ê¸°ì¡´ ê²€ì¦ ë¡œì§
                const itemName = document.getElementById('itemName').value;
                const imageFile = document.getElementById('itemImage').files[0];
                
                if (!itemName || itemName.trim() === '') {
                    alert('ìŠ¤í‹°ì»¤ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }
                
                if (!isEdit && !imageFile) {
                    alert('ìƒˆ ìŠ¤í‹°ì»¤ì„ ì¶”ê°€í•  ë•ŒëŠ” ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }
                
                await handleSingleUpload(categoryId, itemId, isEdit);
            }
        });

        // ë‹¨ì¼ ì—…ë¡œë“œ ì²˜ë¦¬
        async function handleSingleUpload(categoryId, itemId, isEdit) {
            const submitBtn = document.getElementById('submitItemBtn');
            const originalText = submitBtn.textContent;
            
            // ë²„íŠ¼ ë¹„í™œì„±í™” ë° ë¡œë”© ìƒíƒœ í‘œì‹œ
            submitBtn.disabled = true;
            submitBtn.textContent = isEdit ? 'ìˆ˜ì • ì¤‘...' : 'ì €ì¥ ì¤‘...';
            
            try {
                const formData = new FormData();
                formData.append('name', document.getElementById('itemName').value);
                formData.append('order', document.getElementById('itemOrder').value);

                // ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ ì¶”ê°€
                const frames = document.getElementById('itemFrames').value;
                const columns = document.getElementById('itemColumns').value;
                const duration = document.getElementById('itemDuration').value;
                const animationType = document.getElementById('itemAnimationType').value;

                if (frames) formData.append('frames', frames);
                if (columns) formData.append('columns', columns);
                if (duration) formData.append('duration', duration);
                if (animationType) formData.append('animationType', animationType);

                const imageFile = document.getElementById('itemImage').files[0];
                const thumbnailFile = document.getElementById('itemThumbnail').files[0];

                if (!isEdit && !imageFile) {
                    alert('ìƒˆ ìŠ¤í‹°ì»¤ì„ ì¶”ê°€í•  ë•ŒëŠ” ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }

                if (imageFile) {
                    formData.append('image', imageFile);
                }

                if (thumbnailFile) {
                    formData.append('thumbnail', thumbnailFile);
                }

                const url = isEdit ? 
                    `/api/admin/stickers/categories/${categoryId}/items/${itemId}` : 
                    `/api/admin/stickers/categories/${categoryId}/items`;
                
                const response = await fetch(url, {
                    method: isEdit ? 'PUT' : 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    alert(`âœ… ìŠ¤í‹°ì»¤ì´ ì„±ê³µì ìœ¼ë¡œ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'}ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    closeItemModal();
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`âŒ ${isEdit ? 'ìˆ˜ì •' : 'ì¶”ê°€'} ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ìŠ¤í‹°ì»¤ ì €ì¥ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            } finally {
                // ë²„íŠ¼ ìƒíƒœ ë³µì›
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // ë‹¤ì¤‘ ì—…ë¡œë“œ ì²˜ë¦¬
        async function handleMultipleUpload(categoryId) {
            if (selectedFiles.length === 0) {
                alert('ì—…ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const submitBtn = document.getElementById('submitItemBtn');
            const originalText = submitBtn.textContent;
            
            // ë²„íŠ¼ ë¹„í™œì„±í™”
            submitBtn.disabled = true;
            submitBtn.textContent = 'ì—…ë¡œë“œ ì¤‘...';

            const progressContainer = document.getElementById('uploadProgress');
            progressContainer.style.display = 'block';
            
            let successCount = 0;
            let failCount = 0;

            try {
                for (let i = 0; i < selectedFiles.length; i++) {
                    const fileData = selectedFiles[i];
                    updateProgress(i + 1, selectedFiles.length);

                    const formData = new FormData();
                    formData.append('name', fileData.name);
                    formData.append('order', fileData.order.toString());
                    formData.append('image', fileData.file);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ ì¶”ê°€
                    if (fileData.frames) formData.append('frames', fileData.frames.toString());
                    if (fileData.columns) formData.append('columns', fileData.columns.toString());
                    if (fileData.duration) formData.append('duration', fileData.duration.toString());
                    if (fileData.animationType) formData.append('animationType', fileData.animationType);
                    
                    if (fileData.thumbnailFile) {
                        formData.append('thumbnail', fileData.thumbnailFile);
                    }

                    try {
                        const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentToken}`
                            },
                            body: formData
                        });

                        if (response.ok) {
                            successCount++;
                        } else {
                            failCount++;
                            console.error(`íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨: ${fileData.name}`);
                        }

                    } catch (error) {
                        failCount++;
                        console.error(`íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜: ${fileData.name}`, error);
                    }
                }

                if (successCount > 0) {
                    alert(`âœ… ${successCount}ê°œì˜ ìŠ¤í‹°ì»¤ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.${failCount > 0 ? ` (ì‹¤íŒ¨: ${failCount}ê°œ)` : ''}`);
                    closeItemModal();
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`âŒ ëª¨ë“  ì—…ë¡œë“œê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
                }
            } finally {
                // ì§„í–‰ë¥  ìˆ¨ê¸°ê¸° ë° ë²„íŠ¼ ìƒíƒœ ë³µì›
                progressContainer.style.display = 'none';
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // ì¹´í…Œê³ ë¦¬ ìˆ˜ì •
        function editCategory(categoryId) {
            console.log('editCategory called with categoryId:', categoryId);
            console.log('Available categories:', categories);
            
            // _id ë˜ëŠ” id í•„ë“œë¡œ ì¹´í…Œê³ ë¦¬ ì°¾ê¸°
            const category = categories.find(c => c._id === categoryId || c.id === categoryId);
            console.log('Found category:', category);
            
            if (!category) {
                console.error('Category not found with ID:', categoryId);
                console.error('Available category IDs:', categories.map(c => c._id || c.id));
                alert('ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            document.getElementById('categoryModalTitle').textContent = 'ğŸ“ ì¹´í…Œê³ ë¦¬ ìˆ˜ì •';
            document.getElementById('categoryId').value = category._id || category.id;
            document.getElementById('categoryName').value = category.name;
            document.getElementById('categoryType').value = category.type;
            document.getElementById('categoryOrder').value = category.order || 0;
            
            const modal = document.getElementById('categoryModal');
            modal.classList.add('show');
            modal.style.display = 'block';
        }

        // ì¹´í…Œê³ ë¦¬ ì‚­ì œ
        async function deleteCategory(categoryId) {
            console.log('deleteCategory called with categoryId:', categoryId);
            
            if (!confirm('ì •ë§ë¡œ ì´ ì¹´í…Œê³ ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ìŠ¤í‹°ì»¤ë„ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¹´í…Œê³ ë¦¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    loadCategories();
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¹´í…Œê³ ë¦¬ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ìŠ¤í‹°ì»¤ ì‚­ì œ
        async function deleteItem(categoryId, itemId) {
            if (!confirm('ì •ë§ë¡œ ì´ ìŠ¤í‹°ì»¤ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items/${itemId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ìŠ¤í‹°ì»¤ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`âŒ ì‚­ì œ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ìŠ¤í‹°ì»¤ ì‚­ì œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¸ë„¤ì¼ ì¬ìƒì„±
        async function regenerateThumbnail(categoryId, itemId) {
            if (!confirm('ì´ ìŠ¤í‹°ì»¤ì˜ ì¸ë„¤ì¼ì„ ì¬ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/stickers/categories/${categoryId}/items/${itemId}/regenerate-thumbnail`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì¸ë„¤ì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¬ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    // ì „ì²´ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë§Œ ì—…ë°ì´íŠ¸
                    await updateCategoryItems(categoryId);
                } else {
                    alert(`âŒ ì¸ë„¤ì¼ ì¬ìƒì„± ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì¸ë„¤ì¼ ì¬ìƒì„± ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            const categoryModal = document.getElementById('categoryModal');
            const itemModal = document.getElementById('itemModal');
            
            if (event.target === categoryModal) {
                closeCategoryModal();
            }
            if (event.target === itemModal) {
                closeItemModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="public/test/login.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ - AR ëª…í•¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .login-section,
        .result-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .login-section {
            background-color: #f9f9f9;
        }

        .result-section {
            background-color: #f0f8f0;
            display: none;
        }

        .error-section {
            background-color: #fff0f0;
            display: none;
        }

        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .logout-btn {
            background-color: #dc3545;
        }

        .logout-btn:hover {
            background-color: #c82333;
        }

        .test-btn {
            background-color: #28a745;
        }

        .test-btn:hover {
            background-color: #218838;
        }

        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .user-info {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            margin: 10px 0;
        }

        .user-info strong {
            color: #495057;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ”¥ Firebase Authentication í…ŒìŠ¤íŠ¸</h1>

        <div class="login-section" style="background-color: #fff3cd; border: 1px solid #ffeaa7;">
            <h3>âš ï¸ ì„¤ì • í•„ìš”</h3>
            <p><strong>í…ŒìŠ¤íŠ¸í•˜ê¸° ì „ì— Firebase ì„¤ì •ì„ ì™„ë£Œí•´ì•¼ í•©ë‹ˆë‹¤:</strong></p>
            <ol>
                <li>Firebase Consoleì—ì„œ í”„ë¡œì íŠ¸ ì„¤ì • â†’ ì›¹ ì•± ì¶”ê°€</li>
                <li>Authentication â†’ ë¡œê·¸ì¸ ë°©ë²• â†’ Google ì‚¬ìš© ì„¤ì •</li>
                <li>ì´ HTML íŒŒì¼ì˜ <code>firebaseConfig</code>ë¥¼ ì‹¤ì œ ê°’ìœ¼ë¡œ êµì²´</li>
                <li>ìŠ¹ì¸ëœ ë„ë©”ì¸ì— <code>localhost</code> ì¶”ê°€ (ê°œë°œìš©)</li>
            </ol>
        </div>

        <div class="login-section">
            <h3>1. Firebase ë¡œê·¸ì¸</h3>
            <p>Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì—¬ Firebase ID í† í°ì„ ë°›ì•„ì˜µë‹ˆë‹¤.</p>
            <button id="loginBtn" onclick="signInWithGoogle()">Googleë¡œ ë¡œê·¸ì¸</button>
            <button id="logoutBtn" onclick="signOut()" class="logout-btn" style="display: none;">ë¡œê·¸ì•„ì›ƒ</button>
            <div id="firebaseStatus"></div>
        </div>

        <div class="login-section">
            <h3>2. ë°±ì—”ë“œ ì¸ì¦ í…ŒìŠ¤íŠ¸</h3>
            <p>ë°›ì•„ì˜¨ Firebase ID í† í°ì„ ë°±ì—”ë“œë¡œ ì „ì†¡í•˜ì—¬ AR ëª…í•¨ ì‹œìŠ¤í…œ JWTë¥¼ ë°›ì•„ì˜µë‹ˆë‹¤.</p>
            <button id="testBackendBtn" onclick="testBackendAuth()" class="test-btn" disabled>ë°±ì—”ë“œ ì¸ì¦ í…ŒìŠ¤íŠ¸</button>
            <div id="backendStatus"></div>
        </div>

        <div id="resultSection" class="result-section">
            <h3>âœ… ì¸ì¦ ì„±ê³µ ê²°ê³¼</h3>
            <div id="resultContent"></div>
        </div>

        <div id="errorSection" class="error-section">
            <h3>âŒ ì˜¤ë¥˜ ì •ë³´</h3>
            <div id="errorContent"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut as firebaseSignOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

        // Firebase ì„¤ì • - ì‹¤ì œ í”„ë¡œì íŠ¸ ì •ë³´ë¡œ ì—…ë°ì´íŠ¸ í•„ìš”
        // ì£¼ì˜: ì‹¤ì œ ì‚¬ìš© ì‹œì—ëŠ” Firebase Consoleì—ì„œ ì •í™•í•œ ì„¤ì •ê°’ì„ í™•ì¸í•˜ì—¬ êµì²´í•˜ì„¸ìš”
        const firebaseConfig = {
            apiKey: "AIzaSyCIzVh3sVKobi_lFm8dQbx1IgnTOwIe1fM",
            authDomain: "hninepeople.firebaseapp.com",
            projectId: "hninepeople",
            storageBucket: "hninepeople.firebasestorage.app",
            messagingSenderId: "666601587213",
            appId: "1:666601587213:web:1f407eaa9c915856050b44"
        };

        // Firebase ì´ˆê¸°í™”
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();

        let currentUser = null;
        let currentIdToken = null;

        // ì „ì—­ í•¨ìˆ˜ë“¤ì„ windowì— ë“±ë¡
        window.signInWithGoogle = async function () {
            const loginBtn = document.getElementById('loginBtn');
            const status = document.getElementById('firebaseStatus');

            try {
                loginBtn.disabled = true;
                status.innerHTML = '<div class="status loading">Google ë¡œê·¸ì¸ ì¤‘...</div>';

                const result = await signInWithPopup(auth, provider);
                currentUser = result.user;
                currentIdToken = await currentUser.getIdToken();

                updateUIAfterLogin();
                status.innerHTML = '<div class="status success">âœ… Firebase ë¡œê·¸ì¸ ì„±ê³µ!</div>';

            } catch (error) {
                console.error('ë¡œê·¸ì¸ ì‹¤íŒ¨:', error);
                status.innerHTML = `<div class="status error">âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: ${error.message}</div>`;
                loginBtn.disabled = false;
            }
        };

        window.signOut = async function () {
            try {
                await firebaseSignOut(auth);
                currentUser = null;
                currentIdToken = null;
                updateUIAfterLogout();
                document.getElementById('firebaseStatus').innerHTML = '<div class="status success">âœ… ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ</div>';
            } catch (error) {
                console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:', error);
            }
        };

        window.testBackendAuth = async function () {
            const testBtn = document.getElementById('testBackendBtn');
            const status = document.getElementById('backendStatus');
            const resultSection = document.getElementById('resultSection');
            const errorSection = document.getElementById('errorSection');

            if (!currentIdToken) {
                status.innerHTML = '<div class="status error">âŒ ë¨¼ì € Firebase ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.</div>';
                return;
            }

            try {
                testBtn.disabled = true;
                status.innerHTML = '<div class="status loading">ë°±ì—”ë“œ ì¸ì¦ í…ŒìŠ¤íŠ¸ ì¤‘...</div>';

                const response = await fetch('/api/auth/firebase/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        idToken: currentIdToken
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // ì„±ê³µ
                    status.innerHTML = '<div class="status success">âœ… ë°±ì—”ë“œ ì¸ì¦ ì„±ê³µ!</div>';
                    displaySuccessResult(data);
                    resultSection.style.display = 'block';
                    errorSection.style.display = 'none';
                } else {
                    // ì‹¤íŒ¨
                    status.innerHTML = '<div class="status error">âŒ ë°±ì—”ë“œ ì¸ì¦ ì‹¤íŒ¨</div>';
                    displayErrorResult(data, response.status);
                    resultSection.style.display = 'none';
                    errorSection.style.display = 'block';
                }

            } catch (error) {
                console.error('ë°±ì—”ë“œ ì¸ì¦ ì˜¤ë¥˜:', error);
                status.innerHTML = '<div class="status error">âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ' + error.message + '</div>';
                errorSection.style.display = 'block';
                document.getElementById('errorContent').innerHTML = `<pre>${JSON.stringify({ error: error.message }, null, 2)}</pre>`;
            } finally {
                testBtn.disabled = false;
            }
        };

        function updateUIAfterLogin() {
            document.getElementById('loginBtn').style.display = 'none';
            document.getElementById('logoutBtn').style.display = 'inline-block';
            document.getElementById('testBackendBtn').disabled = false;

            // Firebase ì‚¬ìš©ì ì •ë³´ í‘œì‹œ
            const firebaseInfo = `
                <div class="user-info">
                    <strong>ì´ë¦„:</strong> <span>${currentUser.displayName || 'N/A'}</span>
                    <strong>ì´ë©”ì¼:</strong> <span>${currentUser.email}</span>
                    <strong>UID:</strong> <span>${currentUser.uid}</span>
                    <strong>ID í† í°:</strong> <span style="font-size: 10px; word-break: break-all;">${currentIdToken.substring(0, 50)}...</span>
                </div>
            `;
            document.getElementById('firebaseStatus').innerHTML += firebaseInfo;
        }

        function updateUIAfterLogout() {
            document.getElementById('loginBtn').style.display = 'inline-block';
            document.getElementById('loginBtn').disabled = false;
            document.getElementById('logoutBtn').style.display = 'none';
            document.getElementById('testBackendBtn').disabled = true;
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('backendStatus').innerHTML = '';
        }

        function displaySuccessResult(data) {
            const content = `
                <h4>ğŸ‰ AR ëª…í•¨ ì‹œìŠ¤í…œ ì¸ì¦ ì„±ê³µ!</h4>
                <div class="user-info">
                    <strong>ë©”ì‹œì§€:</strong> <span>${data.message}</span>
                    <strong>ì‚¬ìš©ì ì´ë¦„:</strong> <span>${data.user.nameKr} (${data.user.nameEn})</span>
                    <strong>ì´ë©”ì¼:</strong> <span>${data.user.email}</span>
                    <strong>AR ID:</strong> <span>${data.user.arId}</span>
                    <strong>ì—­í• :</strong> <span>${data.user.role}</span>
                    <strong>ë¶€ì„œ:</strong> <span>${data.user.part}</span>
                    <strong>ê´€ë¦¬ì:</strong> <span>${data.user.isAdmin ? 'ì˜ˆ' : 'ì•„ë‹ˆì˜¤'}</span>
                    <strong>ëª…í•¨ í™œì„±í™”:</strong> <span>${data.user.isNamecardActive ? 'ì˜ˆ' : 'ì•„ë‹ˆì˜¤'}</span>
                </div>
                <h5>JWT í† í°:</h5>
                <pre>${data.token}</pre>
                <h5>ì „ì²´ ì‘ë‹µ ë°ì´í„°:</h5>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            document.getElementById('resultContent').innerHTML = content;
        }

        function displayErrorResult(data, status) {
            const content = `
                <h4>HTTP Status: ${status}</h4>
                <pre>${JSON.stringify(data, null, 2)}</pre>
            `;
            document.getElementById('errorContent').innerHTML = content;
        }

        // ì¸ì¦ ìƒíƒœ ë³€í™” ê°ì§€
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log('ì‚¬ìš©ì ë¡œê·¸ì¸ë¨:', user.email);
            } else {
                console.log('ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒë¨');
            }
        });
    </script>
</body>

</html>
</file>

<file path="public/test/user.html">
<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ìš©ì ê´€ë¦¬ í…ŒìŠ¤íŠ¸ - AR ëª…í•¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .auth-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"], input[type="email"], input[type="tel"], textarea {
            width: 200px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #28a745;
        }

        .btn-success:hover {
            background-color: #218838;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .modal {
            display: none !important;
            position: fixed !important;
            z-index: 9999 !important;
            left: 0 !important;
            top: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        .modal.show {
            display: block !important;
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        .form-group {
            margin: 15px 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            box-sizing: border-box;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status.loading {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .page-info {
            color: #666;
            font-size: 14px;
        }

        .admin-badge {
            background-color: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        .active-badge {
            background-color: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ‘¥ ì‚¬ìš©ì ê´€ë¦¬ í…ŒìŠ¤íŠ¸ í˜ì´ì§€</h1>

        <!-- ì¸ì¦ ì„¹ì…˜ -->
        <div class="section auth-section">
            <h3>ğŸ” ê´€ë¦¬ì ì¸ì¦</h3>
            <p>ì‚¬ìš©ì ê´€ë¦¬ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <div class="controls">
                <input type="text" id="adminToken" placeholder="ê´€ë¦¬ì JWT í† í° ì…ë ¥" style="width: 400px;">
                <button onclick="setAuthToken()">í† í° ì„¤ì •</button>
                <button onclick="getAdminToken()" class="btn-success">ê´€ë¦¬ì í† í° ìƒì„±</button>
                <button onclick="clearAuthToken()" class="btn-secondary">í† í° ì´ˆê¸°í™”</button>
            </div>
            <div id="authStatus"></div>
        </div>

        <!-- ì‚¬ìš©ì ì¶”ê°€ ì„¹ì…˜ -->
        <div class="section">
            <h3>â• ìƒˆ ì‚¬ìš©ì ì¶”ê°€</h3>
            <button onclick="openCreateUserModal()" class="btn-success">ìƒˆ ì‚¬ìš©ì ì¶”ê°€</button>
        </div>

        <!-- ì‚¬ìš©ì ëª©ë¡ ì„¹ì…˜ -->
        <div class="section">
            <h3>ğŸ“‹ ì‚¬ìš©ì ëª©ë¡</h3>
            
            <!-- ê²€ìƒ‰ ë° í•„í„° ì»¨íŠ¸ë¡¤ -->
            <div class="controls">
                <input type="text" id="searchInput" placeholder="ì´ë¦„, ì´ë©”ì¼, AR ID ê²€ìƒ‰">
                <select id="roleFilter">
                    <option value="">ì „ì²´ ì—­í• </option>
                    <option value="User">User</option>
                    <option value="Admin">Admin</option>
                    <option value="Manager">Manager</option>
                </select>
                <select id="adminFilter">
                    <option value="">ì „ì²´</option>
                    <option value="true">ê´€ë¦¬ìë§Œ</option>
                    <option value="false">ì¼ë°˜ ì‚¬ìš©ìë§Œ</option>
                </select>
                <select id="activeFilter">
                    <option value="">ì „ì²´</option>
                    <option value="true">í™œì„±í™”ëœ ëª…í•¨ë§Œ</option>
                    <option value="false">ë¹„í™œì„±í™”ëœ ëª…í•¨ë§Œ</option>
                </select>
                <button onclick="loadUsers()" class="btn-success">ê²€ìƒ‰</button>
                <button onclick="clearFilters()" class="btn-secondary">í•„í„° ì´ˆê¸°í™”</button>
            </div>

            <div id="userListStatus"></div>
            
            <!-- ì‚¬ìš©ì í…Œì´ë¸” -->
            <div id="userTableContainer">
                <table id="userTable" style="display: none;">
                    <thead>
                        <tr>
                            <th>AR ID</th>
                            <th>ì´ë¦„</th>
                            <th>ì´ë©”ì¼</th>
                            <th>ì—­í• </th>
                            <th>ë¶€ì„œ</th>
                            <th>ì „í™”ë²ˆí˜¸</th>
                            <th>ìƒíƒœ</th>
                            <th>ì‘ì—…</th>
                        </tr>
                    </thead>
                    <tbody id="userTableBody">
                    </tbody>
                </table>
            </div>

            <!-- í˜ì´ì§€ë„¤ì´ì…˜ -->
            <div class="pagination" id="pagination" style="display: none;">
                <button onclick="changePage(-1)" id="prevBtn">ì´ì „</button>
                <span class="page-info" id="pageInfo"></span>
                <button onclick="changePage(1)" id="nextBtn">ë‹¤ìŒ</button>
            </div>
        </div>
    </div>

    <!-- ì‚¬ìš©ì í¸ì§‘ ëª¨ë‹¬ -->
    <div id="editUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h3>âœï¸ ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •</h3>
            <form id="editUserForm">
                <input type="hidden" id="editUserId">
                
                <div class="form-group">
                    <label>ì´ë©”ì¼ (ìˆ˜ì • ë¶ˆê°€)</label>
                    <input type="email" id="editEmail" disabled>
                </div>
                
                <div class="form-group">
                    <label>AR ID (ìˆ˜ì • ë¶ˆê°€)</label>
                    <input type="text" id="editArId" disabled>
                </div>
                
                <div class="form-group">
                    <label for="editNameKr">í•œê¸€ëª… *</label>
                    <input type="text" id="editNameKr" required>
                </div>
                
                <div class="form-group">
                    <label for="editNameEn">ì˜ë¬¸ëª…</label>
                    <input type="text" id="editNameEn">
                </div>
                
                <div class="form-group">
                    <label for="editRole">ì—­í• </label>
                    <input type="text" id="editRole">
                </div>
                
                <div class="form-group">
                    <label for="editPart">ë¶€ì„œ</label>
                    <input type="text" id="editPart">
                </div>
                
                <div class="form-group">
                    <label for="editPhone">ì „í™”ë²ˆí˜¸ *</label>
                    <input type="tel" id="editPhone" required>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="editIsAdmin">
                        <label for="editIsAdmin">ê´€ë¦¬ì ê¶Œí•œ</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="editIsNamecardActive">
                        <label for="editIsNamecardActive">ëª…í•¨ í™œì„±í™”</label>
                    </div>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeEditModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success">ì €ì¥</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ì‚¬ìš©ì ìƒì„± ëª¨ë‹¬ -->
    <div id="createUserModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCreateModal()">&times;</span>
            <h3>â• ìƒˆ ì‚¬ìš©ì ì¶”ê°€</h3>
            <form id="createUserForm">
                <div class="form-group">
                    <label for="createEmail">ì´ë©”ì¼ *</label>
                    <input type="email" id="createEmail" required>
                </div>
                
                <div class="form-group">
                    <label for="createArId">AR ID * (3ìë¦¬)</label>
                    <input type="text" id="createArId" maxlength="3" required>
                </div>
                
                <div class="form-group">
                    <label for="createNameKr">í•œê¸€ëª… *</label>
                    <input type="text" id="createNameKr" required>
                </div>
                
                <div class="form-group">
                    <label for="createNameEn">ì˜ë¬¸ëª…</label>
                    <input type="text" id="createNameEn">
                </div>
                
                <div class="form-group">
                    <label for="createRole">ì—­í• </label>
                    <input type="text" id="createRole" value="User">
                </div>
                
                <div class="form-group">
                    <label for="createPart">ë¶€ì„œ</label>
                    <input type="text" id="createPart">
                </div>
                
                <div class="form-group">
                    <label for="createPhone">ì „í™”ë²ˆí˜¸ *</label>
                    <input type="tel" id="createPhone" required>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="createIsAdmin">
                        <label for="createIsAdmin">ê´€ë¦¬ì ê¶Œí•œ</label>
                    </div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="createIsNamecardActive">
                        <label for="createIsNamecardActive">ëª…í•¨ í™œì„±í™”</label>
                    </div>
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" onclick="closeCreateModal()" class="btn-secondary">ì·¨ì†Œ</button>
                    <button type="submit" class="btn-success">ì¶”ê°€</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentToken = '';
        let currentPage = 1;
        let totalPages = 1;
        let users = [];

        // ì¸ì¦ í† í° ì„¤ì •
        function setAuthToken() {
            const token = document.getElementById('adminToken').value.trim();
            if (!token) {
                showStatus('authStatus', 'error', 'í† í°ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            currentToken = token;
            localStorage.setItem('adminToken', token);
            showStatus('authStatus', 'success', 'âœ… ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // í† í° ì„¤ì • í›„ ì‚¬ìš©ì ëª©ë¡ ìë™ ë¡œë“œ
            loadUsers();
        }

        // ê´€ë¦¬ì í† í° ìƒì„±
        async function getAdminToken() {
            try {
                showStatus('authStatus', 'loading', 'ê´€ë¦¬ì í† í°ì„ ìƒì„±í•˜ëŠ” ì¤‘...');

                const response = await fetch('/api/auth/test-token/001', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    const token = data.token;
                    document.getElementById('adminToken').value = token;
                    currentToken = token;
                    localStorage.setItem('adminToken', token);
                    
                    showStatus('authStatus', 'success', `âœ… ê´€ë¦¬ì í† í°ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìš©ì: ${data.user.nameKr})`);
                    
                    // í† í° ìƒì„± í›„ ì‚¬ìš©ì ëª©ë¡ ìë™ ë¡œë“œ
                    loadUsers();
                } else {
                    showStatus('authStatus', 'error', `âŒ í† í° ìƒì„± ì‹¤íŒ¨: ${data.message || 'ê´€ë¦¬ì ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'}`);
                }

            } catch (error) {
                console.error('í† í° ìƒì„± ì˜¤ë¥˜:', error);
                showStatus('authStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // í† í° ì´ˆê¸°í™”
        function clearAuthToken() {
            currentToken = '';
            localStorage.removeItem('adminToken');
            document.getElementById('adminToken').value = '';
            showStatus('authStatus', 'success', 'ğŸ”„ í† í°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
            
            // ì‚¬ìš©ì í…Œì´ë¸” ìˆ¨ê¸°ê¸°
            document.getElementById('userTable').style.display = 'none';
            document.getElementById('pagination').style.display = 'none';
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í† í° ë³µì›
        window.addEventListener('load', function() {
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                document.getElementById('adminToken').value = savedToken;
                currentToken = savedToken;
                showStatus('authStatus', 'success', 'âœ… ì €ì¥ëœ í† í°ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                loadUsers();
            }
        });

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ
        async function loadUsers(page = 1) {
            if (!currentToken) {
                showStatus('userListStatus', 'error', 'âŒ ë¨¼ì € ê´€ë¦¬ì í† í°ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.');
                return;
            }

            const searchInput = document.getElementById('searchInput').value.trim();
            const roleFilter = document.getElementById('roleFilter').value;
            const adminFilter = document.getElementById('adminFilter').value;
            const activeFilter = document.getElementById('activeFilter').value;

            try {
                showStatus('userListStatus', 'loading', 'ì‚¬ìš©ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

                const params = new URLSearchParams({
                    page: page.toString(),
                    limit: '10'
                });

                if (searchInput) params.append('search', searchInput);
                if (roleFilter) params.append('role', roleFilter);
                if (adminFilter) params.append('isAdmin', adminFilter);
                if (activeFilter) params.append('isNamecardActive', activeFilter);

                const response = await fetch(`/api/admin/users?${params}`, {
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    users = data.users;
                    currentPage = data.currentPage;
                    totalPages = data.totalPages;
                    
                    renderUserTable();
                    renderPagination();
                    
                    showStatus('userListStatus', 'success', `âœ… ${data.total}ëª…ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.`);
                } else {
                    showStatus('userListStatus', 'error', `âŒ ${data.message || 'ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨'}`);
                }

            } catch (error) {
                console.error('ì‚¬ìš©ì ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
                showStatus('userListStatus', 'error', `âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì‚¬ìš©ì í…Œì´ë¸” ë Œë”ë§
        function renderUserTable() {
            const tbody = document.getElementById('userTableBody');
            tbody.innerHTML = '';

            users.forEach(user => {
                // ID í•„ë“œ í™•ì¸ - _id ë˜ëŠ” id ì‚¬ìš©
                const userId = user._id || user.id;
                console.log('User object:', user);
                console.log('User ID:', userId);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${user.arId}</td>
                    <td>${user.nameKr}${user.nameEn ? ' (' + user.nameEn + ')' : ''}</td>
                    <td>${user.email}</td>
                    <td>${user.role}</td>
                    <td>${user.part}</td>
                    <td>${user.phone}</td>
                    <td>
                        ${user.isAdmin ? '<span class="admin-badge">ê´€ë¦¬ì</span>' : ''}
                        ${user.isNamecardActive ? '<span class="active-badge">í™œì„±</span>' : ''}
                    </td>
                    <td>
                        <button onclick="openEditModal('${userId}')" class="btn-success" style="padding: 5px 10px; font-size: 12px;">ìˆ˜ì •</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('userTable').style.display = 'table';
        }

        // í˜ì´ì§€ë„¤ì´ì…˜ ë Œë”ë§
        function renderPagination() {
            const pagination = document.getElementById('pagination');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            pageInfo.textContent = `${currentPage} / ${totalPages} í˜ì´ì§€`;
            prevBtn.disabled = currentPage <= 1;
            nextBtn.disabled = currentPage >= totalPages;

            pagination.style.display = 'flex';
        }

        // í˜ì´ì§€ ë³€ê²½
        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                loadUsers(newPage);
            }
        }

        // í•„í„° ì´ˆê¸°í™”
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('roleFilter').value = '';
            document.getElementById('adminFilter').value = '';
            document.getElementById('activeFilter').value = '';
            loadUsers(1);
        }

        // ì‚¬ìš©ì í¸ì§‘ ëª¨ë‹¬ ì—´ê¸°
        function openEditModal(userId) {
            console.log('openEditModal called with userId:', userId);
            console.log('Available users:', users);
            
            // _id ë˜ëŠ” id í•„ë“œë¡œ ì‚¬ìš©ì ì°¾ê¸°
            const user = users.find(u => u._id === userId || u.id === userId);
            console.log('Found user:', user);
            
            if (!user) {
                console.error('User not found with ID:', userId);
                console.error('Available user IDs:', users.map(u => u._id || u.id));
                alert('ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // ëª¨ë‹¬ ìš”ì†Œ í™•ì¸
            const modal = document.getElementById('editUserModal');
            if (!modal) {
                console.error('Edit modal element not found');
                alert('í¸ì§‘ ëª¨ë‹¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                document.getElementById('editUserId').value = user._id || user.id;
                document.getElementById('editEmail').value = user.email;
                document.getElementById('editArId').value = user.arId;
                document.getElementById('editNameKr').value = user.nameKr;
                document.getElementById('editNameEn').value = user.nameEn || '';
                document.getElementById('editRole').value = user.role;
                document.getElementById('editPart').value = user.part;
                document.getElementById('editPhone').value = user.phone;
                document.getElementById('editIsAdmin').checked = user.isAdmin;
                document.getElementById('editIsNamecardActive').checked = user.isNamecardActive;

                console.log('Modal display before:', modal.style.display);
                
                // CSS í´ë˜ìŠ¤ì™€ ì¸ë¼ì¸ ìŠ¤íƒ€ì¼ ëª¨ë‘ ì ìš©
                modal.classList.add('show');
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.zIndex = '9999';
                
                console.log('Modal display after:', modal.style.display);
                console.log('Modal classList:', modal.classList.toString());
                
            } catch (error) {
                console.error('Error opening edit modal:', error);
                alert('ëª¨ë‹¬ì„ ì—¬ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // ì‚¬ìš©ì í¸ì§‘ ëª¨ë‹¬ ë‹«ê¸°
        function closeEditModal() {
            const modal = document.getElementById('editUserModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ì‚¬ìš©ì ìƒì„± ëª¨ë‹¬ ì—´ê¸°
        function openCreateUserModal() {
            document.getElementById('createUserForm').reset();
            document.getElementById('createRole').value = 'User';
            
            const modal = document.getElementById('createUserModal');
            modal.classList.add('show');
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.zIndex = '9999';
        }

        // ì‚¬ìš©ì ìƒì„± ëª¨ë‹¬ ë‹«ê¸°
        function closeCreateModal() {
            const modal = document.getElementById('createUserModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
        }

        // ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •
        document.getElementById('editUserForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            if (!currentToken) {
                alert('ê´€ë¦¬ì í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const userId = document.getElementById('editUserId').value;
            const updateData = {
                nameKr: document.getElementById('editNameKr').value,
                nameEn: document.getElementById('editNameEn').value,
                role: document.getElementById('editRole').value,
                part: document.getElementById('editPart').value,
                phone: document.getElementById('editPhone').value,
                isAdmin: document.getElementById('editIsAdmin').checked,
                isNamecardActive: document.getElementById('editIsNamecardActive').checked
            };

            try {
                const response = await fetch(`/api/admin/users/${userId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ì‚¬ìš©ì ì •ë³´ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    closeEditModal();
                    loadUsers(currentPage);
                } else {
                    alert(`âŒ ìˆ˜ì • ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì‚¬ìš©ì ìˆ˜ì • ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        });

        // ìƒˆ ì‚¬ìš©ì ìƒì„±
        document.getElementById('createUserForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const createData = {
                email: document.getElementById('createEmail').value,
                arId: document.getElementById('createArId').value,
                nameKr: document.getElementById('createNameKr').value,
                nameEn: document.getElementById('createNameEn').value,
                role: document.getElementById('createRole').value,
                part: document.getElementById('createPart').value,
                phone: document.getElementById('createPhone').value,
                isAdmin: document.getElementById('createIsAdmin').checked,
                isNamecardActive: document.getElementById('createIsNamecardActive').checked
            };

            try {
                const response = await fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(createData)
                });

                const data = await response.json();

                if (response.ok) {
                    alert('âœ… ìƒˆ ì‚¬ìš©ìê°€ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    closeCreateModal();
                    loadUsers(currentPage);
                } else {
                    alert(`âŒ ì‚¬ìš©ì ì¶”ê°€ ì‹¤íŒ¨: ${data.message}`);
                }

            } catch (error) {
                console.error('ì‚¬ìš©ì ìƒì„± ì˜¤ë¥˜:', error);
                alert(`âŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`);
            }
        });

        // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
        window.onclick = function(event) {
            const editModal = document.getElementById('editUserModal');
            const createModal = document.getElementById('createUserModal');
            
            if (event.target === editModal) {
                closeEditModal();
            }
            if (event.target === createModal) {
                closeCreateModal();
            }
        }
    </script>
</body>

</html>
</file>

<file path="scripts/generate-ssl-cert-fixed.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL ë””ë ‰í† ë¦¬ ìƒì„±
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// ë¡œì»¬ IP ì£¼ì†Œ ì°¾ê¸°
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`ğŸ” ë¡œì»¬ IP ì£¼ì†Œ: ${localIp}`);

// ê°œì„ ëœ OpenSSL ì„¤ì • íŒŒì¼ ìƒì„±
const opensslConfig = `
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
C = KR
ST = Seoul
L = Seoul
O = AR Namecard Dev
OU = Development
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
DNS.3 = 127.0.0.1
DNS.4 = ${localIp}
IP.1 = 127.0.0.1
IP.2 = ::1
IP.3 = ${localIp}
IP.4 = 192.168.1.1
IP.5 = 10.0.0.1
`;

const configPath = path.join(sslDir, 'openssl.conf');
fs.writeFileSync(configPath, opensslConfig);

try {
  console.log('ğŸ” ê°œì„ ëœ SSL ì¸ì¦ì„œ ìƒì„± ì¤‘...');
  
  // ê¸°ì¡´ ì¸ì¦ì„œ ë°±ì—…
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath)) {
    fs.renameSync(keyPath, keyPath + '.backup');
    console.log('ğŸ“¦ ê¸°ì¡´ ê°œì¸í‚¤ ë°±ì—… ì™„ë£Œ');
  }
  
  if (fs.existsSync(certPath)) {
    fs.renameSync(certPath, certPath + '.backup');
    console.log('ğŸ“¦ ê¸°ì¡´ ì¸ì¦ì„œ ë°±ì—… ì™„ë£Œ');
  }
  
  // ê°œì¸í‚¤ ìƒì„± (RSA 2048ë¹„íŠ¸)
  console.log('ğŸ”‘ ê°œì¸í‚¤ ìƒì„± ì¤‘...');
  execSync(`openssl genrsa -out "${keyPath}" 2048`, { stdio: 'inherit' });
  
  // ì¸ì¦ì„œ ìƒì„± (365ì¼ ìœ íš¨)
  console.log('ğŸ“œ ì¸ì¦ì„œ ìƒì„± ì¤‘...');
  execSync(`openssl req -new -x509 -key "${keyPath}" -out "${certPath}" -days 365 -config "${configPath}"`, { stdio: 'inherit' });
  
  // ì¸ì¦ì„œ ê²€ì¦
  console.log('ğŸ” ì¸ì¦ì„œ ê²€ì¦ ì¤‘...');
  const certInfo = execSync(`openssl x509 -in "${certPath}" -text -noout`, { encoding: 'utf8' });
  
  console.log('âœ… SSL ì¸ì¦ì„œ ìƒì„± ì™„ë£Œ!');
  console.log(`ğŸ“ ì¸ì¦ì„œ ìœ„ì¹˜: ${sslDir}`);
  console.log(`ğŸ”‘ ê°œì¸í‚¤: ${keyPath}`);
  console.log(`ğŸ“œ ì¸ì¦ì„œ: ${certPath}`);
  
  // ì„¤ì • íŒŒì¼ ì‚­ì œ
  fs.unlinkSync(configPath);
  
  console.log('\nğŸš€ HTTPS ì„œë²„ ì„¤ì •:');
  console.log('1. .env íŒŒì¼ì— ENABLE_HTTPS=true ì„¤ì •');
  console.log('2. npm run dev ë˜ëŠ” npm startë¡œ ì„œë²„ ì‹¤í–‰');
  console.log(`3. https://localhost:3443 ë˜ëŠ” https://${localIp}:3443 ì ‘ì†`);
  
  console.log('\nâš ï¸  ë¸Œë¼ìš°ì € ê²½ê³  í•´ê²° ë°©ë²•:');
  console.log('- Chrome: "ê³ ê¸‰" â†’ "localhost(ì•ˆì „í•˜ì§€ ì•ŠìŒ)ë¡œ ì´ë™" í´ë¦­');
  console.log('- Firefox: "ê³ ê¸‰" â†’ "ìœ„í—˜ì„ ê°ìˆ˜í•˜ê³  ê³„ì†" í´ë¦­');
  console.log('- Safari: "ê³ ê¸‰" â†’ "ì›¹ì‚¬ì´íŠ¸ ë°©ë¬¸" í´ë¦­');
  
  console.log('\nğŸ”’ ì¸ì¦ì„œ ì •ë³´:');
  console.log(`- ìœ íš¨ê¸°ê°„: 365ì¼`);
  console.log(`- ì§€ì› ë„ë©”ì¸: localhost, ${localIp}`);
  console.log(`- í‚¤ ì‚¬ìš©: digitalSignature, keyEncipherment`);
  console.log(`- í™•ì¥ í‚¤ ì‚¬ìš©: serverAuth, clientAuth`);
  
} catch (error) {
  console.error('âŒ SSL ì¸ì¦ì„œ ìƒì„± ì‹¤íŒ¨:', error.message);
  console.log('\nğŸ’¡ OpenSSLì´ ì„¤ì¹˜ë˜ì§€ ì•Šì€ ê²½ìš°:');
  console.log('- macOS: brew install openssl');
  console.log('- Ubuntu: sudo apt-get install openssl');
  console.log('- Windows: https://slproweb.com/products/Win32OpenSSL.html');
  
  // ë°±ì—… íŒŒì¼ ë³µêµ¬
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath + '.backup')) {
    fs.renameSync(keyPath + '.backup', keyPath);
    console.log('ğŸ”„ ê¸°ì¡´ ê°œì¸í‚¤ ë³µêµ¬ ì™„ë£Œ');
  }
  
  if (fs.existsSync(certPath + '.backup')) {
    fs.renameSync(certPath + '.backup', certPath);
    console.log('ğŸ”„ ê¸°ì¡´ ì¸ì¦ì„œ ë³µêµ¬ ì™„ë£Œ');
  }
  
  process.exit(1);
}
</file>

<file path="scripts/generate-ssl-cert.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL ë””ë ‰í† ë¦¬ ìƒì„±
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// ë¡œì»¬ IP ì£¼ì†Œ ì°¾ê¸°
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`ğŸ” ë¡œì»¬ IP ì£¼ì†Œ: ${localIp}`);

// OpenSSL ì„¤ì • íŒŒì¼ ìƒì„±
const opensslConfig = `
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
C = KR
ST = Seoul
L = Seoul
O = AR Namecard Dev
CN = localhost

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = *.localhost
IP.1 = 127.0.0.1
IP.2 = ::1
IP.3 = ${localIp}
`;

const configPath = path.join(sslDir, 'openssl.conf');
fs.writeFileSync(configPath, opensslConfig);

try {
  console.log('ğŸ” SSL ì¸ì¦ì„œ ìƒì„± ì¤‘...');
  
  // ê°œì¸í‚¤ ìƒì„±
  const keyPath = path.join(sslDir, 'server.key');
  execSync(`openssl genrsa -out "${keyPath}" 2048`, { stdio: 'inherit' });
  
  // ì¸ì¦ì„œ ìƒì„±
  const certPath = path.join(sslDir, 'server.crt');
  execSync(`openssl req -new -x509 -key "${keyPath}" -out "${certPath}" -days 365 -config "${configPath}"`, { stdio: 'inherit' });
  
  console.log('âœ… SSL ì¸ì¦ì„œ ìƒì„± ì™„ë£Œ!');
  console.log(`ğŸ“ ì¸ì¦ì„œ ìœ„ì¹˜: ${sslDir}`);
  console.log(`ğŸ”‘ ê°œì¸í‚¤: ${keyPath}`);
  console.log(`ğŸ“œ ì¸ì¦ì„œ: ${certPath}`);
  
  // ì„¤ì • íŒŒì¼ ì‚­ì œ
  fs.unlinkSync(configPath);
  
  console.log('\nğŸš€ HTTPS ì„œë²„ ì„¤ì •:');
  console.log('1. .env íŒŒì¼ì— ENABLE_HTTPS=true ì„¤ì •');
  console.log('2. npm run dev ë˜ëŠ” npm startë¡œ ì„œë²„ ì‹¤í–‰');
  console.log(`3. https://localhost:3443 ë˜ëŠ” https://${localIp}:3443 ì ‘ì†`);
  
  console.log('\nâš ï¸  ë¸Œë¼ìš°ì € ê²½ê³  í•´ê²° ë°©ë²•:');
  console.log('- Chrome: "ê³ ê¸‰" â†’ "localhost(ì•ˆì „í•˜ì§€ ì•ŠìŒ)ë¡œ ì´ë™" í´ë¦­');
  console.log('- Firefox: "ê³ ê¸‰" â†’ "ìœ„í—˜ì„ ê°ìˆ˜í•˜ê³  ê³„ì†" í´ë¦­');
  console.log('- ë˜ëŠ” ë¡œì»¬ CA ì„¤ì •ìœ¼ë¡œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì¸ì¦ì„œ ë§Œë“¤ê¸°');
  
} catch (error) {
  console.error('âŒ SSL ì¸ì¦ì„œ ìƒì„± ì‹¤íŒ¨:', error.message);
  console.log('\nğŸ’¡ OpenSSLì´ ì„¤ì¹˜ë˜ì§€ ì•Šì€ ê²½ìš°:');
  console.log('- macOS: brew install openssl');
  console.log('- Ubuntu: sudo apt-get install openssl');
  console.log('- Windows: https://slproweb.com/products/Win32OpenSSL.html');
  process.exit(1);
}
</file>

<file path="scripts/migrate-avatar-colors.js">
const mongoose = require('mongoose');
const dotenv = require('dotenv');

// .env íŒŒì¼ ë¡œë“œ
dotenv.config();

// MongoDB ì—°ê²°
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/ar_namecard');
    console.log('âœ… MongoDB ì—°ê²° ì„±ê³µ');
  } catch (error) {
    console.error('âŒ MongoDB ì—°ê²° ì‹¤íŒ¨:', error);
    process.exit(1);
  }
};

// AvatarCategory ìŠ¤í‚¤ë§ˆ ì •ì˜
const avatarOptionSchema = new mongoose.Schema({
  name: String,
  imageUrl: String,
  modelUrl: String,
  thumbnailUrl: String,
  thumbnailSource: String,
  color: mongoose.Schema.Types.Mixed, // ë‹¤ì–‘í•œ íƒ€ì… í—ˆìš©
  order: Number
}, { timestamps: true });

const avatarCategorySchema = new mongoose.Schema({
  name: String,
  type: String,
  options: [avatarOptionSchema],
  order: Number
}, { timestamps: true });

const AvatarCategory = mongoose.model('AvatarCategory', avatarCategorySchema);

// ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜
async function migrateAvatarColors() {
  try {
    console.log('ğŸ”„ ì•„ë°”íƒ€ ì»¬ëŸ¬ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...');
    
    const categories = await AvatarCategory.find({});
    let totalUpdated = 0;
    
    for (const category of categories) {
      let categoryUpdated = false;
      
      for (const option of category.options) {
        // ì˜ëª»ëœ í˜•íƒœì˜ color ë°ì´í„° ê°ì§€
        if (option.color && typeof option.color === 'object' && !Array.isArray(option.color)) {
          // ê°ì²´ í˜•íƒœë¡œ ì €ì¥ëœ ê²½ìš° (ì˜ˆ: {"0": "#", "1": "0", ...})
          if (option.color.hasOwnProperty('0') && option.color.hasOwnProperty('1')) {
            console.log(`ğŸ”§ ì˜ëª»ëœ ì»¬ëŸ¬ ë°ì´í„° ë°œê²¬: ${category.name} - ${option.name}`);
            
            // ì›ë³¸ ìƒ‰ìƒ ë¬¸ìì—´ ë³µì›
            let colorString = '';
            for (let i = 0; option.color.hasOwnProperty(i.toString()); i++) {
              colorString += option.color[i.toString()];
            }
            
            console.log(`   ë³µì›ëœ ì»¬ëŸ¬: ${colorString}`);
            
            // ìƒˆë¡œìš´ í˜•íƒœë¡œ ë³€í™˜
            if (colorString && option.imageUrl) {
              const colorName = colorString === '#000000' ? 'Black' : 
                              colorString === '#ffffff' ? 'White' : 
                              colorString.startsWith('#') ? colorString : 'Default';
              
              option.color = [{
                colorName: colorName,
                imageUrl: option.imageUrl
              }];
              
              categoryUpdated = true;
              totalUpdated++;
              console.log(`   âœ… ë³€í™˜ ì™„ë£Œ: ${colorName}`);
            }
          }
        }
        // ë¬¸ìì—´ í˜•íƒœì˜ color ë°ì´í„° ë³€í™˜
        else if (typeof option.color === 'string' && option.imageUrl) {
          console.log(`ğŸ”§ ë¬¸ìì—´ ì»¬ëŸ¬ ë°ì´í„° ë³€í™˜: ${category.name} - ${option.name} (${option.color})`);
          
          const colorName = option.color === '#000000' ? 'Black' : 
                          option.color === '#ffffff' ? 'White' : 
                          option.color;
          
          option.color = [{
            colorName: colorName,
            imageUrl: option.imageUrl
          }];
          
          categoryUpdated = true;
          totalUpdated++;
          console.log(`   âœ… ë³€í™˜ ì™„ë£Œ: ${colorName}`);
        }
        // colorê°€ ì—†ê³  imageUrlë§Œ ìˆëŠ” ê²½ìš°
        else if (!option.color && option.imageUrl) {
          console.log(`ğŸ”§ ì»¬ëŸ¬ ì—†ëŠ” ì˜µì…˜ ì²˜ë¦¬: ${category.name} - ${option.name}`);
          
          option.color = [{
            colorName: 'Default',
            imageUrl: option.imageUrl
          }];
          
          categoryUpdated = true;
          totalUpdated++;
          console.log(`   âœ… ê¸°ë³¸ ì»¬ëŸ¬ ì˜µì…˜ ìƒì„±`);
        }
      }
      
      if (categoryUpdated) {
        await category.save();
        console.log(`ğŸ’¾ ì¹´í…Œê³ ë¦¬ ì €ì¥ ì™„ë£Œ: ${category.name}`);
      }
    }
    
    console.log(`\nğŸ‰ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!`);
    console.log(`   - ì´ ${totalUpdated}ê°œì˜ ì˜µì…˜ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    
  } catch (error) {
    console.error('âŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤‘ ì˜¤ë¥˜:', error);
  }
}

// ì‹¤í–‰
async function main() {
  await connectDB();
  await migrateAvatarColors();
  
  console.log('\nğŸ” ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ê³¼ í™•ì¸...');
  
  // ê²°ê³¼ í™•ì¸
  const categories = await AvatarCategory.find({}).limit(2);
  for (const category of categories) {
    console.log(`\nğŸ“‚ ${category.name}:`);
    for (const option of category.options.slice(0, 2)) {
      console.log(`   - ${option.name}: ${JSON.stringify(option.color, null, 2)}`);
    }
  }
  
  console.log('\nâœ¨ ì‘ì—… ì™„ë£Œ! MongoDB ì—°ê²°ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.');
  await mongoose.connection.close();
}

main().catch(console.error);
</file>

<file path="scripts/migrate-uploads-to-firebase.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import { uploadToFirebase } from '../src/config/firebase-storage';

// í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
dotenv.config({ path: '.env.local' });

interface FileMapping {
  localPath: string;
  firebaseUrl: string;
  firebasePath: string;
  success: boolean;
  error?: string;
}

interface MigrationResult {
  total: number;
  success: number;
  failed: number;
  mappings: FileMapping[];
}

// ì§€ì›ë˜ëŠ” íŒŒì¼ í™•ì¥ì
const SUPPORTED_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.pdf', '.doc', '.docx'];

// Firebaseì— ì—…ë¡œë“œí•  íŒŒì¼ì¸ì§€ í™•ì¸
const isUploadableFile = (filename: string): boolean => {
  const ext = path.extname(filename).toLowerCase();
  return SUPPORTED_EXTENSIONS.includes(ext) && !filename.startsWith('.');
};

// ë¡œì»¬ íŒŒì¼ì„ Firebase Storageë¡œ ì—…ë¡œë“œ
const uploadFileToFirebase = async (
  localFilePath: string, 
  relativePath: string
): Promise<FileMapping> => {
  const mapping: FileMapping = {
    localPath: localFilePath,
    firebaseUrl: '',
    firebasePath: '',
    success: false
  };

  try {
    // íŒŒì¼ ì½ê¸°
    const fileBuffer = await fs.readFile(localFilePath);
    const stats = await fs.stat(localFilePath);
    
    // MIME íƒ€ì… ì¶”ì •
    const ext = path.extname(localFilePath).toLowerCase();
    let mimetype = 'application/octet-stream';
    if (ext === '.png') mimetype = 'image/png';
    else if (ext === '.jpg' || ext === '.jpeg') mimetype = 'image/jpeg';
    else if (ext === '.gif') mimetype = 'image/gif';
    else if (ext === '.pdf') mimetype = 'application/pdf';

    // Express.Multer.File í˜•íƒœë¡œ ë³€í™˜
    const file: Express.Multer.File = {
      fieldname: 'file',
      originalname: path.basename(localFilePath),
      encoding: '7bit',
      mimetype: mimetype,
      buffer: fileBuffer,
      size: stats.size,
      destination: '',
      filename: '',
      path: '',
      stream: null as any,
    };

    // Firebase Storageì— ì—…ë¡œë“œ
    const result = await uploadToFirebase(file, relativePath);
    
    mapping.firebaseUrl = result.url;
    mapping.firebasePath = result.path;
    mapping.success = true;
    
    console.log(`âœ… ${localFilePath} â†’ ${result.url}`);
    
  } catch (error) {
    mapping.error = error instanceof Error ? error.message : String(error);
    mapping.success = false;
    console.error(`âŒ ${localFilePath}: ${mapping.error}`);
  }

  return mapping;
};

// ë””ë ‰í† ë¦¬ ì¬ê·€ ìŠ¤ìº”
const scanDirectory = async (dirPath: string, baseDir: string): Promise<string[]> => {
  const files: string[] = [];
  
  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      
      if (entry.isDirectory()) {
        // í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¬ê·€ ìŠ¤ìº”
        const subFiles = await scanDirectory(fullPath, baseDir);
        files.push(...subFiles);
      } else if (entry.isFile() && isUploadableFile(entry.name)) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`ë””ë ‰í† ë¦¬ ìŠ¤ìº” ì˜¤ë¥˜ (${dirPath}):`, error);
  }
  
  return files;
};

// ë©”ì¸ ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜
const migrateUploadToFirebase = async (): Promise<MigrationResult> => {
  console.log('ğŸš€ Firebase Storage ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...\n');
  
  const uploadsDir = path.join(process.cwd(), 'uploads');
  const result: MigrationResult = {
    total: 0,
    success: 0,
    failed: 0,
    mappings: []
  };

  try {
    // uploads ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
    await fs.access(uploadsDir);
    
    // ëª¨ë“  íŒŒì¼ ìŠ¤ìº”
    console.log('ğŸ“ íŒŒì¼ ìŠ¤ìº” ì¤‘...');
    const allFiles = await scanDirectory(uploadsDir, uploadsDir);
    result.total = allFiles.length;
    
    console.log(`ğŸ“Š ì´ ${result.total}ê°œ íŒŒì¼ ë°œê²¬\n`);
    
    if (result.total === 0) {
      console.log('ì—…ë¡œë“œí•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
      return result;
    }

    // íŒŒì¼ë³„ ì—…ë¡œë“œ ì§„í–‰
    for (let i = 0; i < allFiles.length; i++) {
      const filePath = allFiles[i];
      const relativePath = path.relative(uploadsDir, filePath).replace(/\\/g, '/');
      const folderPath = path.dirname(relativePath) === '.' ? 'uploads/' : `uploads/${path.dirname(relativePath)}/`;
      
      console.log(`[${i + 1}/${result.total}] ${relativePath}`);
      
      const mapping = await uploadFileToFirebase(filePath, folderPath);
      result.mappings.push(mapping);
      
      if (mapping.success) {
        result.success++;
      } else {
        result.failed++;
      }
      
      // ì§„í–‰ë¥  í‘œì‹œ
      const progress = Math.round((i + 1) / result.total * 100);
      console.log(`ì§„í–‰ë¥ : ${progress}%\n`);
    }

    // ê²°ê³¼ ì €ì¥
    const mappingFile = path.join(process.cwd(), 'migration-mapping.json');
    await fs.writeFile(mappingFile, JSON.stringify(result, null, 2));
    console.log(`ğŸ“„ ë§¤í•‘ íŒŒì¼ ì €ì¥: ${mappingFile}`);

  } catch (error) {
    console.error('âŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ì˜¤ë¥˜:', error);
    throw error;
  }

  return result;
};

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
const main = async () => {
  try {
    const result = await migrateUploadToFirebase();
    
    console.log('\nğŸ‰ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!');
    console.log('='.repeat(50));
    console.log(`ì´ íŒŒì¼: ${result.total}`);
    console.log(`ì„±ê³µ: ${result.success}`);
    console.log(`ì‹¤íŒ¨: ${result.failed}`);
    console.log(`ì„±ê³µë¥ : ${Math.round(result.success / result.total * 100)}%`);
    
    if (result.failed > 0) {
      console.log('\nâŒ ì‹¤íŒ¨í•œ íŒŒì¼ë“¤:');
      result.mappings
        .filter(m => !m.success)
        .forEach(m => {
          console.log(`  - ${m.localPath}: ${m.error}`);
        });
    }
    
    console.log('\nâœ… Firebase Storage ë§ˆì´ê·¸ë ˆì´ì…˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
    
  } catch (error) {
    console.error('ğŸ’¥ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨:', error);
    process.exit(1);
  }
};

// ìŠ¤í¬ë¦½íŠ¸ê°€ ì§ì ‘ ì‹¤í–‰ëœ ê²½ìš°ì—ë§Œ main í•¨ìˆ˜ í˜¸ì¶œ
if (require.main === module) {
  main();
}

export { migrateUploadToFirebase, FileMapping, MigrationResult };
</file>

<file path="scripts/setup-mkcert.js">
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// SSL ë””ë ‰í† ë¦¬ ìƒì„±
const sslDir = path.join(__dirname, '../ssl');
if (!fs.existsSync(sslDir)) {
  fs.mkdirSync(sslDir, { recursive: true });
}

// ë¡œì»¬ IP ì£¼ì†Œ ì°¾ê¸°
function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const interface of interfaces[name]) {
      const { address, family, internal } = interface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

const localIp = getLocalIpAddress();
console.log(`ğŸ” ë¡œì»¬ IP ì£¼ì†Œ: ${localIp}`);

// mkcert ì„¤ì¹˜ í™•ì¸
function checkMkcert() {
  try {
    execSync('mkcert -version', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

// mkcert ì„¤ì¹˜ ì•ˆë‚´
function installMkcert() {
  console.log('ğŸ“¦ mkcert ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
  console.log('ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•˜ì„¸ìš”:');
  
  const platform = os.platform();
  switch (platform) {
    case 'darwin':
      console.log('ğŸ macOS:');
      console.log('  brew install mkcert');
      console.log('  brew install nss  # Firefox ì§€ì›ìš©');
      break;
    case 'linux':
      console.log('ğŸ§ Linux:');
      console.log('  # Ubuntu/Debian:');
      console.log('  sudo apt install libnss3-tools');
      console.log('  curl -JLO "https://dl.filippo.io/mkcert/latest?for=linux/amd64"');
      console.log('  chmod +x mkcert-v*-linux-amd64');
      console.log('  sudo mv mkcert-v*-linux-amd64 /usr/local/bin/mkcert');
      break;
    case 'win32':
      console.log('ğŸªŸ Windows:');
      console.log('  choco install mkcert');
      console.log('  # ë˜ëŠ” ìˆ˜ë™ ë‹¤ìš´ë¡œë“œ: https://github.com/FiloSottile/mkcert/releases');
      break;
    default:
      console.log('ğŸ’» ê¸°íƒ€ í”Œë«í¼: https://github.com/FiloSottile/mkcert#installation');
  }
  
  console.log('\nì„¤ì¹˜ í›„ ë‹¤ì‹œ ì‹¤í–‰í•˜ì„¸ìš”: node scripts/setup-mkcert.js');
  process.exit(1);
}

try {
  // mkcert ì„¤ì¹˜ í™•ì¸
  if (!checkMkcert()) {
    installMkcert();
  }
  
  console.log('âœ… mkcertê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
  
  // ë¡œì»¬ CA ì„¤ì¹˜ (ì²˜ìŒ ì‹¤í–‰ ì‹œì—ë§Œ)
  console.log('ğŸ” ë¡œì»¬ CA ì„¤ì¹˜ ì¤‘...');
  try {
    execSync('mkcert -install', { stdio: 'inherit' });
    console.log('âœ… ë¡œì»¬ CA ì„¤ì¹˜ ì™„ë£Œ');
  } catch (error) {
    console.log('â„¹ï¸  ë¡œì»¬ CAê°€ ì´ë¯¸ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
  }
  
  // ê¸°ì¡´ ì¸ì¦ì„œ ë°±ì—…
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath)) {
    fs.renameSync(keyPath, keyPath + '.backup');
    console.log('ğŸ“¦ ê¸°ì¡´ ê°œì¸í‚¤ ë°±ì—… ì™„ë£Œ');
  }
  
  if (fs.existsSync(certPath)) {
    fs.renameSync(certPath, certPath + '.backup');
    console.log('ğŸ“¦ ê¸°ì¡´ ì¸ì¦ì„œ ë°±ì—… ì™„ë£Œ');
  }
  
  // mkcertë¡œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì¸ì¦ì„œ ìƒì„±
  console.log('ğŸ“œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” SSL ì¸ì¦ì„œ ìƒì„± ì¤‘...');
  const certCommand = `mkcert -key-file "${keyPath}" -cert-file "${certPath}" localhost 127.0.0.1 ::1 ${localIp}`;
  
  execSync(certCommand, { stdio: 'inherit', cwd: sslDir });
  
  console.log('âœ… SSL ì¸ì¦ì„œ ìƒì„± ì™„ë£Œ!');
  console.log(`ğŸ“ ì¸ì¦ì„œ ìœ„ì¹˜: ${sslDir}`);
  console.log(`ğŸ”‘ ê°œì¸í‚¤: ${keyPath}`);
  console.log(`ğŸ“œ ì¸ì¦ì„œ: ${certPath}`);
  
  console.log('\nğŸš€ HTTPS ì„œë²„ ì„¤ì •:');
  console.log('1. .env íŒŒì¼ì— ENABLE_HTTPS=true ì„¤ì •');
  console.log('2. npm run dev ë˜ëŠ” npm startë¡œ ì„œë²„ ì‹¤í–‰');
  console.log(`3. https://localhost:3443 ë˜ëŠ” https://${localIp}:3443 ì ‘ì†`);
  
  console.log('\nğŸ‰ ë¸Œë¼ìš°ì € ê²½ê³  ì—†ìŒ!');
  console.log('- mkcertë¡œ ìƒì„±ëœ ì¸ì¦ì„œëŠ” ë¸Œë¼ìš°ì €ì—ì„œ ì‹ ë¢°ë©ë‹ˆë‹¤.');
  console.log('- ë³„ë„ì˜ ê²½ê³  ë¬´ì‹œ ì‘ì—…ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
  
  console.log('\nğŸ”’ ì¸ì¦ì„œ ì •ë³´:');
  console.log(`- ìœ íš¨ê¸°ê°„: ì•½ 10ë…„`);
  console.log(`- ì§€ì› ë„ë©”ì¸: localhost, 127.0.0.1, ${localIp}`);
  console.log(`- ë¸Œë¼ìš°ì € ì‹ ë¢°: Chrome, Firefox, Safari ëª¨ë‘ ì§€ì›`);
  
} catch (error) {
  console.error('âŒ SSL ì¸ì¦ì„œ ìƒì„± ì‹¤íŒ¨:', error.message);
  
  // ë°±ì—… íŒŒì¼ ë³µêµ¬
  const keyPath = path.join(sslDir, 'server.key');
  const certPath = path.join(sslDir, 'server.crt');
  
  if (fs.existsSync(keyPath + '.backup')) {
    fs.renameSync(keyPath + '.backup', keyPath);
    console.log('ğŸ”„ ê¸°ì¡´ ê°œì¸í‚¤ ë³µêµ¬ ì™„ë£Œ');
  }
  
  if (fs.existsSync(certPath + '.backup')) {
    fs.renameSync(certPath + '.backup', certPath);
    console.log('ğŸ”„ ê¸°ì¡´ ì¸ì¦ì„œ ë³µêµ¬ ì™„ë£Œ');
  }
  
  process.exit(1);
}
</file>

<file path="scripts/update-db-urls-to-firebase.ts">
import * as fs from 'fs/promises';
import * as path from 'path';
import * as dotenv from 'dotenv';
import mongoose from 'mongoose';

// í™˜ê²½ë³€ìˆ˜ ë¡œë“œ - í•„ìš”ì‹œ .env.atlasë¡œ ë³€ê²½ ê°€ëŠ¥
dotenv.config({ path: '.env.local' });

interface FileMapping {
  localPath: string;
  firebaseUrl: string;
  firebasePath: string;
  success: boolean;
  error?: string;
}

interface MigrationMappings {
  total: number;
  success: number;
  failed: number;
  mappings: FileMapping[];
}

interface UpdateResult {
  collection: string;
  field: string;
  documentId: string;
  oldValue: string;
  newValue: string;
  success: boolean;
  error?: string;
}

interface DatabaseUpdateResult {
  totalUpdates: number;
  successfulUpdates: number;
  failedUpdates: number;
  updates: UpdateResult[];
  collections: {
    [collectionName: string]: {
      documentsUpdated: number;
      fieldsUpdated: number;
    };
  };
}

// URL ë§¤í•‘ ìƒì„± í•¨ìˆ˜
const createUrlMapping = (mappings: FileMapping[]): Map<string, string> => {
  const urlMap = new Map<string, string>();
  
  mappings.forEach(mapping => {
    if (mapping.success && mapping.localPath && mapping.firebaseUrl) {
      // ì ˆëŒ€ ê²½ë¡œì—ì„œ /uploads/filename ì¶”ì¶œ
      const filename = path.basename(mapping.localPath);
      const localUrl = `/uploads/${filename}`;
      urlMap.set(localUrl, mapping.firebaseUrl);
      
      // í•˜ìœ„ í´ë”ê°€ ìˆëŠ” ê²½ìš°ë„ ì²˜ë¦¬
      const relativePath = mapping.localPath.split('/uploads/')[1];
      if (relativePath && relativePath !== filename) {
        const localUrlWithFolder = `/uploads/${relativePath}`;
        urlMap.set(localUrlWithFolder, mapping.firebaseUrl);
      }
    }
  });
  
  return urlMap;
};

// URL ì—…ë°ì´íŠ¸ í•¨ìˆ˜
const updateUrlInValue = (value: any, urlMap: Map<string, string>): { updated: boolean; newValue: any; changes: Array<{oldUrl: string; newUrl: string}> } => {
  const changes: Array<{oldUrl: string; newUrl: string}> = [];
  let updated = false;
  let newValue = value;

  if (typeof value === 'string' && value.startsWith('/uploads/')) {
    const firebaseUrl = urlMap.get(value);
    if (firebaseUrl) {
      changes.push({ oldUrl: value, newUrl: firebaseUrl });
      newValue = firebaseUrl;
      updated = true;
    }
  } else if (Array.isArray(value)) {
    const newArray = value.map(item => {
      const result = updateUrlInValue(item, urlMap);
      if (result.updated) {
        updated = true;
        changes.push(...result.changes);
      }
      return result.newValue;
    });
    if (updated) {
      newValue = newArray;
    }
  } else if (value && typeof value === 'object') {
    const newObject = { ...value };
    for (const [key, val] of Object.entries(value)) {
      const result = updateUrlInValue(val, urlMap);
      if (result.updated) {
        updated = true;
        changes.push(...result.changes);
        newObject[key] = result.newValue;
      }
    }
    if (updated) {
      newValue = newObject;
    }
  }

  return { updated, newValue, changes };
};

// avatarcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸
const updateAvatarCategories = async (urlMap: Map<string, string>): Promise<UpdateResult[]> => {
  console.log('ğŸ”„ avatarcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸ ì¤‘...');
  
  const results: UpdateResult[] = [];
  const AvatarCategory = mongoose.model('AvatarCategory', new mongoose.Schema({}, { strict: false }));
  
  try {
    const categories = await AvatarCategory.find({});
    console.log(`ğŸ“Š avatarcategories: ${categories.length}ê°œ ë¬¸ì„œ ë°œê²¬`);
    
    for (const category of categories) {
      const categoryObj = category.toObject() as any;
      let documentUpdated = false;
      const documentUpdates: UpdateResult[] = [];
      
      if (categoryObj.options && Array.isArray(categoryObj.options)) {
        for (let optionIndex = 0; optionIndex < categoryObj.options.length; optionIndex++) {
          const option = categoryObj.options[optionIndex];
          
          // imageUrl ì—…ë°ì´íŠ¸
          if (option.imageUrl) {
            const result = updateUrlInValue(option.imageUrl, urlMap);
            if (result.updated) {
              option.imageUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'avatarcategories',
                field: `options[${optionIndex}].imageUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // thumbnailUrl ì—…ë°ì´íŠ¸
          if (option.thumbnailUrl) {
            const result = updateUrlInValue(option.thumbnailUrl, urlMap);
            if (result.updated) {
              option.thumbnailUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'avatarcategories',
                field: `options[${optionIndex}].thumbnailUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // color ë°°ì—´ ì—…ë°ì´íŠ¸
          if (option.color && Array.isArray(option.color)) {
            for (let colorIndex = 0; colorIndex < option.color.length; colorIndex++) {
              const colorOption = option.color[colorIndex];
              
              // imageUrl
              if (colorOption.imageUrl) {
                const result = updateUrlInValue(colorOption.imageUrl, urlMap);
                if (result.updated) {
                  colorOption.imageUrl = result.newValue;
                  documentUpdated = true;
                  documentUpdates.push({
                    collection: 'avatarcategories',
                    field: `options[${optionIndex}].color[${colorIndex}].imageUrl`,
                    documentId: (category._id as any).toString(),
                    oldValue: result.changes[0].oldUrl,
                    newValue: result.changes[0].newUrl,
                    success: true
                  });
                }
              }
              
              // paletteImageUrl
              if (colorOption.paletteImageUrl) {
                const result = updateUrlInValue(colorOption.paletteImageUrl, urlMap);
                if (result.updated) {
                  colorOption.paletteImageUrl = result.newValue;
                  documentUpdated = true;
                  documentUpdates.push({
                    collection: 'avatarcategories',
                    field: `options[${optionIndex}].color[${colorIndex}].paletteImageUrl`,
                    documentId: (category._id as any).toString(),
                    oldValue: result.changes[0].oldUrl,
                    newValue: result.changes[0].newUrl,
                    success: true
                  });
                }
              }
              
              // resourceImages ì²˜ë¦¬
              if (colorOption.resourceImages) {
                for (const [resourceKey, resourceUrl] of Object.entries(colorOption.resourceImages)) {
                  if (typeof resourceUrl === 'string') {
                    const result = updateUrlInValue(resourceUrl, urlMap);
                    if (result.updated) {
                      colorOption.resourceImages[resourceKey] = result.newValue;
                      documentUpdated = true;
                      documentUpdates.push({
                        collection: 'avatarcategories',
                        field: `options[${optionIndex}].color[${colorIndex}].resourceImages.${resourceKey}`,
                        documentId: (category._id as any).toString(),
                        oldValue: result.changes[0].oldUrl,
                        newValue: result.changes[0].newUrl,
                        success: true
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      // ë¬¸ì„œ ì €ì¥
      if (documentUpdated) {
        try {
          await category.updateOne(categoryObj);
          results.push(...documentUpdates);
          console.log(`âœ… avatarcategories - ë¬¸ì„œ ${(category._id as any)} ì—…ë°ì´íŠ¸ ì™„ë£Œ (${documentUpdates.length}ê°œ í•„ë“œ)`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`âŒ avatarcategories - ë¬¸ì„œ ${(category._id as any)} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:`, errorMessage);
          documentUpdates.forEach(update => {
            update.success = false;
            update.error = errorMessage;
          });
          results.push(...documentUpdates);
        }
      }
    }
  } catch (error) {
    console.error('âŒ avatarcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜:', error);
  }
  
  return results;
};

// itemcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸
const updateItemCategories = async (urlMap: Map<string, string>): Promise<UpdateResult[]> => {
  console.log('ğŸ”„ itemcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸ ì¤‘...');
  
  const results: UpdateResult[] = [];
  const ItemCategory = mongoose.model('ItemCategory', new mongoose.Schema({}, { strict: false }));
  
  try {
    const categories = await ItemCategory.find({});
    console.log(`ğŸ“Š itemcategories: ${categories.length}ê°œ ë¬¸ì„œ ë°œê²¬`);
    
    for (const category of categories) {
      const categoryObj = category.toObject() as any;
      let documentUpdated = false;
      const documentUpdates: UpdateResult[] = [];
      
      if (categoryObj.items && Array.isArray(categoryObj.items)) {
        for (let itemIndex = 0; itemIndex < categoryObj.items.length; itemIndex++) {
          const item = categoryObj.items[itemIndex];
          
          // imageUrl ì—…ë°ì´íŠ¸
          if (item.imageUrl) {
            const result = updateUrlInValue(item.imageUrl, urlMap);
            if (result.updated) {
              item.imageUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].imageUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // thumbnailUrl ì—…ë°ì´íŠ¸
          if (item.thumbnailUrl) {
            const result = updateUrlInValue(item.thumbnailUrl, urlMap);
            if (result.updated) {
              item.thumbnailUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].thumbnailUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
          
          // animationUrl ì—…ë°ì´íŠ¸
          if (item.animationUrl) {
            const result = updateUrlInValue(item.animationUrl, urlMap);
            if (result.updated) {
              item.animationUrl = result.newValue;
              documentUpdated = true;
              documentUpdates.push({
                collection: 'itemcategories',
                field: `items[${itemIndex}].animationUrl`,
                documentId: (category._id as any).toString(),
                oldValue: result.changes[0].oldUrl,
                newValue: result.changes[0].newUrl,
                success: true
              });
            }
          }
        }
      }
      
      // ë¬¸ì„œ ì €ì¥
      if (documentUpdated) {
        try {
          await category.updateOne(categoryObj);
          results.push(...documentUpdates);
          console.log(`âœ… itemcategories - ë¬¸ì„œ ${(category._id as any)} ì—…ë°ì´íŠ¸ ì™„ë£Œ (${documentUpdates.length}ê°œ í•„ë“œ)`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`âŒ itemcategories - ë¬¸ì„œ ${(category._id as any)} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:`, errorMessage);
          documentUpdates.forEach(update => {
            update.success = false;
            update.error = errorMessage;
          });
          results.push(...documentUpdates);
        }
      }
    }
  } catch (error) {
    console.error('âŒ itemcategories ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜:', error);
  }
  
  return results;
};

// ë©”ì¸ ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜
const updateDatabaseUrls = async (): Promise<DatabaseUpdateResult> => {
  console.log('ğŸš€ ë°ì´í„°ë² ì´ìŠ¤ URL ì—…ë°ì´íŠ¸ ì‹œì‘...\n');
  
  const result: DatabaseUpdateResult = {
    totalUpdates: 0,
    successfulUpdates: 0,
    failedUpdates: 0,
    updates: [],
    collections: {}
  };

  try {
    // MongoDB ì—°ê²°
    const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/ar_namecard';
    console.log(`ğŸ”— MongoDB ì—°ê²° ì¤‘: ${mongoUri}`);
    await mongoose.connect(mongoUri);
    console.log('âœ… MongoDB ì—°ê²° ì„±ê³µ\n');

    // ë§ˆì´ê·¸ë ˆì´ì…˜ ë§¤í•‘ íŒŒì¼ ë¡œë“œ
    const mappingFile = path.join(process.cwd(), 'migration-mapping.json');
    console.log(`ğŸ“„ ë§¤í•‘ íŒŒì¼ ë¡œë“œ: ${mappingFile}`);
    
    const mappingData = await fs.readFile(mappingFile, 'utf-8');
    const migrations: MigrationMappings = JSON.parse(mappingData);
    
    console.log(`ğŸ“Š ë§¤í•‘ ë°ì´í„°: ì´ ${migrations.total}ê°œ íŒŒì¼, ì„±ê³µ ${migrations.success}ê°œ`);
    
    if (migrations.success === 0) {
      console.log('âŒ ì„±ê³µì ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
      return result;
    }

    // URL ë§¤í•‘ ìƒì„±
    const urlMap = createUrlMapping(migrations.mappings);
    console.log(`ğŸ—ºï¸  URL ë§¤í•‘ ìƒì„± ì™„ë£Œ: ${urlMap.size}ê°œ URL\n`);

    // ê° ì»¬ë ‰ì…˜ ì—…ë°ì´íŠ¸
    const avatarResults = await updateAvatarCategories(urlMap);
    const itemResults = await updateItemCategories(urlMap);

    // ê²°ê³¼ ì§‘ê³„
    result.updates = [...avatarResults, ...itemResults];
    result.totalUpdates = result.updates.length;
    result.successfulUpdates = result.updates.filter(u => u.success).length;
    result.failedUpdates = result.updates.filter(u => !u.success).length;

    // ì»¬ë ‰ì…˜ë³„ í†µê³„
    result.collections = {};
    for (const update of result.updates) {
      if (!result.collections[update.collection]) {
        result.collections[update.collection] = {
          documentsUpdated: 0,
          fieldsUpdated: 0
        };
      }
      result.collections[update.collection].fieldsUpdated++;
    }

    // ì»¬ë ‰ì…˜ë³„ ë¬¸ì„œ ìˆ˜ ê³„ì‚°
    const documentIds = new Set();
    for (const update of result.updates) {
      const key = `${update.collection}-${update.documentId}`;
      if (!documentIds.has(key)) {
        documentIds.add(key);
        result.collections[update.collection].documentsUpdated++;
      }
    }

    // ê²°ê³¼ ì €ì¥
    const resultFile = path.join(process.cwd(), 'db-url-update-result.json');
    await fs.writeFile(resultFile, JSON.stringify(result, null, 2));
    console.log(`\nğŸ“„ ê²°ê³¼ íŒŒì¼ ì €ì¥: ${resultFile}`);

  } catch (error) {
    console.error('âŒ ë°ì´í„°ë² ì´ìŠ¤ URL ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜:', error);
    throw error;
  } finally {
    // MongoDB ì—°ê²° ì¢…ë£Œ
    await mongoose.disconnect();
    console.log('ğŸ”Œ MongoDB ì—°ê²° ì¢…ë£Œ');
  }

  return result;
};

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
const main = async () => {
  try {
    const result = await updateDatabaseUrls();
    
    console.log('\nğŸ‰ ë°ì´í„°ë² ì´ìŠ¤ URL ì—…ë°ì´íŠ¸ ì™„ë£Œ!');
    console.log('='.repeat(50));
    console.log(`ì´ ì—…ë°ì´íŠ¸: ${result.totalUpdates}`);
    console.log(`ì„±ê³µ: ${result.successfulUpdates}`);
    console.log(`ì‹¤íŒ¨: ${result.failedUpdates}`);
    console.log(`ì„±ê³µë¥ : ${Math.round(result.successfulUpdates / result.totalUpdates * 100)}%`);
    
    console.log('\nğŸ“Š ì»¬ë ‰ì…˜ë³„ í†µê³„:');
    for (const [collection, stats] of Object.entries(result.collections)) {
      console.log(`  ${collection}: ${stats.documentsUpdated}ê°œ ë¬¸ì„œ, ${stats.fieldsUpdated}ê°œ í•„ë“œ`);
    }
    
    if (result.failedUpdates > 0) {
      console.log('\nâŒ ì‹¤íŒ¨í•œ ì—…ë°ì´íŠ¸ë“¤:');
      result.updates
        .filter(u => !u.success)
        .forEach(u => {
          console.log(`  - ${u.collection}.${u.field} (${u.documentId}): ${u.error}`);
        });
    }
    
    console.log('\nâœ… ë°ì´í„°ë² ì´ìŠ¤ URL ì—…ë°ì´íŠ¸ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
    
  } catch (error) {
    console.error('ğŸ’¥ ë°ì´í„°ë² ì´ìŠ¤ URL ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
    process.exit(1);
  }
};

// ìŠ¤í¬ë¦½íŠ¸ê°€ ì§ì ‘ ì‹¤í–‰ëœ ê²½ìš°ì—ë§Œ main í•¨ìˆ˜ í˜¸ì¶œ
if (require.main === module) {
  main();
}

export { updateDatabaseUrls, UpdateResult, DatabaseUpdateResult };
</file>

<file path="src/config/cors.ts">
import { CorsOptions } from 'cors';

// í™˜ê²½ ë³€ìˆ˜ ì½ê¸°
const isDevelopment = process.env.NODE_ENV === 'development';
const allowAllOrigins = process.env.CORS_ALLOW_ALL === 'true';

// ê°œë°œì ëª¨ë“œì—ì„œ ëª¨ë“  origin í—ˆìš©
if (isDevelopment && allowAllOrigins) {
  console.log('ğŸ”“ CORS: ê°œë°œì ëª¨ë“œ - ëª¨ë“  origin í—ˆìš©');
}

// ê°œë°œ í™˜ê²½ì—ì„œ ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ìë™ í—ˆìš©
if (isDevelopment) {
  console.log('ğŸŒ CORS: ê°œë°œ ëª¨ë“œ - ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ í—ˆìš©');
}

// ê¸°ë³¸ í—ˆìš© ë„ë©”ì¸ ëª©ë¡
const allowedOrigins = [
  // ë¡œì»¬ ê°œë°œ í™˜ê²½
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:5173',
  'http://localhost:5174',
  'https://localhost:3443',
  'https://localhost:3001',
  
  // 8th Wall ë„ë©”ì¸
  'https://8thwall.com',
  'https://www.8thwall.com',
  'https://console.8thwall.com',
  'https://8thwall.app',
  'https://www.8thwall.app',
  
  // ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ (ëª¨ë“  ì‚¬ì„¤ IP ëŒ€ì—­)
  /^https?:\/\/192\.168\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  /^https?:\/\/10\.\d{1,3}\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  /^https?:\/\/172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3}(:\d+)?$/,
  
  // 8th Wall ë™ì  ë„ë©”ì¸ íŒ¨í„´
  /^https:\/\/.*\.8thwall\.com$/,
  /^https:\/\/.*\.8thwall\.app$/,
  
  // í…ŒìŠ¤íŠ¸ ë„ë©”ì¸
  'http://test.com',
  'https://test.com',
  'https://192.168.1.20',
  
  // ê°œë°œ í™˜ê²½ ì¶”ê°€ ì§€ì›
  ...(isDevelopment ? [
    // ë¡œì»¬ í˜¸ìŠ¤íŠ¸ ë³€í˜•
    'http://127.0.0.1:3000',
    'http://0.0.0.0:3000',
    'https://127.0.0.1:3443',
    'https://0.0.0.0:3443',
    
    // ë” ë„“ì€ ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ì§€ì›
    /^https?:\/\/.*\.local(:\d+)?$/,
    /^https?:\/\/.*\.lan(:\d+)?$/,
    
    // ê°œë°œì ë„êµ¬ ì§€ì›
    'null', // file:// í”„ë¡œí† ì½œìš©
  ] : []),
  
  // CloudType ë°°í¬ ë„ë©”ì¸ë“¤
  'https://ar-namecard-api.run.goorm.site',
  /^https:\/\/port-\d+-ar-namecard-api-.*\.cloudtype\.app$/,
  /^https:\/\/.*\.cloudtype\.app$/,
  
  // ì¶”ê°€ í”„ë¡œë•ì…˜ ë„ë©”ì¸ë“¤ (í•„ìš”ì‹œ)
];

export const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    // ê°œë°œì ëª¨ë“œì—ì„œ ëª¨ë“  origin í—ˆìš©
    if (isDevelopment && allowAllOrigins) {
      console.log(`âœ… CORS: ëª¨ë“  origin í—ˆìš© ëª¨ë“œ - ${origin}`);
      return callback(null, true);
    }
    
    // originì´ ì—†ëŠ” ê²½ìš° (ê°™ì€ ë„ë©”ì¸ ìš”ì²­) í—ˆìš©
    if (!origin) {
      return callback(null, true);
    }
    
    // ê°œë°œ í™˜ê²½ì—ì„œ ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ìë™ í—ˆìš©
    if (isDevelopment) {
      const isLocalNetwork = /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0|192\.168\.\d{1,3}\.\d{1,3}|10\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3})(:\d+)?$/i.test(origin);
      
      if (isLocalNetwork) {
        console.log(`âœ… CORS: ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ í—ˆìš© - ${origin}`);
        return callback(null, true);
      }
    }
    
    // í—ˆìš©ëœ origin ëª©ë¡ í™•ì¸
    const isAllowed = allowedOrigins.some(allowedOrigin => {
      if (typeof allowedOrigin === 'string') {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      console.log(`âœ… CORS: í—ˆìš©ëœ origin - ${origin}`);
      callback(null, true);
    } else {
      console.warn(`ğŸš« CORS: ì°¨ë‹¨ëœ origin - ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin',
    'Access-Control-Allow-Origin'
  ]
};
</file>

<file path="src/config/database.ts">
import mongoose from 'mongoose';

export const connectDB = async (): Promise<void> => {
  try {
    const mongoURI = process.env['MONGODB_URI'] || 'mongodb://localhost:27017/ar_namecard';
    
    await mongoose.connect(mongoURI);
    
    console.log('MongoDB Connected Successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

mongoose.connection.on('disconnected', () => {
  console.log('MongoDB disconnected');
});

mongoose.connection.on('error', (error) => {
  console.error('MongoDB connection error:', error);
});
</file>

<file path="src/config/firebase-storage.ts">
import { initializeFirebase } from '../scripts/config/firebase-admin';

export const getStorage = () => {
  const app = initializeFirebase();
  return app.storage();
};

export const getBucket = () => {
  const storage = getStorage();
  return storage.bucket(process.env.FIREBASE_STORAGE_BUCKET);
};

export const uploadToFirebase = async (
  file: Express.Multer.File,
  folder: string = ''
): Promise<{ url: string; path: string }> => {
  const filename = `${folder}${Date.now()}-${Math.round(Math.random() * 1E9)}-${file.originalname}`;
  const bucket = getBucket();
  const fileUpload = bucket.file(filename);
  
  const stream = fileUpload.createWriteStream({
    metadata: {
      contentType: file.mimetype,
    },
  });

  return new Promise((resolve, reject) => {
    stream.on('error', reject);
    stream.on('finish', async () => {
      try {
        await fileUpload.makePublic();
        const url = `https://storage.googleapis.com/${bucket.name}/${filename}`;
        resolve({ url, path: filename });
      } catch (error) {
        reject(error);
      }
    });
    stream.end(file.buffer);
  });
};
</file>

<file path="src/config/swagger.ts">
import swaggerJSDoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';
import { Express } from 'express';
import os from 'os';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'AR Namecard API',
      version: '1.0.0',
      description: `AR ëª…í•¨ ì„œë¹„ìŠ¤ API ë¬¸ì„œì…ë‹ˆë‹¤.

### í…ŒìŠ¤íŠ¸ í˜ì´ì§€:
* [ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸](/test/login/)
* [ì‚¬ìš©ì ì •ë³´ í…ŒìŠ¤íŠ¸](/test/user/)
* [ìºë¦­í„° ì˜µì…˜ ë“±ë¡ í…ŒìŠ¤íŠ¸](/test/avatar/)
* [ìŠ¤í‹°ì»¤ ì˜µì…˜ ë“±ë¡ í…ŒìŠ¤íŠ¸](/test/item/)
* [ì»¤ìŠ¤í„°ë§ˆì´ì§• í…ŒìŠ¤íŠ¸](/test/customize/)
`,
    },
    servers: [], // ë™ì ìœ¼ë¡œ ìƒì„±ë¨
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
          description: 'AR ëª…í•¨ ì‹œìŠ¤í…œ JWT í† í°',
        },
        firebaseAuth: {
          type: 'oauth2',
          description: 'Firebase Authentication (Google OAuth)',
          flows: {
            implicit: {
              authorizationUrl: 'https://accounts.google.com/o/oauth2/auth',
              scopes: {
                'openid': 'OpenID Connect',
                'email': 'Email address',
                'profile': 'User profile'
              }
            }
          }
        },
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ì‚¬ìš©ì ID',
            },
            nameEn: {
              type: 'string',
              description: 'ì˜ë¬¸ ì´ë¦„',
            },
            email: {
              type: 'string',
              description: 'ì´ë©”ì¼',
            },
            nameKr: {
              type: 'string',
              description: 'í•œê¸€ ì´ë¦„',
            },
            role: {
              type: 'string',
              description: 'ì—­í• ',
              default: 'User',
            },
            part: {
              type: 'string',
              description: 'ì†Œì† ë¶€ì„œ',
              default: '',
            },
            phone: {
              type: 'string',
              description: 'ì „í™”ë²ˆí˜¸',
            },
            isNamecardActive: {
              type: 'boolean',
              description: 'ëª…í•¨ í™œì„±í™” ì—¬ë¶€',
              default: false,
            },
            arId: {
              type: 'string',
              description: 'AR ëª…í•¨ ID (3ìë¦¬)',
              minLength: 3,
              maxLength: 3,
            },
            isAdmin: {
              type: 'boolean',
              description: 'ê´€ë¦¬ì ì—¬ë¶€',
              default: false,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìƒì„±ì¼ì‹œ',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìˆ˜ì •ì¼ì‹œ',
            },
          },
          required: ['email', 'nameKr', 'phone', 'arId'],
        },
        UserCustomization: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ì‚¬ìš©ì ID ì°¸ì¡°',
            },
            avatarSelections: {
              type: 'object',
              description: 'ì•„ë°”íƒ€ ì„ íƒ ì˜µì…˜',
              additionalProperties: {
                type: 'string',
              },
            },
            role: {
              type: 'string',
              description: 'ì—­í• ',
            },
            item1: {
              type: 'string',
              description: 'ì•„ì´í…œ 1',
            },
            item2: {
              type: 'string',
              description: 'ì•„ì´í…œ 2',
            },
            item3: {
              type: 'string',
              description: 'ì•„ì´í…œ 3',
            },
            avatarImgUrl: {
              type: 'string',
              description: 'ì•„ë°”íƒ€ ì´ë¯¸ì§€ URL',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìƒì„±ì¼ì‹œ',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìˆ˜ì •ì¼ì‹œ',
            },
          },
          required: ['id'],
        },
        AvatarWithUser: {
          type: 'object',
          description: 'ì‚¬ìš©ì ì •ë³´ì™€ ì•„ë°”íƒ€ ì •ë³´ê°€ í•©ì³ì§„ ì‘ë‹µ',
          properties: {
            id: {
              type: 'string',
              description: 'ì‚¬ìš©ì ID',
            },
            nameEn: {
              type: 'string',
              description: 'ì˜ë¬¸ ì´ë¦„',
              nullable: true,
            },
            email: {
              type: 'string',
              description: 'ì´ë©”ì¼',
              nullable: true,
            },
            nameKr: {
              type: 'string',
              description: 'í•œê¸€ ì´ë¦„',
              nullable: true,
            },
            part: {
              type: 'string',
              description: 'ì†Œì† ë¶€ì„œ',
              default: '',
            },
            phone: {
              type: 'string',
              description: 'ì „í™”ë²ˆí˜¸',
              nullable: true,
            },
            isNamecardActive: {
              type: 'boolean',
              description: 'ëª…í•¨ í™œì„±í™” ì—¬ë¶€',
              default: false,
            },
            arId: {
              type: 'string',
              description: 'AR ëª…í•¨ ID (3ìë¦¬)',
              nullable: true,
            },
            isAdmin: {
              type: 'boolean',
              description: 'ê´€ë¦¬ì ì—¬ë¶€',
              default: false,
            },
            avatarSelections: {
              type: 'object',
              description: 'ì•„ë°”íƒ€ ì„ íƒ ì˜µì…˜ (ìƒì„¸ ì •ë³´ í¬í•¨)',
              additionalProperties: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  name: { type: 'string' },
                  imageUrl: { type: 'string' },
                  thumbnailUrl: { type: 'string' },
                },
              },
            },
            role: {
              type: 'object',
              description: 'ì—­í•  ìƒì„¸ ì •ë³´',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
              },
            },
            item1: {
              type: 'object',
              description: 'ì•„ì´í…œ 1 ìƒì„¸ ì •ë³´',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            item2: {
              type: 'object',
              description: 'ì•„ì´í…œ 2 ìƒì„¸ ì •ë³´',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            item3: {
              type: 'object',
              description: 'ì•„ì´í…œ 3 ìƒì„¸ ì •ë³´',
              nullable: true,
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                imageUrl: { type: 'string' },
                thumbnailUrl: { type: 'string' },
                category: { type: 'string' },
              },
            },
            avatarImgUrl: {
              type: 'string',
              description: 'ì•„ë°”íƒ€ ì´ë¯¸ì§€ URL',
              nullable: true,
            },
            message: {
              type: 'string',
              description: 'ì‚¬ìš©ì ë©”ì‹œì§€',
              default: '',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìƒì„±ì¼ì‹œ',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìˆ˜ì •ì¼ì‹œ',
            },
          },
          required: ['id'],
        },
        AvatarCategory: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ ID',
            },
            name: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ ì´ë¦„',
            },
            type: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ íƒ€ì…',
            },
            options: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: {
                    type: 'string',
                    description: 'ì˜µì…˜ ì´ë¦„',
                  },
                  imageUrl: {
                    type: 'string',
                    description: 'ì´ë¯¸ì§€ URL',
                  },
                  thumbnailUrl: {
                    type: 'string',
                    description: 'ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL',
                  },
                  thumbnailSource: {
                    type: 'string',
                    enum: ['user', 'auto'],
                    description: 'ì¸ë„¤ì¼ ìƒì„± ë°©ì‹',
                  },
                  modelUrl: {
                    type: 'string',
                    description: 'ëª¨ë¸ URL',
                  },
                  color: {
                    type: 'string',
                    description: 'ìƒ‰ìƒ',
                  },
                  order: {
                    type: 'number',
                    description: 'ìˆœì„œ',
                    default: 0,
                  },
                },
                required: ['name', 'imageUrl'],
              },
            },
            order: {
              type: 'number',
              description: 'ìˆœì„œ',
              default: 0,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìƒì„±ì¼ì‹œ',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìˆ˜ì •ì¼ì‹œ',
            },
          },
          required: ['name', 'type'],
        },
        ItemCategory: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ ID',
            },
            name: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ ì´ë¦„',
            },
            type: {
              type: 'string',
              description: 'ì¹´í…Œê³ ë¦¬ íƒ€ì…',
            },
            items: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: {
                    type: 'string',
                    description: 'ì•„ì´í…œ ì´ë¦„',
                  },
                  imageUrl: {
                    type: 'string',
                    description: 'ì´ë¯¸ì§€ URL',
                  },
                  thumbnailUrl: {
                    type: 'string',
                    description: 'ì¸ë„¤ì¼ ì´ë¯¸ì§€ URL',
                  },
                  thumbnailSource: {
                    type: 'string',
                    enum: ['user', 'auto'],
                    description: 'ì¸ë„¤ì¼ ìƒì„± ë°©ì‹',
                  },
                  modelUrl: {
                    type: 'string',
                    description: 'ëª¨ë¸ URL',
                  },
                  animationUrl: {
                    type: 'string',
                    description: 'ì• ë‹ˆë©”ì´ì…˜ URL',
                  },
                  animation: {
                    type: 'object',
                    properties: {
                      frames: {
                        type: 'number',
                        description: 'í”„ë ˆì„ ìˆ˜',
                      },
                      columns: {
                        type: 'number',
                        description: 'ì—´ ìˆ˜',
                      },
                      duration: {
                        type: 'number',
                        description: 'ì§€ì† ì‹œê°„',
                      },
                      type: {
                        type: 'string',
                        description: 'ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…',
                      },
                    },
                    required: ['frames', 'columns', 'duration', 'type'],
                  },
                  order: {
                    type: 'number',
                    description: 'ìˆœì„œ',
                    default: 0,
                  },
                },
                required: ['name', 'imageUrl'],
              },
            },
            order: {
              type: 'number',
              description: 'ìˆœì„œ',
              default: 0,
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìƒì„±ì¼ì‹œ',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'ìˆ˜ì •ì¼ì‹œ',
            },
          },
          required: ['name', 'type'],
        },
        Error: {
          type: 'object',
          properties: {
            error: {
              type: 'string',
              description: 'ì—ëŸ¬ ë©”ì‹œì§€',
            },
            errors: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  field: {
                    type: 'string',
                    description: 'í•„ë“œëª…',
                  },
                  message: {
                    type: 'string',
                    description: 'ì—ëŸ¬ ë©”ì‹œì§€',
                  },
                },
              },
            },
          },
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
      {
        firebaseAuth: ['openid', 'email', 'profile'],
      },
    ],
  },
  apis: ['./src/routes/*.ts'], // API íŒŒì¼ ê²½ë¡œ
};

// ë¡œì»¬ IP ì£¼ì†Œ ì°¾ê¸°
function getLocalIpAddress(): string {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const networkInterface of interfaces[name]!) {
      const { address, family, internal } = networkInterface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

// ë™ì  ì„œë²„ URL ìƒì„±
function generateServerUrls() {
  const localIp = getLocalIpAddress();
  const port = process.env.PORT || '3000';
  const httpsPort = process.env.HTTPS_PORT || '3443';
  
  return [
    {
      url: `http://localhost:${port}`,
      description: 'Local development server',
    },
    {
      url: `http://${localIp}:${port}`,
      description: 'Network development server',
    },
    {
      url: `https://localhost:${httpsPort}`,
      description: 'Local HTTPS server',
    },
    {
      url: `https://${localIp}:${httpsPort}`,
      description: 'Network HTTPS server',
    },
  ];
}

// ë™ì  ì˜µì…˜ ìƒì„±
const getDynamicOptions = () => ({
  ...options,
  definition: {
    ...options.definition,
    servers: generateServerUrls(),
  },
});

export const setupSwagger = (app: Express): void => {
  const dynamicSpecs = swaggerJSDoc(getDynamicOptions());
  
  // Swagger UI ì˜µì…˜ ì„¤ì •
  const swaggerUiOptions = {
    explorer: true,
    swaggerOptions: {
      docExpansion: 'none', // ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  íƒœê·¸ë¥¼ ì ‘ìŒ
      defaultModelsExpandDepth: 1,
      defaultModelExpandDepth: 1,
      displayOperationId: false,
      displayRequestDuration: true,
      filter: true,
      showExtensions: true,
      showCommonExtensions: true,
      tryItOutEnabled: true,
    }
  };
  
  // ì»¤ìŠ¤í…€ CSSì™€ JavaScriptë¡œ Avatars íƒœê·¸ë§Œ í™•ì¥
  const customCss = `
    .opblock-tag-section[data-tag="Avatars"] .opblock-tag {
      background-color: #e8f5e8 !important;
      border-left: 4px solid #4caf50 !important;
    }
    .opblock-tag-section[data-tag="Avatars"] .opblock-tag:after {
      content: " â­ ê¸°ë³¸ í™•ì¥" !important;
      font-size: 12px !important;
      color: #4caf50 !important;
      font-weight: bold !important;
    }
    
    /* ìë™ í™•ì¥ ìŠ¤í¬ë¦½íŠ¸ */
    <script>
      window.addEventListener('DOMContentLoaded', function() {
        function expandAvatarsTag() {
          const avatarsSection = document.querySelector('[data-tag="Avatars"]');
          if (avatarsSection) {
            const avatarsTag = avatarsSection.querySelector('.opblock-tag');
            if (avatarsTag && !avatarsSection.classList.contains('is-open')) {
              avatarsTag.click();
              console.log('âœ… Avatars íƒœê·¸ ìë™ í™•ì¥ ì™„ë£Œ');
            }
          } else {
            // DOMì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¬ì‹œë„
            setTimeout(expandAvatarsTag, 500);
          }
        }
        
        // í˜ì´ì§€ ë¡œë“œ í›„ ì ì‹œ ëŒ€ê¸°í•œ ë‹¤ìŒ ì‹¤í–‰
        setTimeout(expandAvatarsTag, 1000);
      });
    </script>
  `;
  
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(dynamicSpecs, swaggerUiOptions, {}, customCss, undefined, undefined, 'AR Namecard API Documentation'));
};
</file>

<file path="src/controllers/adminAvatarController.ts">
import { Request, Response } from 'express';
import { AvatarCategory } from '../models';
import { validationResult } from 'express-validator';
import { ThumbnailGenerator } from '../utils/thumbnailGenerator';
import { PaletteImageProcessor } from '../utils/paletteImageProcessor';
import { uploadToFirebase } from '../config/firebase-storage';
import { uploadToFirebaseStorage } from '../middleware/upload';
import path from 'path';
import fs from 'fs/promises'; // Added fs import

interface AuthRequest extends Request {
  user?: any;
}

// íŒŒì¼ ì‚­ì œ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
const deleteFileIfExists = async (filePath: string): Promise<void> => {
  try {
    await fs.access(filePath);
    await fs.unlink(filePath);
    console.log(`File deleted: ${filePath}`);
  } catch (error) {
    // íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ë¬´ì‹œ
    console.warn(`Failed to delete file: ${filePath}`, error);
  }
};

// URLì—ì„œ ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
const getFilePathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', filename);
};

// ì¸ë„¤ì¼ URLì—ì„œ ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
const getThumbnailPathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', 'thumbnails', filename);
};

export const getAllAvatarCategories = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await AvatarCategory.find(query).sort({ order: 1 });
    
    // ê¸°ì¡´ ë°ì´í„° í˜¸í™˜ì„±ì„ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ì ìš©
    const migratedCategories = categories.map(category => {
      const categoryObj = category.toObject();
      if (categoryObj.options) {
        categoryObj.options = categoryObj.options.map((option: any) => {
          // ê¸°ì¡´ êµ¬ì¡°(ë‹¨ì¼ color string)ë¥¼ ìƒˆ êµ¬ì¡°ë¡œ ë³€í™˜
          if (typeof option.color === 'string' && option.imageUrl) {
            option.color = [{
              colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
              imageUrl: option.imageUrl
            }];
          }
          // colorê°€ ë°°ì—´ì´ ì•„ë‹ˆê³  imageUrlì´ ìˆëŠ” ê²½ìš° (null, undefined ë“±)
          else if (!Array.isArray(option.color) && option.imageUrl) {
            option.color = [{
              colorName: 'Default',
              imageUrl: option.imageUrl
            }];
          }

          // ê¸°ì¡´ hairPartsë¥¼ resourceImagesë¡œ ë³€í™˜ (hair ì¹´í…Œê³ ë¦¬ë§Œ)
          if (categoryObj.type === 'hair' && option.hairParts && Array.isArray(option.color)) {
            option.color = option.color.map((colorOpt: any) => {
              if (!colorOpt.resourceImages) {
                // ìƒˆë¡œìš´ ê°ì²´ êµ¬ì¡°ë¡œ ë³€í™˜
                const resourceImages: any = {};
                if (option.hairParts.middle) {
                  resourceImages.hairMiddleImageUrl = option.hairParts.middle; // ì¤‘ê°„ë¨¸ë¦¬
                }
                if (option.hairParts.back) {
                  resourceImages.hairBackImageUrl = option.hairParts.back; // ë’·ë¨¸ë¦¬
                }
                colorOpt.resourceImages = resourceImages;
              }
              return colorOpt;
            });
            // ë³€í™˜ í›„ hairParts ì œê±°
            delete option.hairParts;
          }
          
          // ê¸°ì¡´ ë°°ì—´ êµ¬ì¡° resourceImagesë¥¼ ê°ì²´ êµ¬ì¡°ë¡œ ë³€í™˜ (hair ì¹´í…Œê³ ë¦¬ë§Œ)
          if (categoryObj.type === 'hair' && Array.isArray(option.color)) {
            option.color = option.color.map((colorOpt: any) => {
              if (colorOpt.resourceImages && Array.isArray(colorOpt.resourceImages)) {
                // ë°°ì—´ êµ¬ì¡°ë¥¼ ê°ì²´ êµ¬ì¡°ë¡œ ë³€í™˜
                const newResourceImages: any = {};
                if (colorOpt.resourceImages[2]) {
                  newResourceImages.hairMiddleImageUrl = colorOpt.resourceImages[2]; // ì¤‘ê°„ë¨¸ë¦¬
                }
                if (colorOpt.resourceImages[0]) {
                  newResourceImages.hairBackImageUrl = colorOpt.resourceImages[0]; // ë’·ë¨¸ë¦¬
                }
                colorOpt.resourceImages = newResourceImages;
              }
              return colorOpt;
            });
          }
          
          return option;
        });
      }
      return categoryObj;
    });
    
    res.json({ categories: migratedCategories, total: migratedCategories.length });
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const getAvatarCategoryById = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await AvatarCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // ê¸°ì¡´ ë°ì´í„° í˜¸í™˜ì„±ì„ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ì ìš©
    const categoryObj = category.toObject();
    if (categoryObj.options) {
      categoryObj.options = categoryObj.options.map((option: any) => {
        // ê¸°ì¡´ êµ¬ì¡°(ë‹¨ì¼ color string)ë¥¼ ìƒˆ êµ¬ì¡°ë¡œ ë³€í™˜
        if (typeof option.color === 'string' && option.imageUrl) {
          option.color = [{
            colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
            imageUrl: option.imageUrl
          }];
        }
        // colorê°€ ë°°ì—´ì´ ì•„ë‹ˆê³  imageUrlì´ ìˆëŠ” ê²½ìš° (null, undefined ë“±)
        else if (!Array.isArray(option.color) && option.imageUrl) {
          option.color = [{
            colorName: 'Default',
            imageUrl: option.imageUrl
          }];
        }
        
        return option;
      });
    }

    res.json(categoryObj);
  } catch (error) {
    console.error('Error fetching avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const createAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { name, type, order = 0 } = req.body;

    // ë™ì¼í•œ typeì´ ìˆëŠ”ì§€ í™•ì¸
    const existingCategory = await AvatarCategory.findOne({ type });
    if (existingCategory) {
      res.status(400).json({ message: 'Avatar category with this type already exists' });
      return;
    }

    const category = new AvatarCategory({
      name,
      type,
      options: [],
      order
    });

    await category.save();
    res.status(201).json({ message: 'Avatar category created successfully', category });
  } catch (error) {
    console.error('Error creating avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, type, order } = req.body;

    // typeì´ ë³€ê²½ë˜ëŠ” ê²½ìš° ì¤‘ë³µ í™•ì¸
    if (type) {
      const existingCategory = await AvatarCategory.findOne({ type, _id: { $ne: id } });
      if (existingCategory) {
        res.status(400).json({ message: 'Avatar category with this type already exists' });
        return;
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (type !== undefined) updateData.type = type;
    if (order !== undefined) updateData.order = order;

    const category = await AvatarCategory.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    res.json({ message: 'Avatar category updated successfully', category });
  } catch (error) {
    console.error('Error updating avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteAvatarCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await AvatarCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // ì¹´í…Œê³ ë¦¬ì˜ ëª¨ë“  ì˜µì…˜ ì´ë¯¸ì§€, ì¸ë„¤ì¼ ë° íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì‚­ì œ
    for (const option of category.options) {
      if (option.imageUrl) {
        const imagePath = getFilePathFromUrl(option.imageUrl);
        await deleteFileIfExists(imagePath);
      }
      if (option.thumbnailUrl) {
        const thumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
        await deleteFileIfExists(thumbnailPath);
      }
      
      // íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë“¤ ì‚­ì œ
      if (option.color && Array.isArray(option.color)) {
        for (const colorOpt of option.color) {
          if (colorOpt.paletteImageUrl) {
            await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
          }
        }
      }
    }

    await AvatarCategory.findByIdAndDelete(id);
    res.json({ message: 'Avatar category deleted successfully' });
  } catch (error) {
    console.error('Error deleting avatar category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const addAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, colorOptions, order = 0 } = req.body;
    const files = req.files as Express.Multer.File[];
    
    console.log(`ğŸ” addAvatarOption ìš”ì²­ ë°ì´í„°:`, {
      name,
      colorOptionsType: typeof colorOptions,
      colorOptionsLength: colorOptions?.length,
      filesCount: files?.length || 0
    });
    
    // colorOptionsëŠ” JSON ë¬¸ìì—´ë¡œ ì „ì†¡ë  ê²ƒì„
    let parsedColorOptions;
    try {
      parsedColorOptions = typeof colorOptions === 'string' ? JSON.parse(colorOptions) : colorOptions;
      console.log(`ğŸ” íŒŒì‹±ëœ colorOptions:`, parsedColorOptions);
    } catch (error) {
      console.error('âŒ colorOptions íŒŒì‹± ì‹¤íŒ¨:', error);
      res.status(400).json({ message: 'Invalid colorOptions format' });
      return;
    }

    if (!parsedColorOptions || !Array.isArray(parsedColorOptions) || parsedColorOptions.length === 0) {
      console.error('âŒ colorOptions ê²€ì¦ ì‹¤íŒ¨:', {
        exists: !!parsedColorOptions,
        isArray: Array.isArray(parsedColorOptions),
        length: parsedColorOptions?.length || 0
      });
      res.status(400).json({ message: 'At least one color option is required' });
      return;
    }

    const category = await AvatarCategory.findById(id);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    // hair ì¹´í…Œê³ ë¦¬ ê°ì§€
    const isHairCategory = category.type === 'hair';

    // íŒŒì¼ ë°°ì—´ì„ ê°ì²´ë¡œ ë³€í™˜ (upload.any() ì‚¬ìš©ìœ¼ë¡œ ì¸í•´)
    const filesByName: { [key: string]: Express.Multer.File[] } = {};
    if (Array.isArray(files)) {
      files.forEach(file => {
        if (!filesByName[file.fieldname]) {
          filesByName[file.fieldname] = [];
        }
        filesByName[file.fieldname].push(file);
      });
    }

    // ë””ë²„ê¹…: ë°›ì€ íŒŒì¼ë“¤ ë¡œê·¸
    console.log('ğŸ” ë°›ì€ íŒŒì¼ë“¤:', Object.keys(filesByName));
    if (isHairCategory) {
      console.log('ğŸ’‡â€â™€ï¸ Hair ì¹´í…Œê³ ë¦¬ íŒŒì¼ë“¤:', Object.keys(filesByName).filter(key => key.startsWith('hair_')));
    }

    // íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ë° hair ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ì²˜ë¦¬
    const paletteFiles = filesByName.palette || [];
    const processedColorOptions = await Promise.all(
      parsedColorOptions.map(async (colorOption: any, index: number) => {
        let paletteImageUrl = '';
        let resourceImages: { hairMiddleImageUrl: string; hairBackImageUrl?: string } | undefined;
        
        // í•´ë‹¹ ì¸ë±ìŠ¤ì— íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì²˜ë¦¬
        if (paletteFiles[index]) {
          try {
            // Firebase Storageì— íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ
            const uploadResult = await uploadToFirebaseStorage(paletteFiles[index], 'palettes/');
            paletteImageUrl = uploadResult.url;
            console.log(`âœ… íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ (ìƒ‰ìƒ ì˜µì…˜ ${index}):`, uploadResult.url);
          } catch (error) {
            console.error(`Error processing palette image for color option ${index}:`, error);
          }
        }

        // hair ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ì²˜ë¦¬
        if (isHairCategory) {
          // hair ê²€ì¦: ì¤‘ê°„ë¨¸ë¦¬ëŠ” í•„ìˆ˜
          const middleHairKey = `hair_${index}_middle`;
          const backHairKey = `hair_${index}_back`;
          
          if (!filesByName[middleHairKey] || filesByName[middleHairKey].length === 0) {
            throw new Error(`Middle hair image is required for color option ${index + 1}: ${colorOption.colorName}`);
          }

          try {
            // ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ê°ì²´ ì´ˆê¸°í™”
            resourceImages = {} as { hairMiddleImageUrl: string; hairBackImageUrl?: string };
            
            // ì¤‘ê°„ë¨¸ë¦¬ ì²˜ë¦¬ (í•„ìˆ˜)
            const middleHairFile = filesByName[middleHairKey]![0];
            if (!middleHairFile.buffer) {
              throw new Error('Middle hair file buffer is missing');
            }
            const middleResult = await uploadToFirebase(middleHairFile, 'uploads/hair/');
            resourceImages.hairMiddleImageUrl = middleResult.url;

            // ë’·ë¨¸ë¦¬ ì²˜ë¦¬ (ì„ íƒì‚¬í•­)
            if (filesByName[backHairKey] && filesByName[backHairKey].length > 0) {
              const backHairFile = filesByName[backHairKey][0];
              if (!backHairFile.buffer) {
                throw new Error('Back hair file buffer is missing');
              }
              const backResult = await uploadToFirebase(backHairFile, 'uploads/hair/');
              resourceImages.hairBackImageUrl = backResult.url;
            }

          } catch (error) {
            console.error(`Error processing hair images for color option ${index}:`, error);
            throw new Error(`Failed to process hair images for color option: ${colorOption.colorName}`);
          }
        }

        // Hair ì¹´í…Œê³ ë¦¬ì—ì„œ imageUrl ê²°ì •
        let finalImageUrl = colorOption.imageUrl;
        if (isHairCategory) {
          // ì¤‘ê°„ë¨¸ë¦¬ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ imageUrl ìœ ì§€
          finalImageUrl = resourceImages?.hairMiddleImageUrl || colorOption.imageUrl;
          // Hair ì¹´í…Œê³ ë¦¬ì—ì„œ imageUrlì´ ì—¬ì „íˆ ì—†ìœ¼ë©´ ì—ëŸ¬
          if (!finalImageUrl) {
            throw new Error(`Hair category requires middle hair image for color option: ${colorOption.colorName}`);
          }
        }

        return {
          colorName: colorOption.colorName,
          imageUrl: finalImageUrl,
          paletteImageUrl,
          ...(isHairCategory && { resourceImages })
        };
      })
    );

    // ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ì˜ ì´ë¯¸ì§€ë¥¼ ë©”ì¸ ì´ë¯¸ì§€ë¡œ ì‚¬ìš©
    const mainImageUrl = processedColorOptions[0]?.imageUrl;
    console.log(`ğŸ” ë©”ì¸ ì´ë¯¸ì§€ URL (ì¸ë„¤ì¼ ìƒì„±ìš©):`, mainImageUrl);
    if (!mainImageUrl) {
      res.status(400).json({ message: 'First color option must have an imageUrl' });
      return;
    }

    // ì¸ë„¤ì¼ ì²˜ë¦¬ (ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ ì´ë¯¸ì§€ ê¸°ì¤€)
    let thumbnailUrl = '';
    let thumbnailSource: 'user' | 'auto' = 'auto';

    if (filesByName.thumbnail && filesByName.thumbnail.length > 0) {
      // ì‚¬ìš©ìê°€ ì¸ë„¤ì¼ì„ ì œê³µí•œ ê²½ìš°
      const thumbnailFile = filesByName.thumbnail[0];
      if (!thumbnailFile) {
        res.status(400).json({ message: 'Thumbnail file is invalid' });
        return;
      }
      // Firebase Storageì— ì¸ë„¤ì¼ ì§ì ‘ ì—…ë¡œë“œ
      if (!thumbnailFile.buffer) {
        res.status(400).json({ message: 'Thumbnail file buffer is missing' });
        return;
      }
      
      const thumbnailUploadResult = await uploadToFirebaseStorage(thumbnailFile, 'thumbnails/');
      thumbnailUrl = thumbnailUploadResult.url;
      thumbnailSource = 'user';
    } else {
      // ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ ì´ë¯¸ì§€ë¡œ ìë™ ì¸ë„¤ì¼ ìƒì„±
      // mainImageUrlì„ ThumbnailGeneratorì— ì§ì ‘ ì „ë‹¬ (Firebase Storage URL ë˜ëŠ” ë¡œì»¬ ê²½ë¡œ)
      console.log(`ğŸ” ì¸ë„¤ì¼ ìƒì„±ìš© ì´ë¯¸ì§€ URL:`, mainImageUrl);
      const thumbnailResult = await ThumbnailGenerator.generateThumbnail(mainImageUrl);
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    }

    const newOption: any = {
      name,
      imageUrl: mainImageUrl,
      thumbnailUrl,
      thumbnailSource,
      color: processedColorOptions,
      order: parseInt(order) || 0
    };

    category.options.push(newOption as any);
    await category.save();

    res.status(201).json({ 
      message: 'Avatar option added successfully', 
      option: newOption,
      category: category.name
    });
  } catch (error) {
    console.error('Error adding avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;
    const { name, colorOptions, order } = req.body;
    const files = req.files as Express.Multer.File[];

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];

    // ê¸°ì¡´ íŒŒì¼ ê²½ë¡œ ì €ì¥ (ì‚­ì œìš©)
    const oldThumbnailPath = option.thumbnailUrl ? getThumbnailPathFromUrl(option.thumbnailUrl) : '';

    // ê¸°ë³¸ ì •ë³´ ì—…ë°ì´íŠ¸
    if (name !== undefined) option.name = name;
    if (order !== undefined) option.order = parseInt(order);

    // hair ì¹´í…Œê³ ë¦¬ ê°ì§€
    const isHairCategory = category.type === 'hair';

    // íŒŒì¼ ë°°ì—´ì„ ê°ì²´ë¡œ ë³€í™˜ (upload.any() ì‚¬ìš©ìœ¼ë¡œ ì¸í•´)
    const filesByName: { [key: string]: Express.Multer.File[] } = {};
    if (Array.isArray(files)) {
      files.forEach(file => {
        if (!filesByName[file.fieldname]) {
          filesByName[file.fieldname] = [];
        }
        filesByName[file.fieldname].push(file);
      });
    }

    // ì»¬ëŸ¬ ì˜µì…˜ ì—…ë°ì´íŠ¸
    if (colorOptions !== undefined) {
      let parsedColorOptions;
      try {
        parsedColorOptions = typeof colorOptions === 'string' ? JSON.parse(colorOptions) : colorOptions;
      } catch (error) {
        res.status(400).json({ message: 'Invalid colorOptions format' });
        return;
      }

      if (!parsedColorOptions || !Array.isArray(parsedColorOptions) || parsedColorOptions.length === 0) {
        res.status(400).json({ message: 'At least one color option is required' });
        return;
      }

      // ê¸°ì¡´ íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë“¤ ì‚­ì œ
      if (option.color && Array.isArray(option.color)) {
        for (const colorOpt of option.color) {
          if (colorOpt.paletteImageUrl) {
            await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
          }
        }
      }

      // ìƒˆë¡œìš´ íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ë° hair ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ì²˜ë¦¬
      const paletteFiles = filesByName.palette || [];
      const processedColorOptions = await Promise.all(
        parsedColorOptions.map(async (colorOption: any, index: number) => {
          let paletteImageUrl = '';
          let resourceImages: { hairMiddleImageUrl: string; hairBackImageUrl?: string } | undefined;
          
          // í•´ë‹¹ ì¸ë±ìŠ¤ì— íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì²˜ë¦¬
          if (paletteFiles[index]) {
            try {
              // Firebase Storageì— íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ
              const uploadResult = await uploadToFirebaseStorage(paletteFiles[index], 'palettes/');
              paletteImageUrl = uploadResult.url;
              console.log(`âœ… íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ (ìƒ‰ìƒ ì˜µì…˜ ${index}):`, uploadResult.url);
            } catch (error) {
              console.error(`Error processing palette image for color option ${index}:`, error);
            }
          } else if (colorOption.paletteImageUrl) {
            // ê¸°ì¡´ íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ìœ ì§€
            paletteImageUrl = colorOption.paletteImageUrl;
          }

          // hair ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ì²˜ë¦¬
          if (isHairCategory) {
            const middleHairKey = `hair_${index}_middle`;
            const backHairKey = `hair_${index}_back`;
            
            try {
              // ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ê°ì²´ ì´ˆê¸°í™”
              resourceImages = {} as { hairMiddleImageUrl: string; hairBackImageUrl?: string };
              
              // ê¸°ì¡´ resourceImages ì²˜ë¦¬
              if (colorOption.resourceImages) {
                if (colorOption.resourceImages.hairMiddleImageUrl) {
                  resourceImages.hairMiddleImageUrl = colorOption.resourceImages.hairMiddleImageUrl;
                }
                if (colorOption.resourceImages.hairBackImageUrl) {
                  resourceImages.hairBackImageUrl = colorOption.resourceImages.hairBackImageUrl;
                }
              } else if (colorOption.imageUrl) {
                // ê¸°ì¡´ Hair ì˜µì…˜ì—ì„œ resourceImagesê°€ ì—†ëŠ” ê²½ìš°, imageUrlì„ ì¤‘ê°„ë¨¸ë¦¬ë¡œ ì‚¬ìš©
                resourceImages.hairMiddleImageUrl = colorOption.imageUrl;
              }
              
              // ì¤‘ê°„ë¨¸ë¦¬ ì²˜ë¦¬ (í•„ìˆ˜)
              if (filesByName[middleHairKey] && filesByName[middleHairKey].length > 0) {
                const middleHairFile = filesByName[middleHairKey][0];
                if (!middleHairFile.buffer) {
                  throw new Error('Middle hair file buffer is missing');
                }
                const middleResult = await uploadToFirebase(middleHairFile, 'uploads/hair/');
                resourceImages.hairMiddleImageUrl = middleResult.url;
              }

              // ë’·ë¨¸ë¦¬ ì²˜ë¦¬ (ì„ íƒì‚¬í•­)
              if (filesByName[backHairKey] && filesByName[backHairKey].length > 0) {
                const backHairFile = filesByName[backHairKey][0];
                if (!backHairFile.buffer) {
                  throw new Error('Back hair file buffer is missing');
                }
                const backResult = await uploadToFirebase(backHairFile, 'uploads/hair/');
                resourceImages.hairBackImageUrl = backResult.url;
              }

            } catch (error) {
              console.error(`Error processing hair images for color option ${index}:`, error);
            }
          }

          // Hair ì¹´í…Œê³ ë¦¬ì—ì„œ imageUrl ê²°ì •
          let finalImageUrl = colorOption.imageUrl;
          if (isHairCategory && resourceImages) {
            // ì¤‘ê°„ë¨¸ë¦¬ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ imageUrl ìœ ì§€
            finalImageUrl = resourceImages.hairMiddleImageUrl || colorOption.imageUrl;
          }

          return {
            colorName: colorOption.colorName,
            imageUrl: finalImageUrl,
            paletteImageUrl,
            ...(isHairCategory && { resourceImages })
          };
        })
      );

      option.color = processedColorOptions;
      
      // ì²« ë²ˆì§¸ ì»¬ëŸ¬ ì˜µì…˜ì˜ ì´ë¯¸ì§€ë¥¼ ë©”ì¸ ì´ë¯¸ì§€ë¡œ ì—…ë°ì´íŠ¸
      const newMainImageUrl = processedColorOptions[0]?.imageUrl;
      console.log(`ğŸ” ì—…ë°ì´íŠ¸ - ìƒˆ ë©”ì¸ ì´ë¯¸ì§€ URL:`, newMainImageUrl, `ê¸°ì¡´:`, option.imageUrl);
      if (newMainImageUrl && newMainImageUrl !== option.imageUrl) {
        option.imageUrl = newMainImageUrl;
        
        // ë©”ì¸ ì´ë¯¸ì§€ê°€ ë³€ê²½ë˜ë©´ ì¸ë„¤ì¼ë„ ì¬ìƒì„± (ìë™ ìƒì„±ì¸ ê²½ìš°)
        if (option.thumbnailSource === 'auto') {
          // ê¸°ì¡´ ì¸ë„¤ì¼ ì‚­ì œ
          if (oldThumbnailPath) {
            await deleteFileIfExists(oldThumbnailPath);
          }

          console.log(`ğŸ” ì—…ë°ì´íŠ¸ - ì¸ë„¤ì¼ ìƒì„±ìš© ì´ë¯¸ì§€ URL:`, newMainImageUrl);
          const thumbnailResult = await ThumbnailGenerator.generateThumbnail(newMainImageUrl);
          option.thumbnailUrl = thumbnailResult.thumbnailUrl;
        }
      }
    }

    // ìƒˆ ì¸ë„¤ì¼ì´ ìˆëŠ” ê²½ìš°
    if (filesByName.thumbnail && filesByName.thumbnail.length > 0) {
      const thumbnailFile = filesByName.thumbnail[0];
      if (thumbnailFile) {
        // Firebase Storage ì‚¬ìš© ì‹œ ë¡œì»¬ íŒŒì¼ ì‚­ì œ ë¶ˆí•„ìš”

        // Firebase Storageì— ì¸ë„¤ì¼ ì§ì ‘ ì—…ë¡œë“œ
        if (!thumbnailFile.buffer) {
          res.status(400).json({ message: 'Thumbnail file buffer is missing' });
          return;
        }
        
        const thumbnailUploadResult = await uploadToFirebaseStorage(thumbnailFile, 'thumbnails/');
        option.thumbnailUrl = thumbnailUploadResult.url;
        option.thumbnailSource = 'user';
      }
    }

    await category.save();

    res.json({ 
      message: 'Avatar option updated successfully', 
      option,
      category: category.name
    });
  } catch (error) {
    console.error('Error updating avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteAvatarOption = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];

    // ê´€ë ¨ íŒŒì¼ë“¤ ì‚­ì œ
    if (option.imageUrl) {
      const imagePath = getFilePathFromUrl(option.imageUrl);
      await deleteFileIfExists(imagePath);
    }
    if (option.thumbnailUrl) {
      const thumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
      await deleteFileIfExists(thumbnailPath);
    }
    
    // íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ë“¤ ì‚­ì œ
    if (option.color && Array.isArray(option.color)) {
      for (const colorOpt of option.color) {
        if (colorOpt.paletteImageUrl) {
          await PaletteImageProcessor.deletePaletteImage(colorOpt.paletteImageUrl);
        }
      }
    }

    category.options.splice(optionIndex, 1);
    await category.save();

    res.json({ message: 'Avatar option deleted successfully' });
  } catch (error) {
    console.error('Error deleting avatar option:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const regenerateThumbnail = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, optionId } = req.params;

    const category = await AvatarCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Avatar category not found' });
      return;
    }

    const optionIndex = category.options.findIndex(opt => (opt as any)._id?.toString() === optionId);
    if (optionIndex === -1) {
      res.status(404).json({ message: 'Avatar option not found' });
      return;
    }

    const option = category.options[optionIndex];
    
    if (!option.imageUrl) {
      res.status(400).json({ message: 'No image URL found for this option' });
      return;
    }
    
    // ê¸°ì¡´ ì¸ë„¤ì¼ ì‚­ì œ
    if (option.thumbnailUrl) {
      const oldThumbnailPath = getThumbnailPathFromUrl(option.thumbnailUrl);
      await deleteFileIfExists(oldThumbnailPath);
    }
    
    // ì¸ë„¤ì¼ ì¬ìƒì„± (Firebase Storage URL ë˜ëŠ” ë¡œì»¬ ê²½ë¡œ ìë™ ì²˜ë¦¬)
    const thumbnailResult = await ThumbnailGenerator.generateThumbnail(option.imageUrl);
    option.thumbnailUrl = thumbnailResult.thumbnailUrl;
    option.thumbnailSource = 'auto';

    await category.save();

    res.json({ 
      message: 'Thumbnail regenerated successfully', 
      thumbnailUrl: option.thumbnailUrl
    });
  } catch (error) {
    console.error('Error regenerating thumbnail:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/adminController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { validationResult } from 'express-validator';

interface AuthRequest extends Request {
  user?: any;
}

export const getAllUsers = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }
    
    const { page = 1, limit = 20, search, role, isActive, isAdmin } = req.query;
    
    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;
    
    let query: any = {};
    
    if (search) {
      query.$or = [
        { nameKr: { $regex: search, $options: 'i' } },
        { nameEn: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { arId: { $regex: search, $options: 'i' } }
      ];
    }
    
    if (role) {
      query.role = role;
    }
    
    if (isActive !== undefined) {
      query.isNamecardActive = isActive === 'true';
    }

    if (isAdmin !== undefined) {
      query.isAdmin = isAdmin === 'true';
    }
    
    const [users, total] = await Promise.all([
      User.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      User.countDocuments(query)
    ]);
    
    res.json({
      users,
      total,
      currentPage: pageNum,
      totalPages: Math.ceil(total / limitNum),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        pages: Math.ceil(total / limitNum)
      }
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateUserPermissions = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }
    
    const { id } = req.params;
    const { isAdmin, isNamecardActive, role, nameKr, nameEn, part, phone } = req.body;
    
    const updateData: any = {};
    
    if (isAdmin !== undefined) {
      updateData.isAdmin = isAdmin;
    }
    
    if (isNamecardActive !== undefined) {
      updateData.isNamecardActive = isNamecardActive;
    }
    
    if (role !== undefined) {
      updateData.role = role;
    }

    if (nameKr !== undefined) {
      updateData.nameKr = nameKr;
    }

    if (nameEn !== undefined) {
      updateData.nameEn = nameEn;
    }

    if (part !== undefined) {
      updateData.part = part;
    }

    if (phone !== undefined) {
      updateData.phone = phone;
    }
    
    const user = await User.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );
    
    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }
    
    res.json({ message: 'User updated successfully', user });
  } catch (error) {
    console.error('Error updating user permissions:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ message: error.message });
    } else {
      res.status(500).json({ message: 'Internal server error' });
    }
  }
};
</file>

<file path="src/controllers/adminItemController.ts">
import { Request, Response } from 'express';
import { ItemCategory } from '../models';
import { validationResult } from 'express-validator';
import { ThumbnailGenerator } from '../utils/thumbnailGenerator';
import { uploadToFirebase } from '../config/firebase-storage';
import path from 'path';
import fs from 'fs/promises';

interface AuthRequest extends Request {
  user?: any;
}

interface MulterFiles {
  image?: Express.Multer.File[];
  thumbnail?: Express.Multer.File[];
}

// íŒŒì¼ ì‚­ì œ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
const deleteFileIfExists = async (filePath: string): Promise<void> => {
  try {
    await fs.access(filePath);
    await fs.unlink(filePath);
    console.log(`File deleted: ${filePath}`);
  } catch (error) {
    // íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì‚­ì œ ì‹¤íŒ¨í•´ë„ ë¬´ì‹œ
    console.warn(`Failed to delete file: ${filePath}`, error);
  }
};

// URLì—ì„œ ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
const getFilePathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', filename);
};

// ì¸ë„¤ì¼ URLì—ì„œ ì‹¤ì œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
const getThumbnailPathFromUrl = (url: string): string => {
  if (!url) return '';
  const filename = path.basename(url);
  return path.join(process.cwd(), 'uploads', 'thumbnails', filename);
};

export const getAllItemCategories = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await ItemCategory.find(query).sort({ order: 1 });
    res.json({ categories, total: categories.length });
  } catch (error) {
    console.error('Error fetching item categories:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const getItemCategoryById = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await ItemCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    res.json(category);
  } catch (error) {
    console.error('Error fetching item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const createItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { name, type, order = 0 } = req.body;

    // ë™ì¼í•œ typeì´ ìˆëŠ”ì§€ í™•ì¸
    const existingCategory = await ItemCategory.findOne({ type });
    if (existingCategory) {
      res.status(400).json({ message: 'Item category with this type already exists' });
      return;
    }

    const category = new ItemCategory({
      name,
      type,
      items: [],
      order
    });

    await category.save();
    res.status(201).json({ message: 'Item category created successfully', category });
  } catch (error) {
    console.error('Error creating item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, type, order } = req.body;

    // typeì´ ë³€ê²½ë˜ëŠ” ê²½ìš° ì¤‘ë³µ í™•ì¸
    if (type) {
      const existingCategory = await ItemCategory.findOne({ type, _id: { $ne: id } });
      if (existingCategory) {
        res.status(400).json({ message: 'Item category with this type already exists' });
        return;
      }
    }

    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (type !== undefined) updateData.type = type;
    if (order !== undefined) updateData.order = order;

    const category = await ItemCategory.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    res.json({ message: 'Item category updated successfully', category });
  } catch (error) {
    console.error('Error updating item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteItemCategory = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { id } = req.params;
    const category = await ItemCategory.findById(id);

    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    // ì¹´í…Œê³ ë¦¬ì˜ ëª¨ë“  ì•„ì´í…œ ì´ë¯¸ì§€ ë° ì¸ë„¤ì¼ ì‚­ì œ
    for (const item of category.items) {
      if (item.imageUrl) {
        const imagePath = getFilePathFromUrl(item.imageUrl);
        await deleteFileIfExists(imagePath);
      }
      if (item.thumbnailUrl) {
        const thumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
        await deleteFileIfExists(thumbnailPath);
      }
    }

    await ItemCategory.findByIdAndDelete(id);
    res.json({ message: 'Item category deleted successfully' });
  } catch (error) {
    console.error('Error deleting item category:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const addItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ message: 'Validation error', errors: errors.array() });
      return;
    }

    const { id } = req.params;
    const { name, order = 0, frames, columns = 16, duration, animationType } = req.body;
    const files = req.files as MulterFiles;

    if (!files || !files.image || files.image.length === 0) {
      res.status(400).json({ message: 'Image file is required' });
      return;
    }

    const category = await ItemCategory.findById(id);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const imageFile = files.image[0];
    if (!imageFile) {
      res.status(400).json({ message: 'Image file is required' });
      return;
    }

    // Firebase Storageì— ì´ë¯¸ì§€ ì—…ë¡œë“œ (ë©”ëª¨ë¦¬ì—ì„œ ì§ì ‘ ì‚¬ìš©)
    if (!imageFile.buffer) {
      res.status(400).json({ message: 'Image file buffer is missing' });
      return;
    }
    
    const imageResult = await uploadToFirebase(imageFile, 'uploads/items/');
    const imageUrl = imageResult.url;

    // ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ ì²˜ë¦¬
    let animation = undefined;
    if (animationType && animationType !== 'none') {
      // ì• ë‹ˆë©”ì´ì…˜ì´ ìˆëŠ” ê²½ìš°ë§Œ animation ê°ì²´ ìƒì„±
      if (frames && columns && duration) {
        animation = {
          frames: parseInt(frames),
          columns: parseInt(columns),
          duration: parseInt(duration),
          type: animationType
        };
      }
    }

    // ì¸ë„¤ì¼ ì²˜ë¦¬
    let thumbnailUrl = '';
    let thumbnailSource: 'user' | 'auto' = 'auto';

    if (files.thumbnail && files.thumbnail.length > 0) {
      // ì‚¬ìš©ìê°€ ì¸ë„¤ì¼ì„ ì œê³µí•œ ê²½ìš°
      const thumbnailFile = files.thumbnail[0];
      if (!thumbnailFile) {
        res.status(400).json({ message: 'Thumbnail file is invalid' });
        return;
      }
      // Firebase Storageì— ì¸ë„¤ì¼ ì§ì ‘ ì—…ë¡œë“œ
      if (!thumbnailFile.buffer) {
        res.status(400).json({ message: 'Thumbnail file buffer is missing' });
        return;
      }
      
      const thumbnailUploadResult = await uploadToFirebase(thumbnailFile, 'uploads/thumbnails/');
      thumbnailUrl = thumbnailUploadResult.url;
      thumbnailSource = 'user';
    } else if (animation) {
      // ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€ì—ì„œ ì²« ë²ˆì§¸ í”„ë ˆì„ ì¶”ì¶œ (Firebase Storage URL ì‚¬ìš©)
      const rows = Math.ceil(animation.frames / animation.columns);
      const thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
        imageUrl, // Firebase Storage URL ì‚¬ìš©
        animation.columns,
        rows,
        imageFile.filename
      );
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    } else {
      // ì¼ë°˜ ì´ë¯¸ì§€ì—ì„œ ì¸ë„¤ì¼ ìƒì„± (Firebase Storage URL ì‚¬ìš©)
      const thumbnailResult = await ThumbnailGenerator.generateThumbnail(
        imageUrl,
        imageFile.filename
      );
      thumbnailUrl = thumbnailResult.thumbnailUrl;
      thumbnailSource = 'auto';
    }

    const newItem = {
      name,
      imageUrl,
      animationUrl: animation ? imageUrl : undefined,
      animation,
      thumbnailUrl,
      thumbnailSource,
      order: parseInt(order) || 0
    };

    category.items.push(newItem as any);
    await category.save();

    res.status(201).json({ 
      message: 'Item added successfully', 
      item: newItem,
      category: category.name
    });
  } catch (error) {
    console.error('Error adding item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const updateItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;
    const { name, order, frames, columns, duration, animationType } = req.body;
    const files = req.files as MulterFiles;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];

    // ê¸°ì¡´ íŒŒì¼ ê²½ë¡œ ì €ì¥ (ì‚­ì œìš©)
    const oldImagePath = item.imageUrl ? getFilePathFromUrl(item.imageUrl) : '';
    const oldThumbnailPath = item.thumbnailUrl ? getThumbnailPathFromUrl(item.thumbnailUrl) : '';

    // ê¸°ë³¸ ì •ë³´ ì—…ë°ì´íŠ¸
    if (name !== undefined) item.name = name;
    if (order !== undefined) item.order = parseInt(order);

    // ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸
    if (animationType !== undefined) {
      if (animationType === 'none' || animationType === '') {
        // ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ ë˜ëŠ” ì„ íƒ ì•ˆí•¨ì¸ ê²½ìš° animation ì œê±°
        item.animation = undefined;
        item.animationUrl = undefined;
      } else {
        // ì• ë‹ˆë©”ì´ì…˜ì´ ìˆëŠ” ê²½ìš°
        if (!item.animation) {
          item.animation = {
            frames: parseInt(frames) || 1,
            columns: parseInt(columns) || 1,
            duration: parseInt(duration) || 1000,
            type: animationType
          };
        } else {
          if (frames !== undefined) item.animation.frames = parseInt(frames);
          if (columns !== undefined) item.animation.columns = parseInt(columns);
          if (duration !== undefined) item.animation.duration = parseInt(duration);
          item.animation.type = animationType;
        }
        item.animationUrl = item.imageUrl;
      }
    } else if (frames || columns || duration) {
      // animationTypeì´ undefinedì´ì§€ë§Œ ë‹¤ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì •ë³´ê°€ ìˆëŠ” ê²½ìš°
      if (!item.animation) {
        item.animation = {
          frames: parseInt(frames) || 1,
          columns: parseInt(columns) || 1,
          duration: parseInt(duration) || 1000,
          type: 'loop'
        };
      } else {
        if (frames !== undefined) item.animation.frames = parseInt(frames);
        if (columns !== undefined) item.animation.columns = parseInt(columns);
        if (duration !== undefined) item.animation.duration = parseInt(duration);
      }
    }

    // ìƒˆ ì´ë¯¸ì§€ê°€ ìˆëŠ” ê²½ìš°
    if (files && files.image && files.image.length > 0) {
      const imageFile = files.image[0];
      if (imageFile) {
        // Firebase Storage ì‚¬ìš© ì‹œ ë¡œì»¬ íŒŒì¼ ì‚­ì œ ë¶ˆí•„ìš” (URLì´ë¯€ë¡œ)
        // ê¸°ì¡´ Firebase Storage íŒŒì¼ì€ ìë™ìœ¼ë¡œ ê´€ë¦¬ë¨

        // Firebase Storageì— ìƒˆ ì´ë¯¸ì§€ ì—…ë¡œë“œ (ë©”ëª¨ë¦¬ì—ì„œ ì§ì ‘ ì‚¬ìš©)
        if (!imageFile.buffer) {
          res.status(400).json({ message: 'Image file buffer is missing' });
          return;
        }
        
        const imageResult = await uploadToFirebase(imageFile, 'uploads/items/');
        item.imageUrl = imageResult.url;
        
        if (item.animation) {
          item.animationUrl = item.imageUrl;
        }

        // ê¸°ì¡´ ì¸ë„¤ì¼ì´ ìë™ ìƒì„±ëœ ê²ƒì´ë©´ ìƒˆë¡œ ìƒì„±
        if (item.thumbnailSource === 'auto') {
          // Firebase Storage ì‚¬ìš© ì‹œ ì¸ë„¤ì¼ë„ URLì´ë¯€ë¡œ ë¡œì»¬ ì‚­ì œ ë¶ˆí•„ìš”

          let thumbnailResult;
          if (item.animation) {
            const rows = Math.ceil(item.animation.frames / item.animation.columns);
            thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
              item.imageUrl, // Firebase Storage URL ì‚¬ìš©
              item.animation.columns,
              rows,
              imageFile.filename
            );
          } else {
            thumbnailResult = await ThumbnailGenerator.generateThumbnail(
              item.imageUrl, // Firebase Storage URL ì‚¬ìš©
              imageFile.filename
            );
          }
          item.thumbnailUrl = thumbnailResult.thumbnailUrl;
        }
      }
    }

    // ìƒˆ ì¸ë„¤ì¼ì´ ìˆëŠ” ê²½ìš°
    if (files && files.thumbnail && files.thumbnail.length > 0) {
      const thumbnailFile = files.thumbnail[0];
      if (thumbnailFile) {
        // Firebase Storage ì‚¬ìš© ì‹œ ì¸ë„¤ì¼ íŒŒì¼ë„ URLì´ë¯€ë¡œ ë¡œì»¬ ì‚­ì œ ë¶ˆí•„ìš”

        // Firebase Storageì— ì¸ë„¤ì¼ ì—…ë¡œë“œ í›„ ì²˜ë¦¬
        if (!thumbnailFile.buffer) {
          res.status(400).json({ message: 'Thumbnail file buffer is missing' });
          return;
        }
        
        const thumbnailUploadResult = await uploadToFirebase(thumbnailFile, 'uploads/thumbnails/');
        item.thumbnailUrl = thumbnailUploadResult.url;
        item.thumbnailSource = 'user';
      }
    }

    await category.save();

    res.json({ 
      message: 'Item updated successfully', 
      item,
      category: category.name
    });
  } catch (error) {
    console.error('Error updating item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const deleteItem = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];

    // ê´€ë ¨ íŒŒì¼ë“¤ ì‚­ì œ
    if (item.imageUrl) {
      const imagePath = getFilePathFromUrl(item.imageUrl);
      await deleteFileIfExists(imagePath);
    }
    if (item.thumbnailUrl) {
      const thumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
      await deleteFileIfExists(thumbnailPath);
    }

    category.items.splice(itemIndex, 1);
    await category.save();

    res.json({ message: 'Item deleted successfully' });
  } catch (error) {
    console.error('Error deleting item:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export const regenerateItemThumbnail = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user || !req.user.isAdmin) {
      res.status(403).json({ message: 'Admin access required' });
      return;
    }

    const { categoryId, itemId } = req.params;

    const category = await ItemCategory.findById(categoryId);
    if (!category) {
      res.status(404).json({ message: 'Item category not found' });
      return;
    }

    const itemIndex = category.items.findIndex(item => (item as any)._id?.toString() === itemId);
    if (itemIndex === -1) {
      res.status(404).json({ message: 'Item not found' });
      return;
    }

    const item = category.items[itemIndex];
    
    // ì›ë³¸ ì´ë¯¸ì§€ ê²½ë¡œ ì¶”ì¶œ
    const imagePath = path.join(process.cwd(), 'uploads', path.basename(item.imageUrl));
    
    // ê¸°ì¡´ ì¸ë„¤ì¼ ì‚­ì œ
    if (item.thumbnailUrl) {
      const oldThumbnailPath = getThumbnailPathFromUrl(item.thumbnailUrl);
      await deleteFileIfExists(oldThumbnailPath);
    }
    
    // ì¸ë„¤ì¼ ì¬ìƒì„±
    let thumbnailResult;
    if (item.animation) {
      const rows = Math.ceil(item.animation.frames / item.animation.columns);
      thumbnailResult = await ThumbnailGenerator.generateThumbnailFromSprite(
        imagePath,
        item.animation.columns,
        rows
      );
    } else {
      thumbnailResult = await ThumbnailGenerator.generateThumbnail(imagePath);
    }
    
    item.thumbnailUrl = thumbnailResult.thumbnailUrl;
    item.thumbnailSource = 'auto';

    await category.save();

    res.json({ 
      message: 'Thumbnail regenerated successfully', 
      thumbnailUrl: item.thumbnailUrl
    });
  } catch (error) {
    console.error('Error regenerating thumbnail:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/authController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { generateToken } from '../middleware/auth';
import { validationResult } from 'express-validator';

export const loginUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    const { email, arId } = req.body;
    
    // ì´ë©”ì¼ ë˜ëŠ” arIdë¡œ ì‚¬ìš©ì ì°¾ê¸°
    const query = email ? { email } : { arId };
    const user = await User.findOne(query);
    
    if (!user) {
      res.status(401).json({ error: 'Invalid credentials' });
      return;
    }
    
    // JWT í† í° ìƒì„±
    const token = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });
    
    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        nameEn: user.nameEn,
        role: user.role,
        part: user.part,
        arId: user.arId,
        isAdmin: user.isAdmin,
        isNamecardActive: user.isNamecardActive
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getTestToken = async (req: Request, res: Response): Promise<void> => {
  try {
    const { arId } = req.params;
    
    const user = await User.findOne({ arId });
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    const token = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });
    
    res.json({
      message: 'Test token generated',
      token,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        arId: user.arId,
        isAdmin: user.isAdmin
      }
    });
  } catch (error) {
    console.error('Test token generation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/avatarController.ts">
import { Request, Response } from 'express';
import { UserCustomization, AvatarCategory } from '../models';
import { validationResult } from 'express-validator';

export const getAvatarByUserId = async (req: Request, res: Response): Promise<void> => {
  try {
    const { userId } = req.params;
    
    // ë¨¼ì € idë¡œ ê²€ìƒ‰
    let avatar = await UserCustomization.findOne({ id: userId });
    let user = null;
    
    // idë¡œ ì°¾ì§€ ëª»í•˜ë©´ User í…Œì´ë¸”ì—ì„œ arIdë¡œ ê²€ìƒ‰í•´ì„œ ì‹¤ì œ idë¥¼ ì°¾ì•„ ë‹¤ì‹œ ê²€ìƒ‰
    if (!avatar) {
      const { User } = require('../models');
      user = await User.findOne({ arId: userId });
      if (user) {
        avatar = await UserCustomization.findOne({ id: user._id.toString() });
      }
    } else {
      // avatarê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì‚¬ìš©ì ì •ë³´ë„ ê°€ì ¸ì˜¤ê¸°
      const { User } = require('../models');
      user = await User.findById(avatar.id);
    }
    
    if (!avatar) {
      res.status(404).json({ error: 'Avatar not found' });
      return;
    }
    
    // ì•„ë°”íƒ€ ì˜µì…˜ë“¤ì˜ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const { AvatarCategory, ItemCategory } = require('../models');
    
    // avatarSelections ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const avatarSelectionsWithDetails: any = {};
    if (avatar.avatarSelections) {
      for (const [categoryType, optionId] of Object.entries(avatar.avatarSelections)) {
        const category = await AvatarCategory.findOne({ type: categoryType });
        if (category) {
          const option = category.options.find((opt: any) => opt._id.toString() === optionId);
          if (option) {
            // ê¸°ì¡´ ë°ì´í„° í˜¸í™˜ì„±ì„ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§
            let colorOptions = option.color;
            
            // ê¸°ì¡´ êµ¬ì¡°(ë‹¨ì¼ color string)ë¥¼ ìƒˆ êµ¬ì¡°ë¡œ ë³€í™˜
            if (typeof option.color === 'string' && option.imageUrl) {
              colorOptions = [{
                colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
                imageUrl: option.imageUrl
              }];
            }
            // colorê°€ ë°°ì—´ì´ ì•„ë‹ˆê³  imageUrlì´ ìˆëŠ” ê²½ìš° (null, undefined ë“±)
            else if (!Array.isArray(option.color) && option.imageUrl) {
              colorOptions = [{
                colorName: 'Default',
                imageUrl: option.imageUrl
              }];
            }
            
            avatarSelectionsWithDetails[categoryType] = {
              id: optionId,
              name: option.name,
              imageUrl: option.imageUrl,
              thumbnailUrl: option.thumbnailUrl,
              color: colorOptions
            };
          }
        }
      }
    }
    
    // role ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    let roleDetails = null;
    if (avatar.role) {
      const roleCategory = await ItemCategory.findOne({ type: 'role' });
      if (roleCategory) {
        const roleItem = roleCategory.items.find((item: any) => item._id.toString() === avatar.role);
        if (roleItem) {
          roleDetails = {
            id: avatar.role,
            name: roleItem.name,
            imageUrl: roleItem.imageUrl,
            thumbnailUrl: roleItem.thumbnailUrl
          };
        }
      }
    }
    
    // item1, item2, item3 ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const itemDetails: any = {};
    const items = ['item1', 'item2', 'item3'];
    
    for (const itemKey of items) {
      if ((avatar as any)[itemKey]) {
        // ëª¨ë“  ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ì—ì„œ ê²€ìƒ‰
        const itemCategories = await ItemCategory.find({ type: { $ne: 'role' } });
        let found = false;
        
        for (const category of itemCategories) {
          const item = category.items.find((item: any) => item._id.toString() === (avatar as any)[itemKey]);
          if (item) {
            itemDetails[itemKey] = {
              id: (avatar as any)[itemKey],
              name: item.name,
              imageUrl: item.imageUrl,
              thumbnailUrl: item.thumbnailUrl,
              category: category.name
            };
            found = true;
            break;
          }
        }
        
        if (!found) {
          itemDetails[itemKey] = {
            id: (avatar as any)[itemKey],
            name: 'Unknown',
            imageUrl: null,
            thumbnailUrl: null,
            category: 'Unknown'
          };
        }
      }
    }
    
    // ìµœì¢… ì‘ë‹µ êµ¬ì„± (ì‚¬ìš©ì ì •ë³´ + ì•„ë°”íƒ€ ì •ë³´ í†µí•©)
    const response = {
      id: avatar.id,
      nameEn: user ? user.nameEn : null,
      email: user ? user.email : null,
      nameKr: user ? user.nameKr : null,
      part: user ? user.part : '',
      phone: user ? user.phone : null,
      isNamecardActive: user ? user.isNamecardActive : false,
      arId: user ? user.arId : null,
      isAdmin: user ? user.isAdmin : false,
      avatarSelections: avatarSelectionsWithDetails,
      role: roleDetails,
      item1: itemDetails['item1'] || null,
      item2: itemDetails['item2'] || null,
      item3: itemDetails['item3'] || null,
      avatarImgUrl: avatar.avatarImgUrl,
      message: avatar.message || '',
      createdAt: user ? user.createdAt : avatar.createdAt,
      updatedAt: user ? user.updatedAt : avatar.updatedAt
    };
    
    res.json(response);
  } catch (error) {
    console.error('Error fetching avatar:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const updateAvatar = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('Validation errors:', errors.array());
      res.status(400).json({ error: 'Validation failed', details: errors.array() });
      return;
    }
    
    const { userId } = req.params;
    const updateData = req.body;
    
    console.log('Updating avatar for user:', userId);
    console.log('Update data:', updateData);
    
    const avatar = await UserCustomization.findOneAndUpdate(
      { id: userId },
      updateData,
      { new: true, runValidators: true, upsert: true }
    );
    
    res.json(avatar);
  } catch (error) {
    console.error('Error updating avatar:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message, details: error });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const uploadAvatarImage = async (req: Request, res: Response): Promise<void> => {
  try {
    if (!req.file) {
      res.status(400).json({ error: 'No file uploaded' });
      return;
    }
    
    const { userId } = req.body;
    
    if (!userId) {
      res.status(400).json({ error: 'User ID is required' });
      return;
    }
    
    // Firebase Storageë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ì—…ë¡œë“œ
    const { uploadToFirebase } = require('../config/firebase-storage');
    
    if (!req.file.buffer) {
      res.status(400).json({ error: 'File buffer is missing' });
      return;
    }
    
    const uploadResult = await uploadToFirebase(req.file, 'uploads/avatars/');
    const avatarImgUrl = uploadResult.url;
    
    const avatar = await UserCustomization.findOneAndUpdate(
      { id: userId },
      { avatarImgUrl },
      { new: true, runValidators: true, upsert: true }
    );
    
    res.json({ 
      message: 'Avatar image uploaded successfully',
      avatarImgUrl,
      avatar 
    });
  } catch (error) {
    console.error('Error uploading avatar image:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

// ì¼ë°˜ ì‚¬ìš©ììš© ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ (ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ í¬í•¨)
export const getAvatarCategories = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    const query = type ? { type } : {};

    const categories = await AvatarCategory.find(query).sort({ order: 1 });
    
    // ê¸°ì¡´ ë°ì´í„° í˜¸í™˜ì„±ì„ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ì ìš©
    const migratedCategories = categories.map(category => {
      const categoryObj = category.toObject();
      if (categoryObj.options) {
        categoryObj.options = categoryObj.options.map((option: any) => {
          // ê¸°ì¡´ êµ¬ì¡°(ë‹¨ì¼ color string)ë¥¼ ìƒˆ êµ¬ì¡°ë¡œ ë³€í™˜
          if (typeof option.color === 'string' && option.imageUrl) {
            option.color = [{
              colorName: option.color === '#000000' ? 'Black' : option.color === '#ffffff' ? 'White' : option.color,
              imageUrl: option.imageUrl
            }];
          }
          // colorê°€ ë°°ì—´ì´ ì•„ë‹ˆê³  imageUrlì´ ìˆëŠ” ê²½ìš° (null, undefined ë“±)
          else if (!Array.isArray(option.color) && option.imageUrl) {
            option.color = [{
              colorName: 'Default',
              imageUrl: option.imageUrl
            }];
          }
          
          return option;
        });
      }
      return categoryObj;
    });
    
    res.json({ categories: migratedCategories, total: migratedCategories.length });
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/firebaseAuthController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { generateToken } from '../middleware/auth';
import { validationResult } from 'express-validator';
import { initializeFirebase, verifyIdToken } from '../scripts/config/firebase-admin';

export const verifyFirebaseToken = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }

    const { idToken } = req.body;

    initializeFirebase();

    const decodedToken = await verifyIdToken(idToken);
    const firebaseUid = decodedToken.uid;
    const firebaseEmail = decodedToken.email;

    if (!firebaseEmail) {
      res.status(400).json({ error: 'Firebase user email not found' });
      return;
    }

    let user = await User.findOne({ email: firebaseEmail });
    
    if (!user) {
      res.status(404).json({ 
        error: 'User not found in system',
        message: 'Firebase user exists but not registered in AR namecard system',
        firebaseEmail: firebaseEmail
      });
      return;
    }

    const jwtToken = generateToken({
      id: user._id,
      email: user.email,
      arId: user.arId,
      isAdmin: user.isAdmin
    });

    res.json({
      message: 'Firebase authentication successful',
      token: jwtToken,
      user: {
        id: user._id,
        email: user.email,
        nameKr: user.nameKr,
        nameEn: user.nameEn,
        role: user.role,
        part: user.part,
        arId: user.arId,
        isAdmin: user.isAdmin,
        isNamecardActive: user.isNamecardActive
      },
      firebase: {
        uid: firebaseUid,
        email: firebaseEmail
      }
    });
  } catch (error) {
    console.error('Firebase token verification error:', error);
    
    if (error instanceof Error && error.message.includes('Firebase ID token')) {
      res.status(401).json({ error: 'Invalid Firebase ID token' });
      return;
    }
    
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/itemController.ts">
import { Request, Response } from 'express';
import { ItemCategory, AvatarCategory } from '../models';

export const getItems = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    
    let query = {};
    
    if (type) {
      query = { type };
    }
    
    const items = await ItemCategory.find(query).sort({ order: 1, createdAt: -1 });
    
    res.json(items);
  } catch (error) {
    console.error('Error fetching items:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getItemById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const item = await ItemCategory.findById(id);
    
    if (!item) {
      res.status(404).json({ error: 'Item not found' });
      return;
    }
    
    res.json(item);
  } catch (error) {
    console.error('Error fetching item:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getAvatarCategories = async (req: Request, res: Response): Promise<void> => {
  try {
    const { type } = req.query;
    
    let query = {};
    
    if (type) {
      query = { type };
    }
    
    const categories = await AvatarCategory.find(query).sort({ order: 1, createdAt: -1 });
    
    res.json(categories);
  } catch (error) {
    console.error('Error fetching avatar categories:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const getAvatarCategoryById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const category = await AvatarCategory.findById(id);
    
    if (!category) {
      res.status(404).json({ error: 'Avatar category not found' });
      return;
    }
    
    res.json(category);
  } catch (error) {
    console.error('Error fetching avatar category:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
</file>

<file path="src/controllers/userController.ts">
import { Request, Response } from 'express';
import { User } from '../models';
import { validationResult } from 'express-validator';

export const getUserById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const user = await User.findById(id);
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    res.json(user);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

export const updateUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    
    const { id } = req.params;
    const updateData = req.body;
    
    const user = await User.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );
    
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    
    res.json(user);
  } catch (error) {
    console.error('Error updating user:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};

export const createUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    
    const userData = req.body;
    
    const existingUser = await User.findOne({
      $or: [
        { email: userData.email },
        { arId: userData.arId }
      ]
    });
    
    if (existingUser) {
      res.status(409).json({ error: 'User with this email or arId already exists' });
      return;
    }
    
    const user = new User(userData);
    await user.save();
    
    res.status(201).json(user);
  } catch (error) {
    console.error('Error creating user:', error);
    if (error instanceof Error && error.name === 'ValidationError') {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
};
</file>

<file path="src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: any;
}

export const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction): void => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    res.status(401).json({ error: 'Access token required' });
    return;
  }

  const secret = process.env['JWT_SECRET'] || 'your-secret-key';
  
  jwt.verify(token, secret, (err, user) => {
    if (err) {
      res.status(403).json({ error: 'Invalid token' });
      return;
    }
    
    req.user = user;
    next();
  });
};

export const generateToken = (payload: any): string => {
  const secret = process.env['JWT_SECRET'] || 'your-secret-key';
  const expiresIn = process.env['JWT_EXPIRES_IN'] || '24h';
  
  return jwt.sign(payload, secret, { expiresIn } as jwt.SignOptions);
};
</file>

<file path="src/middleware/upload.ts">
import multer from 'multer';
import path from 'path';
import { Request } from 'express';
import { uploadToFirebase } from '../config/firebase-storage';

// ë©”ëª¨ë¦¬ ì €ì¥ìœ¼ë¡œ ë³€ê²½
const storage = multer.memoryStorage();

const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);

  if (mimetype && extname) {
    cb(null, true);
  } else {
    cb(new Error('Only images and documents are allowed'));
  }
};

export const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  },
  fileFilter: fileFilter
});

// Firebase ì—…ë¡œë“œ í•¨ìˆ˜
export const uploadToFirebaseStorage = async (
  file: Express.Multer.File,
  folder: string = 'uploads/'
): Promise<{ url: string; path: string }> => {
  return await uploadToFirebase(file, folder);
};

export const uploadSingle = (fieldName: string) => upload.single(fieldName);
export const uploadMultiple = (fieldName: string, maxCount: number) => upload.array(fieldName, maxCount);
export const uploadFields = (fields: multer.Field[]) => upload.fields(fields);
</file>

<file path="src/models/AvatarCategory.ts">
import { Schema, model, Document } from 'mongoose';

export interface IHairResourceImages {
  hairMiddleImageUrl: string;  // ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ URL (í•„ìˆ˜)
  hairBackImageUrl?: string;   // ë’·ë¨¸ë¦¬ ì´ë¯¸ì§€ URL (ì„ íƒì‚¬í•­)
}

export interface IColorOption {
  colorName: string;
  imageUrl: string;
  paletteImageUrl?: string;
  resourceImages?: IHairResourceImages;  // hair ì¹´í…Œê³ ë¦¬ìš© ë¦¬ì†ŒìŠ¤ ì´ë¯¸ì§€ ê°ì²´
}

export interface IHairParts {
  middle: string;    // ì¤‘ê°„ë¨¸ë¦¬ ì´ë¯¸ì§€ URL (í•„ìˆ˜)
  back?: string;     // ë’·ë¨¸ë¦¬ ì´ë¯¸ì§€ URL (ì„ íƒì‚¬í•­)
}

export interface IAvatarOption {
  name: string;
  imageUrl: string;
  modelUrl?: string;
  thumbnailUrl?: string;
  thumbnailSource?: 'user' | 'auto';
  color?: IColorOption[];
  hairParts?: IHairParts;  // hair ì¹´í…Œê³ ë¦¬ ì „ìš© í•„ë“œ
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface IAvatarCategory extends Document {
  name: string;
  type: string;
  options: IAvatarOption[];
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const avatarOptionSchema = new Schema<IAvatarOption>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  imageUrl: {
    type: String,
    required: true,
    trim: true
  },
  modelUrl: {
    type: String,
    trim: true
  },
  thumbnailUrl: {
    type: String,
    trim: true
  },
  thumbnailSource: {
    type: String,
    enum: ['user', 'auto'],
    default: 'auto'
  },
  color: [{
    colorName: {
      type: String,
      required: true,
      trim: true
    },
    imageUrl: {
      type: String,
      required: true,
      trim: true
    },
    paletteImageUrl: {
      type: String,
      trim: true
    },
    resourceImages: {
      hairMiddleImageUrl: {
        type: String,
        trim: true
      },
      hairBackImageUrl: {
        type: String,
        trim: true
      }
    }
  }],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  _id: true
});

const avatarCategorySchema = new Schema<IAvatarCategory>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  options: [avatarOptionSchema],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

avatarCategorySchema.index({ order: 1 });
avatarCategorySchema.index({ createdAt: -1 });

export const AvatarCategory = model<IAvatarCategory>('AvatarCategory', avatarCategorySchema);
</file>

<file path="src/models/index.ts">
export { User, IUser } from './User';
export { UserCustomization, IUserCustomization } from './UserCustomization';
export { AvatarCategory, IAvatarCategory, IAvatarOption } from './AvatarCategory';
export { ItemCategory, IItemCategory, IItem, IItemAnimation } from './ItemCategory';
</file>

<file path="src/models/ItemCategory.ts">
import { Schema, model, Document } from 'mongoose';

export interface IItemAnimation {
  frames: number;
  columns: number;
  duration: number;
  type: string;
}

export interface IItem {
  name: string;
  imageUrl: string;
  modelUrl?: string;
  animationUrl?: string;
  animation?: IItemAnimation;
  thumbnailUrl?: string;
  thumbnailSource?: 'user' | 'auto';
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface IItemCategory extends Document {
  name: string;
  type: string;
  items: IItem[];
  order: number;
  createdAt: Date;
  updatedAt: Date;
}

const itemAnimationSchema = new Schema<IItemAnimation>({
  frames: {
    type: Number,
    required: true
  },
  columns: {
    type: Number,
    required: true
  },
  duration: {
    type: Number,
    required: true
  },
  type: {
    type: String,
    required: true,
    trim: true
  }
}, { _id: false });

const itemSchema = new Schema<IItem>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  imageUrl: {
    type: String,
    required: true,
    trim: true
  },
  modelUrl: {
    type: String,
    trim: true
  },
  animationUrl: {
    type: String,
    trim: true
  },
  animation: {
    type: itemAnimationSchema,
    required: false
  },
  thumbnailUrl: {
    type: String,
    trim: true
  },
  thumbnailSource: {
    type: String,
    enum: ['user', 'auto'],
    default: 'auto'
  },
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  _id: true
});

const itemCategorySchema = new Schema<IItemCategory>({
  name: {
    type: String,
    required: true,
    trim: true
  },
  type: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  items: [itemSchema],
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

itemCategorySchema.index({ order: 1 });
itemCategorySchema.index({ createdAt: -1 });

export const ItemCategory = model<IItemCategory>('ItemCategory', itemCategorySchema);
</file>

<file path="src/models/User.ts">
import { Schema, model, Document } from 'mongoose';

export interface IUser extends Document {
  id: string;
  nameEn?: string;
  email: string;
  nameKr: string;
  role: string;
  part: string;
  phone: string;
  isNamecardActive: boolean;
  arId: string;
  isAdmin: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>({
  nameEn: {
    type: String,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  nameKr: {
    type: String,
    required: true,
    trim: true
  },
  role: {
    type: String,
    default: 'User',
    trim: true
  },
  part: {
    type: String,
    default: '',
    trim: true
  },
  phone: {
    type: String,
    required: true,
    trim: true
  },
  isNamecardActive: {
    type: Boolean,
    default: false
  },
  arId: {
    type: String,
    required: true,
    unique: true,
    minlength: 3,
    maxlength: 3,
    trim: true
  },
  isAdmin: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

userSchema.index({ createdAt: -1 });

export const User = model<IUser>('User', userSchema);
</file>

<file path="src/models/UserCustomization.ts">
import { Schema, model, Document, Types } from 'mongoose';

export interface IUserCustomization extends Document {
  id: string;
  avatarSelections: any; // Map<string, string> ë˜ëŠ” ê°ì²´ë¥¼ í—ˆìš©
  role?: string;
  item1?: string;
  item2?: string;
  item3?: string;
  avatarImgUrl?: string;
  message?: string;
  createdAt: Date;
  updatedAt: Date;
}

const userCustomizationSchema = new Schema<IUserCustomization>({
  id: {
    type: String,
    required: true,
    unique: true
  },
  avatarSelections: {
    type: Schema.Types.Mixed,
    default: {}
  },
  role: {
    type: String,
    trim: true
  },
  item1: {
    type: String,
    trim: true
  },
  item2: {
    type: String,
    trim: true
  },
  item3: {
    type: String,
    trim: true
  },
  avatarImgUrl: {
    type: String,
    default: null,
    trim: true
  },
  message: {
    type: String,
    trim: true,
    maxlength: 100
  }
}, {
  timestamps: true,
  toJSON: {
    transform: function(_doc, ret: any) {
      if (ret.avatarSelections) {
        if (ret.avatarSelections instanceof Map) {
          ret.avatarSelections = Object.fromEntries(ret.avatarSelections);
        } else if (typeof ret.avatarSelections === 'object' && ret.avatarSelections !== null) {
          // ì´ë¯¸ ê°ì²´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ìœ ì§€
          ret.avatarSelections = ret.avatarSelections;
        } else {
          ret.avatarSelections = {};
        }
      } else {
        ret.avatarSelections = {};
      }
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

userCustomizationSchema.index({ createdAt: -1 });

export const UserCustomization = model<IUserCustomization>('UserCustomization', userCustomizationSchema);
</file>

<file path="src/routes/adminAvatarRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import {
  getAllAvatarCategories,
  getAvatarCategoryById,
  createAvatarCategory,
  updateAvatarCategory,
  deleteAvatarCategory,
  addAvatarOption,
  updateAvatarOption,
  deleteAvatarOption,
  regenerateThumbnail
} from '../controllers/adminAvatarController';
import { authenticateToken } from '../middleware/auth';
import { upload } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Admin - Characters
 *   description: ê´€ë¦¬ì ìºë¦­í„° ìš”ì†Œ ê´€ë¦¬ API
 */

const router = Router();

// ì¹´í…Œê³ ë¦¬ ê´€ë¦¬
const categoryValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('type').isString().isLength({ min: 1, max: 50 }).withMessage('Type must be 1-50 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

// ì˜µì…˜ ê´€ë¦¬
const optionValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('colorOptions').optional().isString().withMessage('Color options must be a JSON string'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

/**
 * @swagger
 * /api/admin/characters/categories:
 *   get:
 *     summary: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ íƒ€ì… í•„í„°
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 categories:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/AvatarCategory'
 *                 total:
 *                   type: integer
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 */
router.get('/categories', authenticateToken, getAllAvatarCategories);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   get:
 *     summary: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìƒì„¸ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìƒì„¸ ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarCategory'
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/categories/:id', authenticateToken, getAvatarCategoryById);

/**
 * @swagger
 * /api/admin/characters/categories:
 *   post:
 *     summary: ìƒˆ ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìƒì„± (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ ì´ë¦„
 *                 example: "í—¤ì–´ìŠ¤íƒ€ì¼"
 *               type:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ íƒ€ì… (ê³ ìœ ê°’)
 *                 example: "hair"
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *                 example: 1
 *     responses:
 *       201:
 *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìƒì„± ì„±ê³µ
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­ ë˜ëŠ” ì¤‘ë³µëœ íƒ€ì…
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 */
router.post('/categories', authenticateToken, categoryValidation, createAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   put:
 *     summary: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìˆ˜ì • (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ ì´ë¦„
 *               type:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ íƒ€ì…
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ìˆ˜ì • ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/categories/:id', authenticateToken, categoryValidation, updateAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}:
 *   delete:
 *     summary: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ì‚­ì œ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ì‚­ì œ ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.delete('/categories/:id', authenticateToken, deleteAvatarCategory);

/**
 * @swagger
 * /api/admin/characters/categories/{id}/options:
 *   post:
 *     summary: ì•„ë°”íƒ€ ì˜µì…˜ ì¶”ê°€ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - colorOptions
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì˜µì…˜ ì´ë¦„
 *               colorOptions:
 *                 type: string
 *                 description: ìƒ‰ìƒ ì˜µì…˜ JSON ë¬¸ìì—´ (ì˜ˆ. [{"colorName":"red","imageUrl":"/uploads/red.jpg"}])
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: ì¸ë„¤ì¼ ì´ë¯¸ì§€ íŒŒì¼ (100x100px, ì„ íƒì‚¬í•­)
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       201:
 *         description: ì•„ë°”íƒ€ ì˜µì…˜ ì¶”ê°€ ì„±ê³µ
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.post('/categories/:id/options', 
  authenticateToken, 
  upload.any(), 
  optionValidation, 
  addAvatarOption
);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}:
 *   put:
 *     summary: ì•„ë°”íƒ€ ì˜µì…˜ ìˆ˜ì • (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì˜µì…˜ ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì˜µì…˜ ì´ë¦„
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: ìƒˆ ì›ë³¸ ì´ë¯¸ì§€ íŒŒì¼ (ì„ íƒì‚¬í•­)
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: ìƒˆ ì¸ë„¤ì¼ ì´ë¯¸ì§€ íŒŒì¼ (ì„ íƒì‚¬í•­)
 *               color:
 *                 type: string
 *                 description: ìƒ‰ìƒ ì •ë³´
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì˜µì…˜ ìˆ˜ì • ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/categories/:categoryId/options/:optionId', 
  authenticateToken, 
  upload.any(), 
  updateAvatarOption
);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}:
 *   delete:
 *     summary: ì•„ë°”íƒ€ ì˜µì…˜ ì‚­ì œ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì˜µì…˜ ID
 *     responses:
 *       200:
 *         description: ì•„ë°”íƒ€ ì˜µì…˜ ì‚­ì œ ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.delete('/categories/:categoryId/options/:optionId', authenticateToken, deleteAvatarOption);

/**
 * @swagger
 * /api/admin/characters/categories/{categoryId}/options/{optionId}/thumbnail/regenerate:
 *   post:
 *     summary: ì•„ë°”íƒ€ ì˜µì…˜ ì¸ë„¤ì¼ ì¬ìƒì„±
 *     tags: [Admin - Characters]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: optionId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì˜µì…˜ ID
 *     responses:
 *       200:
 *         description: ì¸ë„¤ì¼ ì¬ìƒì„± ì„±ê³µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 thumbnailUrl:
 *                   type: string
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ì˜µì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.post('/categories/:categoryId/options/:optionId/thumbnail/regenerate', authenticateToken, regenerateThumbnail);

export default router;
</file>

<file path="src/routes/adminItemRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import {
  getAllItemCategories,
  getItemCategoryById,
  createItemCategory,
  updateItemCategory,
  deleteItemCategory,
  addItem,
  updateItem,
  deleteItem,
  regenerateItemThumbnail
} from '../controllers/adminItemController';
import { authenticateToken } from '../middleware/auth';
import { upload } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Admin - Stickers
 *   description: ê´€ë¦¬ì ìŠ¤í‹°ì»¤ ê´€ë¦¬ API
 */

const router = Router();

// ì¹´í…Œê³ ë¦¬ ê´€ë¦¬
const categoryValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('type').isString().isLength({ min: 1, max: 50 }).withMessage('Type must be 1-50 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer')
];

// ìŠ¤í‹°ì»¤ ê´€ë¦¬
const itemValidation = [
  body('name').isString().isLength({ min: 1, max: 100 }).withMessage('Name must be 1-100 characters'),
  body('order').optional().isInt({ min: 0 }).withMessage('Order must be a non-negative integer'),
  body('frames').optional().isInt({ min: 1 }).withMessage('Frames must be a positive integer'),
  body('columns').optional().isInt({ min: 1, max: 64 }).withMessage('Columns must be 1-64'),
  body('duration').optional().isInt({ min: 1 }).withMessage('Duration must be a positive integer'),
  body('animationType').optional().isString().withMessage('Animation type must be a string')
];

/**
 * @swagger
 * /api/admin/stickers/categories:
 *   get:
 *     summary: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ íƒ€ì… í•„í„°
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ëª©ë¡
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 categories:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/ItemCategory'
 *                 total:
 *                   type: integer
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 */
router.get('/categories', authenticateToken, getAllItemCategories);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   get:
 *     summary: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìƒì„¸ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìƒì„¸ ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ItemCategory'
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/categories/:id', authenticateToken, getItemCategoryById);

/**
 * @swagger
 * /api/admin/stickers/categories:
 *   post:
 *     summary: ìƒˆ ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìƒì„± (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - type
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ ì´ë¦„
 *                 example: "ìš´ë™"
 *               type:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ íƒ€ì… (ê³ ìœ ê°’)
 *                 example: "exercise"
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *                 example: 1
 *     responses:
 *       201:
 *         description: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìƒì„± ì„±ê³µ
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­ ë˜ëŠ” ì¤‘ë³µëœ íƒ€ì…
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 */
router.post('/categories', authenticateToken, categoryValidation, createItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   put:
 *     summary: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìˆ˜ì • (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ ì´ë¦„
 *               type:
 *                 type: string
 *                 description: ì¹´í…Œê³ ë¦¬ íƒ€ì…
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ìˆ˜ì • ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/categories/:id', authenticateToken, categoryValidation, updateItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}:
 *   delete:
 *     summary: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ì‚­ì œ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì¹´í…Œê³ ë¦¬ ì‚­ì œ ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.delete('/categories/:id', authenticateToken, deleteItemCategory);

/**
 * @swagger
 * /api/admin/stickers/categories/{id}/items:
 *   post:
 *     summary: ìŠ¤í‹°ì»¤ ì¶”ê°€ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - image
 *             properties:
 *               name:
 *                 type: string
 *                 description: ìŠ¤í‹°ì»¤ ì´ë¦„
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: ì›ë³¸ ì´ë¯¸ì§€ ë˜ëŠ” ìŠ¤í”„ë¼ì´íŠ¸ ì‹œí€€ìŠ¤ ì´ë¯¸ì§€
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: ì¸ë„¤ì¼ ì´ë¯¸ì§€ íŒŒì¼ (100x100px, ì„ íƒì‚¬í•­)
 *               frames:
 *                 type: integer
 *                 description: ì´ í”„ë ˆì„ ìˆ˜ (ì• ë‹ˆë©”ì´ì…˜ì¸ ê²½ìš°)
 *               columns:
 *                 type: integer
 *                 description: ìŠ¤í”„ë¼ì´íŠ¸ì‹œíŠ¸ ì»¬ëŸ¼ ìˆ˜ (ê¸°ë³¸ê°’ 16)
 *                 default: 16
 *               duration:
 *                 type: integer
 *                 description: ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ (ms)
 *               animationType:
 *                 type: string
 *                 description: ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… (loop, once, etc.)
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       201:
 *         description: ìŠ¤í‹°ì»¤ ì¶”ê°€ ì„±ê³µ
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.post('/categories/:id/items', 
  authenticateToken, 
  upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'thumbnail', maxCount: 1 }
  ]), 
  itemValidation, 
  addItem
);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}:
 *   put:
 *     summary: ìŠ¤í‹°ì»¤ ìˆ˜ì • (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: ìŠ¤í‹°ì»¤ ID
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: ìŠ¤í‹°ì»¤ ì´ë¦„
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: ìƒˆ ì›ë³¸ ì´ë¯¸ì§€ (ì„ íƒì‚¬í•­)
 *               thumbnail:
 *                 type: string
 *                 format: binary
 *                 description: ìƒˆ ì¸ë„¤ì¼ ì´ë¯¸ì§€ (ì„ íƒì‚¬í•­)
 *               frames:
 *                 type: integer
 *                 description: ì´ í”„ë ˆì„ ìˆ˜
 *               columns:
 *                 type: integer
 *                 description: ìŠ¤í”„ë¼ì´íŠ¸ì‹œíŠ¸ ì»¬ëŸ¼ ìˆ˜
 *               duration:
 *                 type: integer
 *                 description: ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ (ms)
 *               animationType:
 *                 type: string
 *                 description: ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…
 *               order:
 *                 type: integer
 *                 description: í‘œì‹œ ìˆœì„œ
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ìˆ˜ì • ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ìŠ¤í‹°ì»¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/categories/:categoryId/items/:itemId', 
  authenticateToken, 
  upload.fields([
    { name: 'image', maxCount: 1 },
    { name: 'thumbnail', maxCount: 1 }
  ]), 
  updateItem
);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}:
 *   delete:
 *     summary: ìŠ¤í‹°ì»¤ ì‚­ì œ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: ìŠ¤í‹°ì»¤ ID
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì‚­ì œ ì„±ê³µ
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ìŠ¤í‹°ì»¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.delete('/categories/:categoryId/items/:itemId', authenticateToken, deleteItem);

/**
 * @swagger
 * /api/admin/stickers/categories/{categoryId}/items/{itemId}/regenerate-thumbnail:
 *   post:
 *     summary: ìŠ¤í‹°ì»¤ ì¸ë„¤ì¼ ì¬ìƒì„± (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: categoryId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ ID
 *       - in: path
 *         name: itemId
 *         required: true
 *         schema:
 *           type: string
 *         description: ìŠ¤í‹°ì»¤ ID
 *     responses:
 *       200:
 *         description: ì¸ë„¤ì¼ ì¬ìƒì„± ì„±ê³µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 thumbnailUrl:
 *                   type: string
 *       404:
 *         description: ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ìŠ¤í‹°ì»¤ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.post('/categories/:categoryId/items/:itemId/regenerate-thumbnail', authenticateToken, regenerateItemThumbnail);

export default router;
</file>

<file path="src/routes/adminRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getAllUsers, updateUserPermissions } from '../controllers/adminController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Admin - Users
 *   description: ê´€ë¦¬ì ì‚¬ìš©ì ê´€ë¦¬ API
 */

const router = Router();

const permissionUpdateValidation = [
  body('isAdmin').optional().isBoolean().withMessage('isAdmin must be a boolean'),
  body('isNamecardActive').optional().isBoolean().withMessage('isNamecardActive must be a boolean'),
  body('role').optional().isString().withMessage('role must be a string').trim()
];

/**
 * @swagger
 * /api/admin/users:
 *   get:
 *     summary: ì „ì²´ ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: í˜ì´ì§€ ë²ˆí˜¸
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 20
 *         description: í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: ê²€ìƒ‰ì–´ (ì´ë¦„, ì´ë©”ì¼, arId)
 *       - in: query
 *         name: role
 *         schema:
 *           type: string
 *         description: ì—­í•  í•„í„°
 *       - in: query
 *         name: isActive
 *         schema:
 *           type: boolean
 *         description: í™œì„±í™” ìƒíƒœ í•„í„°
 *     responses:
 *       200:
 *         description: ì‚¬ìš©ì ëª©ë¡
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 *                 pagination:
 *                   type: object
 *                   properties:
 *                     page:
 *                       type: integer
 *                     limit:
 *                       type: integer
 *                     total:
 *                       type: integer
 *                     pages:
 *                       type: integer
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 */
router.get('/users', authenticateToken, getAllUsers);

/**
 * @swagger
 * /api/admin/users/{id}:
 *   put:
 *     summary: ì‚¬ìš©ì ê¶Œí•œ ê´€ë¦¬ (ê´€ë¦¬ì ì „ìš©)
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì‚¬ìš©ì ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               isAdmin:
 *                 type: boolean
 *                 description: ê´€ë¦¬ì ì—¬ë¶€
 *               isNamecardActive:
 *                 type: boolean
 *                 description: ëª…í•¨ í™œì„±í™” ì—¬ë¶€
 *               role:
 *                 type: string
 *                 description: ì—­í• 
 *     responses:
 *       200:
 *         description: ìˆ˜ì •ëœ ì‚¬ìš©ì ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       403:
 *         description: ê´€ë¦¬ì ê¶Œí•œ í•„ìš”
 *       404:
 *         description: ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/users/:id', authenticateToken, permissionUpdateValidation, updateUserPermissions);

export default router;
</file>

<file path="src/routes/authRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { loginUser, getTestToken } from '../controllers/authController';

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: "ì‚¬ìš©ì ì¸ì¦ API"
 */

const router = Router();

const loginValidation = [
  body('email').optional().isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('arId').optional().isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters')
];

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: "ì‚¬ìš©ì ë¡œê·¸ì¸"
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 description: "ì´ë©”ì¼ (email ë˜ëŠ” arId ì¤‘ í•˜ë‚˜ í•„ìˆ˜)"
 *               arId:
 *                 type: string
 *                 description: "AR ëª…í•¨ ID (email ë˜ëŠ” arId ì¤‘ í•˜ë‚˜ í•„ìˆ˜)"
 *             example:
 *               email: "hyeonseo.ahn@hnine.com"
 *     responses:
 *       200:
 *         description: "ë¡œê·¸ì¸ ì„±ê³µ"
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 token:
 *                   type: string
 *                   description: "JWT í† í°"
 *                 user:
 *                   $ref: '#/components/schemas/User'
 *       401:
 *         description: "ì¸ì¦ ì‹¤íŒ¨"
 *       400:
 *         description: "ì˜ëª»ëœ ìš”ì²­"
 */
router.post('/login', loginValidation, loginUser);

/**
 * @swagger
 * /api/auth/test-token/{arId}:
 *   get:
 *     summary: "í…ŒìŠ¤íŠ¸ìš© í† í° ìƒì„± (ê°œë°œìš©)"
 *     tags: [Authentication]
 *     parameters:
 *       - in: path
 *         name: arId
 *         required: true
 *         schema:
 *           type: string
 *         description: "AR ëª…í•¨ ID (ì˜ˆ: 001)"
 *     responses:
 *       200:
 *         description: "í…ŒìŠ¤íŠ¸ í† í° ìƒì„± ì„±ê³µ"
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 token:
 *                   type: string
 *                   description: "JWT í† í°"
 *                 user:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                     email:
 *                       type: string
 *                     nameKr:
 *                       type: string
 *                     arId:
 *                       type: string
 *                     isAdmin:
 *                       type: boolean
 *       404:
 *         description: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"
 */
router.get('/test-token/:arId', getTestToken);

export default router;
</file>

<file path="src/routes/avatarRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getAvatarByUserId, updateAvatar, uploadAvatarImage } from '../controllers/avatarController';
// import { getAvatarCategories } from '../controllers/avatarController'; // Hidden endpoint
import { authenticateToken } from '../middleware/auth';
import { uploadSingle } from '../middleware/upload';

/**
 * @swagger
 * tags:
 *   name: Avatars
 *   description: ì•„ë°”íƒ€ ê´€ë¦¬ API
 */

const router = Router();

// Hidden endpoint - ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒëŠ” Characters APIì—ì„œ ì²˜ë¦¬
// /**
//  * @swagger
//  * /api/avatars/categories:
//  *   get:
//  *     summary: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ (ì¼ë°˜ ì‚¬ìš©ììš©)
//  *     tags: [Avatars]
//  *     parameters:
//  *       - in: query
//  *         name: type
//  *         schema:
//  *           type: string
//  *         description: ì¹´í…Œê³ ë¦¬ íƒ€ì… í•„í„°
//  *     responses:
//  *       200:
//  *         description: ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡
//  *         content:
//  *           application/json:
//  *             schema:
//  *               type: object
//  *               properties:
//  *                 categories:
//  *                   type: array
//  *                   items:
//  *                     $ref: '#/components/schemas/AvatarCategory'
//  *                 total:
//  *                   type: integer
//  */
// router.get('/categories', getAvatarCategories);

const avatarValidation = [
  body('avatarSelections').optional().isObject().withMessage('Avatar selections must be an object'),
  body('role').optional().trim(),
  body('item1').optional().trim(),
  body('item2').optional().trim(),
  body('item3').optional().trim(),
  body('avatarImgUrl').optional().matches(/^(\/uploads\/.*\.(png|jpg|jpeg|gif|webp)$|https:\/\/.*\.(png|jpg|jpeg|gif|webp)$)/i).withMessage('Avatar image URL must be a valid image path').trim()
];

/**
 * @swagger
 * /api/avatars/{userId}:
 *   get:
 *     summary: ì•„ë°”íƒ€ ì •ë³´ ì¡°íšŒ (ì‚¬ìš©ì ì •ë³´ í¬í•¨ 8thwall ìš©)
 *     tags: [Avatars]
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì‚¬ìš©ì ID ë˜ëŠ” arId
 *     responses:
 *       200:
 *         description: ì‚¬ìš©ì ì •ë³´ì™€ ì•„ë°”íƒ€ ì •ë³´ê°€ í•©ì³ì§„ ì‘ë‹µ
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarWithUser'
 *       404:
 *         description: ì•„ë°”íƒ€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/:userId', getAvatarByUserId);

/**
 * @swagger
 * /api/avatars/{userId}:
 *   put:
 *     summary: ì•„ë°”íƒ€ ì •ë³´ ìˆ˜ì •
 *     tags: [Avatars]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: string
 *         description: ì‚¬ìš©ì ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               avatarSelections:
 *                 type: object
 *                 description: ì•„ë°”íƒ€ ì„ íƒ ì˜µì…˜
 *                 additionalProperties:
 *                   type: string
 *               role:
 *                 type: string
 *                 description: ì—­í• 
 *               item1:
 *                 type: string
 *                 description: ì•„ì´í…œ 1
 *               item2:
 *                 type: string
 *                 description: ì•„ì´í…œ 2
 *               item3:
 *                 type: string
 *                 description: ì•„ì´í…œ 3
 *               avatarImgUrl:
 *                 type: string
 *                 description: ì•„ë°”íƒ€ ì´ë¯¸ì§€ URL
 *     responses:
 *       200:
 *         description: ìˆ˜ì •ëœ ì•„ë°”íƒ€ ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserCustomization'
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 */
router.put('/:userId', authenticateToken, avatarValidation, updateAvatar);

/**
 * @swagger
 * /api/avatars/upload:
 *   post:
 *     summary: ì•„ë°”íƒ€ ì´ë¯¸ì§€ ì—…ë¡œë“œ
 *     tags: [Avatars]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               avatar:
 *                 type: string
 *                 format: binary
 *                 description: ì•„ë°”íƒ€ ì´ë¯¸ì§€ íŒŒì¼
 *               userId:
 *                 type: string
 *                 description: ì‚¬ìš©ì ID
 *             required:
 *               - avatar
 *               - userId
 *     responses:
 *       200:
 *         description: ì—…ë¡œë“œ ì„±ê³µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: ì„±ê³µ ë©”ì‹œì§€
 *                 avatarImgUrl:
 *                   type: string
 *                   description: ì—…ë¡œë“œëœ ì´ë¯¸ì§€ URL
 *                 avatar:
 *                   $ref: '#/components/schemas/UserCustomization'
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 */
router.post('/upload', authenticateToken, uploadSingle('avatar'), uploadAvatarImage);

export default router;
</file>

<file path="src/routes/charactersRoutes.ts">
import { Router } from 'express';
import { getAvatarCategories, getAvatarCategoryById } from '../controllers/itemController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Characters And Stickers
 *   description: ìºë¦­í„° ìš”ì†Œ ë° ìŠ¤í‹°ì»¤ ê´€ë¦¬ API
 */

const router = Router();

/**
 * @swagger
 * /api/characters:
 *   get:
 *     summary: ìºë¦­í„° ìš”ì†Œ ì „ì²´ ëª©ë¡ ì¡°íšŒ (ëˆˆ, ì½”, ì…, ë¨¸ë¦¬, ëˆˆì¹ ë“±)
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: ì¹´í…Œê³ ë¦¬ íƒ€ì… í•„í„°
 *     responses:
 *       200:
 *         description: ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ëª©ë¡
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/AvatarCategory'
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 */
router.get('/', authenticateToken, getAvatarCategories);

/**
 * @swagger
 * /api/characters/{id}:
 *   get:
 *     summary: ìºë¦­í„° ìš”ì†Œ ìƒì„¸ ì¡°íšŒ
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ID
 *     responses:
 *       200:
 *         description: ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/AvatarCategory'
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       404:
 *         description: ìºë¦­í„° ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/:id', authenticateToken, getAvatarCategoryById);

export default router;
</file>

<file path="src/routes/firebaseAuthRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { verifyFirebaseToken } from '../controllers/firebaseAuthController';

/**
 * @swagger
 * tags:
 *   name: Authentication
 *   description: ì‚¬ìš©ì ì¸ì¦ API
 */

const router = Router();

const firebaseTokenValidation = [
  body('idToken')
    .notEmpty()
    .withMessage('Firebase ID token is required')
    .isString()
    .withMessage('ID token must be a string')
];

/**
 * @swagger
 * /api/auth/firebase/verify:
 *   post:
 *     summary: Firebase ID í† í° ê²€ì¦ ë° ë¡œê·¸ì¸
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - idToken
 *             properties:
 *               idToken:
 *                 type: string
 *                 description: Firebase Authenticationì—ì„œ ë°œê¸‰ëœ ID í† í°
 *             example:
 *               idToken: "eyJhbGciOiJSUzI1NiIsImtpZCI6IjE2N..."
 *     responses:
 *       200:
 *         description: Firebase ì¸ì¦ ì„±ê³µ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Firebase authentication successful"
 *                 token:
 *                   type: string
 *                   description: AR ëª…í•¨ ì‹œìŠ¤í…œ JWT í† í°
 *                 user:
 *                   $ref: '#/components/schemas/User'
 *                 firebase:
 *                   type: object
 *                   properties:
 *                     uid:
 *                       type: string
 *                       description: Firebase ì‚¬ìš©ì UID
 *                     email:
 *                       type: string
 *                       description: Firebase ì‚¬ìš©ì ì´ë©”ì¼
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­ (ID í† í° ëˆ„ë½ ë“±)
 *       401:
 *         description: ìœ íš¨í•˜ì§€ ì•Šì€ Firebase ID í† í°
 *       404:
 *         description: Firebase ì‚¬ìš©ìëŠ” ì¡´ì¬í•˜ì§€ë§Œ AR ëª…í•¨ ì‹œìŠ¤í…œì— ë“±ë¡ë˜ì§€ ì•ŠìŒ
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "User not found in system"
 *                 message:
 *                   type: string
 *                   example: "Firebase user exists but not registered in AR namecard system"
 *                 firebaseEmail:
 *                   type: string
 *                   description: Firebaseì—ì„œ í™•ì¸ëœ ì´ë©”ì¼
 *       500:
 *         description: ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜
 */
router.post('/verify', firebaseTokenValidation, verifyFirebaseToken);

export default router;
</file>

<file path="src/routes/itemRoutes.ts">
import { Router } from 'express';
import { getItems, getItemById, getAvatarCategories, getAvatarCategoryById } from '../controllers/itemController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Characters And Stickers
 *   description: ìºë¦­í„° ìš”ì†Œ ë° ìŠ¤í‹°ì»¤ ê´€ë¦¬ API
 */

const router = Router();

/**
 * @swagger
 * /api/stickers:
 *   get:
 *     summary: ìŠ¤í‹°ì»¤ ì „ì²´ ëª©ë¡ ì¡°íšŒ
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: type
 *         schema:
 *           type: string
 *         description: ìŠ¤í‹°ì»¤ íƒ€ì… í•„í„°
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ëª©ë¡
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/ItemCategory'
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 */
router.get('/', authenticateToken, getItems);

/**
 * @swagger
 * /api/stickers/{id}:
 *   get:
 *     summary: ìŠ¤í‹°ì»¤ ìƒì„¸ ì¡°íšŒ
 *     tags: [Characters And Stickers]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ìŠ¤í‹°ì»¤ ID
 *     responses:
 *       200:
 *         description: ìŠ¤í‹°ì»¤ ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ItemCategory'
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       404:
 *         description: ìŠ¤í‹°ì»¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/:id', authenticateToken, getItemById);

export default router;
</file>

<file path="src/routes/userRoutes.ts">
import { Router } from 'express';
import { body } from 'express-validator';
import { getUserById, updateUser, createUser } from '../controllers/userController';
import { authenticateToken } from '../middleware/auth';

/**
 * @swagger
 * tags:
 *   name: Admin - Users
 *   description: ê´€ë¦¬ì ì‚¬ìš©ì ê´€ë¦¬ API
 */

const router = Router();

const userValidation = [
  body('email').isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('nameKr').notEmpty().withMessage('Korean name is required').trim(),
  body('phone').notEmpty().withMessage('Phone number is required').trim(),
  body('arId').isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters'),
  body('nameEn').optional().trim(),
  body('role').optional().trim(),
  body('part').optional().trim(),
  body('isNamecardActive').optional().isBoolean(),
  body('isAdmin').optional().isBoolean()
];

const userUpdateValidation = [
  body('email').optional().isEmail().withMessage('Valid email is required').normalizeEmail(),
  body('nameKr').optional().notEmpty().withMessage('Korean name cannot be empty').trim(),
  body('phone').optional().notEmpty().withMessage('Phone number cannot be empty').trim(),
  body('arId').optional().isLength({ min: 3, max: 3 }).withMessage('arId must be exactly 3 characters'),
  body('nameEn').optional().trim(),
  body('role').optional().trim(),
  body('part').optional().trim(),
  body('isNamecardActive').optional().isBoolean(),
  body('isAdmin').optional().isBoolean()
];

/**
 * @swagger
 * /api/users/{id}:
 *   get:
 *     summary: ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì‚¬ìš©ì ID
 *     responses:
 *       200:
 *         description: ì‚¬ìš©ì ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       404:
 *         description: ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.get('/:id', authenticateToken, getUserById);

/**
 * @swagger
 * /api/users/{id}:
 *   put:
 *     summary: ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •
 *     tags: [Admin - Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *         description: ì‚¬ìš©ì ID
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nameEn:
 *                 type: string
 *                 description: ì˜ë¬¸ ì´ë¦„
 *               email:
 *                 type: string
 *                 description: ì´ë©”ì¼
 *               nameKr:
 *                 type: string
 *                 description: í•œê¸€ ì´ë¦„
 *               role:
 *                 type: string
 *                 description: ì—­í• 
 *               part:
 *                 type: string
 *                 description: ì†Œì† ë¶€ì„œ
 *               phone:
 *                 type: string
 *                 description: ì „í™”ë²ˆí˜¸
 *               isNamecardActive:
 *                 type: boolean
 *                 description: ëª…í•¨ í™œì„±í™” ì—¬ë¶€
 *               arId:
 *                 type: string
 *                 description: AR ëª…í•¨ ID (3ìë¦¬)
 *               isAdmin:
 *                 type: boolean
 *                 description: ê´€ë¦¬ì ì—¬ë¶€
 *     responses:
 *       200:
 *         description: ìˆ˜ì •ëœ ì‚¬ìš©ì ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       401:
 *         description: ì¸ì¦ ì‹¤íŒ¨
 *       404:
 *         description: ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
 */
router.put('/:id', authenticateToken, userUpdateValidation, updateUser);

/**
 * @swagger
 * /api/users:
 *   post:
 *     summary: ì‚¬ìš©ì ìƒì„±
 *     tags: [Admin - Users]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - nameKr
 *               - phone
 *               - arId
 *             properties:
 *               nameEn:
 *                 type: string
 *                 description: ì˜ë¬¸ ì´ë¦„
 *               email:
 *                 type: string
 *                 description: ì´ë©”ì¼
 *               nameKr:
 *                 type: string
 *                 description: í•œê¸€ ì´ë¦„
 *               role:
 *                 type: string
 *                 description: ì—­í• 
 *                 default: User
 *               part:
 *                 type: string
 *                 description: ì†Œì† ë¶€ì„œ
 *                 default: ""
 *               phone:
 *                 type: string
 *                 description: ì „í™”ë²ˆí˜¸
 *               isNamecardActive:
 *                 type: boolean
 *                 description: ëª…í•¨ í™œì„±í™” ì—¬ë¶€
 *                 default: false
 *               arId:
 *                 type: string
 *                 description: AR ëª…í•¨ ID (3ìë¦¬)
 *                 minLength: 3
 *                 maxLength: 3
 *               isAdmin:
 *                 type: boolean
 *                 description: ê´€ë¦¬ì ì—¬ë¶€
 *                 default: false
 *     responses:
 *       201:
 *         description: ìƒì„±ëœ ì‚¬ìš©ì ì •ë³´
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       400:
 *         description: ì˜ëª»ëœ ìš”ì²­
 *       409:
 *         description: ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¬ìš©ì
 */
router.post('/', userValidation, createUser);

export default router;
</file>

<file path="src/scripts/config/firebase-admin.ts">
import * as admin from 'firebase-admin';
import * as path from 'path';

export const initializeFirebase = (): admin.app.App => {
  if (!admin.apps.length) {
    // í™˜ê²½ë³€ìˆ˜ ìš°ì„ , ì—†ìœ¼ë©´ íŒŒì¼ ê¸°ë°˜ fallback
    if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_PRIVATE_KEY && process.env.FIREBASE_CLIENT_EMAIL) {
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
        }),
        projectId: process.env.FIREBASE_PROJECT_ID
      });
    } else {
      // ë¡œì»¬ ê°œë°œìš© fallback
      try {
        const serviceAccount = require(path.join(__dirname, '../../../hninepeople-firebase-adminsdk-fbsvc-cf8551df6d.json'));
        admin.initializeApp({
          credential: admin.credential.cert(serviceAccount),
          projectId: 'hninepeople'
        });
      } catch (error) {
        console.error('Firebase initialization failed. Please set environment variables or provide service account file.');
        throw error;
      }
    }
  }
  return admin.app();
};

export const getFirestore = (): admin.firestore.Firestore => {
  return admin.firestore();
};

export const verifyIdToken = async (idToken: string): Promise<admin.auth.DecodedIdToken> => {
  try {
    return await admin.auth().verifyIdToken(idToken);
  } catch (error) {
    throw new Error(`Failed to verify Firebase ID token: ${error}`);
  }
};

export { admin };
</file>

<file path="src/scripts/types/firebase-user.ts">
export interface FirebaseUser {
  email: string;
  englishName: string;
  koreanName: string;
  organization: string;
  position: string;
  role: string;
  imageUrl: string;
}

export interface MigrationResult {
  success: boolean;
  userId?: string;
  email: string;
  arId?: string;
  error?: string;
}

export interface MigrationReport {
  total: number;
  success: number;
  failed: number;
  results: MigrationResult[];
  startTime: Date;
  endTime: Date;
}
</file>

<file path="src/scripts/utils/arId-generator.ts">
import { User } from '../../models';

export class ArIdGenerator {
  private static instance: ArIdGenerator;
  private currentId: number = 0;

  private constructor() {}

  public static getInstance(): ArIdGenerator {
    if (!ArIdGenerator.instance) {
      ArIdGenerator.instance = new ArIdGenerator();
    }
    return ArIdGenerator.instance;
  }

  public async initialize(): Promise<void> {
    try {
      // ê¸°ì¡´ DBì—ì„œ ê°€ì¥ í° arId ì°¾ê¸°
      const lastUser = await User.findOne({}, { arId: 1 })
        .sort({ arId: -1 })
        .lean();

      if (lastUser && lastUser.arId) {
        this.currentId = parseInt(lastUser.arId);
      }
      
      console.log(`ArId Generator initialized. Starting from: ${this.currentId}`);
    } catch (error) {
      console.error('Error initializing ArId Generator:', error);
      this.currentId = 0;
    }
  }

  public async generateNextArId(): Promise<string> {
    let nextId = this.currentId + 1;
    let arId = this.formatArId(nextId);
    
    // ì¤‘ë³µ ê²€ì‚¬
    while (await this.isArIdExists(arId)) {
      nextId++;
      arId = this.formatArId(nextId);
    }
    
    this.currentId = nextId;
    return arId;
  }

  private formatArId(id: number): string {
    return id.toString().padStart(3, '0');
  }

  private async isArIdExists(arId: string): Promise<boolean> {
    try {
      const existing = await User.findOne({ arId }).lean();
      return !!existing;
    } catch (error) {
      console.error('Error checking arId existence:', error);
      return false;
    }
  }

  public getCurrentId(): number {
    return this.currentId;
  }
}
</file>

<file path="src/scripts/utils/data-mapper.ts">
import { FirebaseUser } from '../types/firebase-user';
import { IUser } from '../../models';

export class DataMapper {
  public static mapFirebaseUserToUser(firebaseUser: FirebaseUser, arId: string): Partial<IUser> {
    return {
      email: firebaseUser.email,
      nameEn: firebaseUser.englishName,
      nameKr: firebaseUser.koreanName,
      part: firebaseUser.organization,
      role: firebaseUser.role,
      phone: '010-0000-0000',
      arId: arId,
      isNamecardActive: false,
      isAdmin: false
    };
  }

  public static mapFirebaseUserToCustomization(firebaseUser: FirebaseUser, userId: string): any {
    return {
      id: userId, // MongoDB ObjectId will be set
      avatarSelections: new Map(),
      role: firebaseUser.role,
      avatarImgUrl: null // Firebase imageUrl ë¬´ì‹œ, nullë¡œ ì„¤ì •
    };
  }

  public static validateFirebaseUser(data: any): FirebaseUser | null {
    if (!data || typeof data !== 'object') {
      return null;
    }

    const requiredFields = ['email', 'englishName', 'koreanName', 'organization', 'role'];
    for (const field of requiredFields) {
      if (!data[field] || typeof data[field] !== 'string') {
        console.warn(`Missing or invalid field: ${field}`);
        return null;
      }
    }

    return {
      email: data.email,
      englishName: data.englishName,
      koreanName: data.koreanName,
      organization: data.organization,
      position: data.position || '',
      role: data.role,
      imageUrl: data.imageUrl || ''
    };
  }
}
</file>

<file path="src/scripts/create-admin.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { User } from '../models';

// í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
dotenv.config();

const createAdmin = async (): Promise<void> => {
  try {
    console.log('ğŸ”§ Creating admin user...');
    
    // MongoDB ì—°ê²°
    await connectDB();
    console.log('âœ… MongoDB connected');

    // arId 001 ì‚¬ìš©ìë¥¼ ê´€ë¦¬ìë¡œ ë³€ê²½
    const result = await User.findOneAndUpdate(
      { arId: '001' },
      { isAdmin: true },
      { new: true }
    );

    if (result) {
      console.log(`âœ… User ${result.email} (arId: ${result.arId}) is now an admin`);
      console.log(`ğŸ“§ Email: ${result.email}`);
      console.log(`ğŸ‘¤ Name: ${result.nameKr} (${result.nameEn})`);
      console.log(`ğŸ¢ Part: ${result.part}`);
      console.log(`ğŸ‘‘ Admin: ${result.isAdmin}`);
    } else {
      console.log('âŒ User with arId 001 not found');
    }

    console.log('\nğŸ‰ Admin creation completed!');
    process.exit(0);

  } catch (error) {
    console.error('ğŸ’¥ Error creating admin:', error);
    process.exit(1);
  }
};

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
if (require.main === module) {
  createAdmin();
}
</file>

<file path="src/scripts/firebase-migration.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { initializeFirebase, getFirestore } from './config/firebase-admin';
import { ArIdGenerator } from './utils/arId-generator';
import { DataMapper } from './utils/data-mapper';
import { User, UserCustomization } from '../models';
import { FirebaseUser, MigrationResult, MigrationReport } from './types/firebase-user';
import * as admin from 'firebase-admin';

// í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
dotenv.config();

class FirebaseMigration {
  private arIdGenerator: ArIdGenerator;
  private firestore!: admin.firestore.Firestore;

  constructor() {
    this.arIdGenerator = ArIdGenerator.getInstance();
  }

  public async run(): Promise<void> {
    console.log('ğŸ”¥ Firebase to MongoDB Migration Started');
    console.log('==========================================');

    const startTime = new Date();
    const report: MigrationReport = {
      total: 0,
      success: 0,
      failed: 0,
      results: [],
      startTime,
      endTime: new Date()
    };

    try {
      // 1. ì—°ê²° ì´ˆê¸°í™”
      await this.initializeConnections();

      // 2. Firebaseì—ì„œ ì‚¬ìš©ì ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      const firebaseUsers = await this.fetchFirebaseUsers();
      report.total = firebaseUsers.length;

      console.log(`ğŸ“Š Found ${firebaseUsers.length} users in Firebase`);

      // 3. ê° ì‚¬ìš©ì ë§ˆì´ê·¸ë ˆì´ì…˜
      for (const firebaseUser of firebaseUsers) {
        const result = await this.migrateUser(firebaseUser);
        report.results.push(result);
        
        if (result.success) {
          report.success++;
          console.log(`âœ… ${result.email} â†’ User ID: ${result.userId}, arId: ${result.arId}`);
        } else {
          report.failed++;
          console.log(`âŒ ${result.email} â†’ Error: ${result.error}`);
        }
      }

      report.endTime = new Date();
      this.printReport(report);

    } catch (error) {
      console.error('ğŸ’¥ Migration failed:', error);
      process.exit(1);
    }
  }

  private async initializeConnections(): Promise<void> {
    console.log('ğŸ”Œ Initializing connections...');
    
    // MongoDB ì—°ê²°
    await connectDB();
    console.log('âœ… MongoDB connected');

    // Firebase ì´ˆê¸°í™”
    initializeFirebase();
    this.firestore = getFirestore();
    console.log('âœ… Firebase initialized');

    // ArId Generator ì´ˆê¸°í™”
    await this.arIdGenerator.initialize();
    console.log('âœ… ArId Generator initialized');
  }

  private async fetchFirebaseUsers(): Promise<FirebaseUser[]> {
    console.log('ğŸ“¥ Fetching users from Firebase...');
    
    const snapshot = await this.firestore.collection('people').get();
    const users: FirebaseUser[] = [];

    snapshot.forEach((doc: admin.firestore.QueryDocumentSnapshot) => {
      const data = doc.data();
      const user = DataMapper.validateFirebaseUser(data);
      
      if (user) {
        users.push(user);
      } else {
        console.warn(`âš ï¸ Invalid user data for document: ${doc.id}`);
      }
    });

    return users;
  }

  private async migrateUser(firebaseUser: FirebaseUser): Promise<MigrationResult> {
    try {
      // 1. ì´ë©”ì¼ ì¤‘ë³µ ê²€ì‚¬
      const existingUser = await User.findOne({ email: firebaseUser.email });
      if (existingUser) {
        return {
          success: false,
          email: firebaseUser.email,
          error: 'Email already exists'
        };
      }

      // 2. arId ìƒì„±
      const arId = await this.arIdGenerator.generateNextArId();

      // 3. User ìƒì„±
      const userData = DataMapper.mapFirebaseUserToUser(firebaseUser, arId);
      const user = new User(userData);
      await user.save();

      // 4. UserCustomization ìƒì„±
      const customizationData = DataMapper.mapFirebaseUserToCustomization(firebaseUser, (user._id as any).toString());
      const customization = new UserCustomization(customizationData);
      await customization.save();

      return {
        success: true,
        userId: (user._id as any).toString(),
        email: firebaseUser.email,
        arId: arId
      };

    } catch (error) {
      return {
        success: false,
        email: firebaseUser.email,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private printReport(report: MigrationReport): void {
    const duration = report.endTime.getTime() - report.startTime.getTime();
    
    console.log('\nğŸ¯ Migration Report');
    console.log('==================');
    console.log(`ğŸ“Š Total: ${report.total}`);
    console.log(`âœ… Success: ${report.success}`);
    console.log(`âŒ Failed: ${report.failed}`);
    console.log(`â±ï¸ Duration: ${duration}ms`);
    console.log(`ğŸš€ Success Rate: ${((report.success / report.total) * 100).toFixed(1)}%`);
    
    if (report.failed > 0) {
      console.log('\nâŒ Failed Users:');
      report.results.filter(r => !r.success).forEach(result => {
        console.log(`  - ${result.email}: ${result.error}`);
      });
    }
    
    console.log('\nğŸ‰ Migration completed!');
  }
}

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
if (require.main === module) {
  const migration = new FirebaseMigration();
  migration.run().catch(error => {
    console.error('ğŸ’¥ Migration script error:', error);
    process.exit(1);
  });
}
</file>

<file path="src/scripts/update-admin-permissions.ts">
import dotenv from 'dotenv';
import { connectDB } from '../config/database';
import { User } from '../models';

// í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
dotenv.config();

interface AdminUpdate {
  email: string;
  isAdmin: boolean;
  action: 'remove' | 'add';
}

const updateAdminPermissions = async (): Promise<void> => {
  try {
    console.log('ğŸ”§ Starting admin permission updates...');
    
    // MongoDB ì—°ê²°
    await connectDB();
    console.log('âœ… MongoDB connected');

    // ì—…ë°ì´íŠ¸í•  ì‚¬ìš©ì ëª©ë¡ ì •ì˜
    const adminUpdates: AdminUpdate[] = [
      {
        email: 'hyeonseo.ahn@hnine.com',
        isAdmin: false,
        action: 'remove'
      },
      {
        email: 'beomseok.jang@hnine.com',
        isAdmin: true,
        action: 'add'
      },
      {
        email: 'kyungmin.woo@hnine.com',
        isAdmin: true,
        action: 'add'
      },
      {
        email: 'daekyo.jeong@hnine.com',
        isAdmin: true,
        action: 'add'
      }
    ];

    console.log(`ğŸ“ Processing ${adminUpdates.length} user permission updates...\n`);

    let successCount = 0;
    let failCount = 0;

    // ê° ì‚¬ìš©ìì— ëŒ€í•´ ê¶Œí•œ ì—…ë°ì´íŠ¸ ìˆ˜í–‰
    for (const update of adminUpdates) {
      try {
        console.log(`ğŸ”„ ${update.action === 'add' ? 'Adding' : 'Removing'} admin permission for: ${update.email}`);
        
        const result = await User.findOneAndUpdate(
          { email: update.email },
          { isAdmin: update.isAdmin },
          { new: true }
        );

        if (result) {
          successCount++;
          const actionText = update.action === 'add' ? 'granted' : 'removed';
          console.log(`âœ… Admin permission ${actionText} for ${result.email}`);
          console.log(`   ğŸ“§ Email: ${result.email}`);
          console.log(`   ğŸ‘¤ Name: ${result.nameKr}${result.nameEn ? ` (${result.nameEn})` : ''}`);
          console.log(`   ğŸ¢ Part: ${result.part}`);
          console.log(`   ğŸ‘‘ Admin: ${result.isAdmin}`);
          console.log(`   ğŸ†” AR ID: ${result.arId}\n`);
        } else {
          failCount++;
          console.log(`âŒ User not found: ${update.email}\n`);
        }
      } catch (error) {
        failCount++;
        console.error(`ğŸ’¥ Error updating ${update.email}:`, error);
        console.log('');
      }
    }

    // ê²°ê³¼ ìš”ì•½
    console.log('ğŸ“Š Update Summary:');
    console.log(`âœ… Successfully updated: ${successCount} users`);
    console.log(`âŒ Failed updates: ${failCount} users`);
    
    if (failCount === 0) {
      console.log('\nğŸ‰ All admin permission updates completed successfully!');
      process.exit(0);
    } else {
      console.log('\nâš ï¸  Some updates failed. Please check the logs above.');
      process.exit(1);
    }

  } catch (error) {
    console.error('ğŸ’¥ Error during admin permission updates:', error);
    process.exit(1);
  }
};

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
if (require.main === module) {
  updateAdminPermissions();
}

export { updateAdminPermissions };
</file>

<file path="src/utils/paletteImageProcessor.ts">
// import sharp from 'sharp'; // Temporarily commented out due to platform issues
import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';

export class PaletteImageProcessor {
  private static PALETTE_SIZE = 128;
  private static PALETTE_UPLOAD_DIR = 'uploads/palettes';

  static async ensurePaletteDirectoryExists(): Promise<void> {
    try {
      await fs.access(this.PALETTE_UPLOAD_DIR);
    } catch {
      await fs.mkdir(this.PALETTE_UPLOAD_DIR, { recursive: true });
    }
  }

  static async processPaletteImage(inputPath: string, originalFilename?: string): Promise<{ paletteImageUrl: string, filename: string }> {
    // inputPathê°€ undefinedì¸ ê²½ìš° ì²˜ë¦¬
    if (!inputPath) {
      throw new Error('Input path is required for palette image processing');
    }

    await this.ensurePaletteDirectoryExists();

    const fileExtension = path.extname(originalFilename || inputPath) || '.jpg';
    const filename = `palette_${uuidv4()}${fileExtension}`;
    const outputPath = path.join(this.PALETTE_UPLOAD_DIR, filename);

    try {
      // TEMPORARY WORKAROUND: Just copy the file for now until Sharp is fixed
      await fs.copyFile(inputPath, outputPath);
      
      console.log('âš ï¸  NOTICE: Using temporary palette image processing (Sharp not available)');

      // ì›ë³¸ íŒŒì¼ ì‚­ì œ (ì„ì‹œ ì—…ë¡œë“œ íŒŒì¼ì¸ ê²½ìš°)
      if (inputPath.includes('uploads/') && !inputPath.includes('palettes/')) {
        try {
          await fs.unlink(inputPath);
        } catch (error) {
          console.warn('Failed to delete temporary file:', inputPath);
        }
      }

      return {
        paletteImageUrl: `/${this.PALETTE_UPLOAD_DIR}/${filename}`,
        filename
      };
    } catch (error) {
      console.error('Error processing palette image:', error);
      throw new Error('Failed to process palette image');
    }
  }

  static async deletePaletteImage(paletteImageUrl: string): Promise<void> {
    if (!paletteImageUrl) return;

    try {
      const filename = path.basename(paletteImageUrl);
      const filePath = path.join(this.PALETTE_UPLOAD_DIR, filename);
      
      // íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
      try {
        await fs.access(filePath);
        await fs.unlink(filePath);
        console.log(`Palette image deleted: ${filePath}`);
      } catch (accessError: any) {
        if (accessError.code === 'ENOENT') {
          console.log(`Palette image already deleted or not found: ${filePath}`);
        } else {
          throw accessError;
        }
      }
    } catch (error) {
      console.warn(`Failed to delete palette image: ${paletteImageUrl}`, error);
    }
  }

  static getFilePathFromUrl(url: string): string {
    if (!url) return '';
    const filename = path.basename(url);
    return path.join(this.PALETTE_UPLOAD_DIR, filename);
  }
}
</file>

<file path="src/utils/thumbnailGenerator.ts">
// import sharp from 'sharp';
import path from 'path';
import fs from 'fs/promises';
import { uploadToFirebase, getBucket } from '../config/firebase-storage';
import { Readable } from 'stream';

export interface ThumbnailResult {
  thumbnailPath: string;
  thumbnailUrl: string;
  source: 'user' | 'auto';
}

export class ThumbnailGenerator {
  private static readonly THUMBNAIL_SIZE = 300;
  private static readonly THUMBNAIL_DIR = 'uploads/thumbnails';

  /**
   * Firebase Storage URLì¸ì§€ í™•ì¸
   */
  private static isFirebaseUrl(url: string): boolean {
    return url.startsWith('https://storage.googleapis.com/') || url.startsWith('gs://');
  }

  /**
   * ì´ë¯¸ì§€ë¥¼ ë¡œì»¬ ì„ì‹œ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ (Firebase Storage URLì¸ ê²½ìš°)
   */
  private static async downloadImageToTemp(imageUrl: string): Promise<string> {
    if (!this.isFirebaseUrl(imageUrl)) {
      // ë¡œì»¬ íŒŒì¼ ê²½ë¡œì¸ ê²½ìš° ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
      if (imageUrl.startsWith('/')) {
        // /uploads/... í˜•íƒœì˜ ê²½ìš°
        return path.join(process.cwd(), imageUrl.slice(1));
      } else if (path.isAbsolute(imageUrl)) {
        // ì´ë¯¸ ì ˆëŒ€ ê²½ë¡œì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
        return imageUrl;
      } else {
        // ìƒëŒ€ ê²½ë¡œì¸ ê²½ìš° í˜„ì¬ ë””ë ‰í† ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜
        return path.join(process.cwd(), imageUrl);
      }
    }

    // Firebase Storageì—ì„œ ë‹¤ìš´ë¡œë“œ
    const tempFilePath = path.join(process.cwd(), 'temp', `temp_${Date.now()}_${Math.random()}.jpg`);
    
    try {
      // temp ë””ë ‰í† ë¦¬ ìƒì„±
      await fs.mkdir(path.dirname(tempFilePath), { recursive: true });
      
      // Firebase Storage URLì—ì„œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ (ê°œì„ ëœ íŒŒì‹±)
      const url = new URL(imageUrl);
      let filePath = '';
      
      // ë‹¤ì–‘í•œ Firebase Storage URL í˜•ì‹ ì§€ì›
      if (url.hostname.includes('firebasestorage.app') || url.hostname.includes('googleapis.com')) {
        // ìƒˆë¡œìš´ í˜•ì‹: https://storage.googleapis.com/bucket-name/uploads/filename
        if (url.pathname.includes('/o/')) {
          filePath = decodeURIComponent(url.pathname.split('/o/')[1]?.split('?')[0] || '');
        } else {
          // ì§ì ‘ ê²½ë¡œ í˜•ì‹: https://storage.googleapis.com/bucket-name/uploads/filename
          const pathParts = url.pathname.split('/');
          if (pathParts.length >= 3) {
            filePath = pathParts.slice(2).join('/'); // bucket-name ì´í›„ì˜ ê²½ë¡œ
          }
        }
      }
      
      if (!filePath) {
        console.error('âŒ Firebase Storage URL íŒŒì‹± ì‹¤íŒ¨:', imageUrl);
        console.error('URL êµ¬ì¡°:', { hostname: url.hostname, pathname: url.pathname });
        throw new Error('Invalid Firebase Storage URL format');
      }
      
      console.log('âœ… íŒŒì‹±ëœ Firebase íŒŒì¼ ê²½ë¡œ:', filePath);

      const bucket = getBucket();
      const file = bucket.file(filePath);
      
      // íŒŒì¼ ë‹¤ìš´ë¡œë“œ
      const [fileBuffer] = await file.download();
      await fs.writeFile(tempFilePath, fileBuffer);
      
      return tempFilePath;
    } catch (error) {
      console.error('Error downloading image from Firebase:', error);
      throw new Error(`Failed to download image: ${error}`);
    }
  }

  /**
   * ì¸ë„¤ì¼ ì´ë¯¸ì§€ë¥¼ Firebase Storageì— ì—…ë¡œë“œ
   */
  private static async uploadThumbnailToFirebase(localThumbnailPath: string, filename: string): Promise<string> {
    try {
      const thumbnailBuffer = await fs.readFile(localThumbnailPath);
      
      // Express.Multer.File í˜•íƒœë¡œ ë³€í™˜
      const uploadFile: Express.Multer.File = {
        fieldname: 'thumbnail',
        originalname: filename,
        encoding: '7bit',
        mimetype: 'image/jpeg',
        buffer: thumbnailBuffer,
        size: thumbnailBuffer.length,
        destination: '',
        filename: filename,
        path: localThumbnailPath,
        stream: null as any,
      };

      // Firebase Storageì— ì—…ë¡œë“œ
      const result = await uploadToFirebase(uploadFile, 'uploads/thumbnails/');
      
      // ì„ì‹œ íŒŒì¼ ì‚­ì œ
      try {
        await fs.unlink(localThumbnailPath);
      } catch (error) {
        console.warn('Failed to delete temporary thumbnail file:', error);
      }
      
      return result.url;
    } catch (error) {
      console.error('Error uploading thumbnail to Firebase:', error);
      throw new Error(`Failed to upload thumbnail: ${error}`);
    }
  }

  static async ensureThumbnailDir(): Promise<void> {
    try {
      await fs.access(this.THUMBNAIL_DIR);
    } catch {
      await fs.mkdir(this.THUMBNAIL_DIR, { recursive: true });
    }
  }

  /**
   * ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ ì¸ë„¤ì¼ì„ ìë™ ìƒì„±í•©ë‹ˆë‹¤
   */
  static async generateThumbnail(
    originalImagePath: string,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    // originalImagePathê°€ undefinedì¸ ê²½ìš° ë°©ì–´
    if (!originalImagePath) {
      throw new Error('Original image path is required for thumbnail generation');
    }
    
    const originalName = filename || path.basename(originalImagePath, path.extname(originalImagePath));
    const thumbnailFilename = `thumb_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    let tempImagePath: string | null = null;

    try {
      console.log(`ğŸ” ì¸ë„¤ì¼ ìƒì„± ì‹œë„:`, { originalImagePath, thumbnailFilename });
      
      // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ (Firebase Storage URLì¸ ê²½ìš°)
      const localImagePath = await this.downloadImageToTemp(originalImagePath);
      if (this.isFirebaseUrl(originalImagePath)) {
        tempImagePath = localImagePath; // ì„ì‹œ íŒŒì¼ì´ë¯€ë¡œ ë‚˜ì¤‘ì— ì‚­ì œ
      }
      
      // ì›ë³¸ íŒŒì¼ ì¡´ì¬ í™•ì¸
      try {
        await fs.access(localImagePath);
      } catch (error) {
        throw new Error(`Original image not found: ${localImagePath}`);
      }
      
      // Temporary: ì›ë³¸ íŒŒì¼ì„ ë³µì‚¬í•´ì„œ ì¸ë„¤ì¼ë¡œ ì‚¬ìš© (Sharp ì—†ì´)
      await fs.copyFile(localImagePath, localThumbnailPath);
      console.log(`âœ… ë¡œì»¬ ì¸ë„¤ì¼ ìƒì„± ì™„ë£Œ:`, localThumbnailPath);
      
      // Firebase Storageì— ì—…ë¡œë“œ
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`âœ… Firebase ì¸ë„¤ì¼ ì—…ë¡œë“œ ì™„ë£Œ:`, firebaseUrl);
      
      // ì„ì‹œ ì´ë¯¸ì§€ íŒŒì¼ ì‚­ì œ
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch (error) {
          console.warn('Failed to delete temporary image file:', error);
        }
      }
      
      return {
        thumbnailPath: localThumbnailPath, // ë¡œì»¬ ê²½ë¡œ (í˜¸í™˜ì„± ìœ ì§€)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'auto'
      };
    } catch (error) {
      console.error(`âŒ ì¸ë„¤ì¼ ìƒì„± ì‹¤íŒ¨:`, error);
      
      // ì„ì‹œ íŒŒì¼ë“¤ ì •ë¦¬
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch {}
      }
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to generate thumbnail: ${error}`);
    }
  }

  /**
   * ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€ì˜ ì²« ë²ˆì§¸ í”„ë ˆì„ì—ì„œ ì¸ë„¤ì¼ì„ ìƒì„±í•©ë‹ˆë‹¤
   */
  static async generateThumbnailFromSprite(
    spriteImagePath: string,
    columns: number = 16,
    rows?: number,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    // spriteImagePathê°€ undefinedì¸ ê²½ìš° ë°©ì–´
    if (!spriteImagePath) {
      throw new Error('Sprite image path is required for thumbnail generation');
    }

    const originalName = filename || path.basename(spriteImagePath, path.extname(spriteImagePath));
    const thumbnailFilename = `thumb_sprite_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    let tempImagePath: string | null = null;

    try {
      console.log(`ğŸ” ìŠ¤í”„ë¼ì´íŠ¸ ì¸ë„¤ì¼ ìƒì„± ì‹œë„:`, { spriteImagePath, thumbnailFilename });
      
      // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ (Firebase Storage URLì¸ ê²½ìš°)
      const localImagePath = await this.downloadImageToTemp(spriteImagePath);
      if (this.isFirebaseUrl(spriteImagePath)) {
        tempImagePath = localImagePath; // ì„ì‹œ íŒŒì¼ì´ë¯€ë¡œ ë‚˜ì¤‘ì— ì‚­ì œ
      }

      // ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      // const { width, height } = await sharp(localImagePath).metadata();
      const width = 800, height = 600; // Temporary values
      
      if (!width || !height) {
        throw new Error('Cannot get sprite image dimensions');
      }

      // ì²« ë²ˆì§¸ í”„ë ˆì„ í¬ê¸° ê³„ì‚°
      const frameWidth = Math.floor(width / columns);
      let frameHeight: number;
      
      if (rows) {
        // í–‰ ìˆ˜ê°€ ì§€ì •ëœ ê²½ìš°
        frameHeight = Math.floor(height / rows);
      } else {
        // í–‰ ìˆ˜ê°€ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš°, ì •ì‚¬ê°í˜• í”„ë ˆì„ì´ë¼ê³  ê°€ì •
        frameHeight = frameWidth;
      }

      console.log(`Sprite info: ${width}x${height}, columns: ${columns}, rows: ${rows || 'auto'}`);
      console.log(`Frame size: ${frameWidth}x${frameHeight}`);

      // Temporary: ì›ë³¸ íŒŒì¼ì„ ë³µì‚¬í•´ì„œ ì¸ë„¤ì¼ë¡œ ì‚¬ìš© (Sharp ì—†ì´)
      // ì‹¤ì œë¡œëŠ” Sharpë¥¼ ì‚¬ìš©í•´ì„œ ì²« ë²ˆì§¸ í”„ë ˆì„ë§Œ ì¶”ì¶œí•´ì•¼ í•¨
      await fs.copyFile(localImagePath, localThumbnailPath);
      console.log(`âœ… ë¡œì»¬ ìŠ¤í”„ë¼ì´íŠ¸ ì¸ë„¤ì¼ ìƒì„± ì™„ë£Œ:`, localThumbnailPath);

      // Firebase Storageì— ì—…ë¡œë“œ
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`âœ… Firebase ìŠ¤í”„ë¼ì´íŠ¸ ì¸ë„¤ì¼ ì—…ë¡œë“œ ì™„ë£Œ:`, firebaseUrl);

      // ì„ì‹œ ì´ë¯¸ì§€ íŒŒì¼ ì‚­ì œ
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch (error) {
          console.warn('Failed to delete temporary sprite image file:', error);
        }
      }

      return {
        thumbnailPath: localThumbnailPath, // ë¡œì»¬ ê²½ë¡œ (í˜¸í™˜ì„± ìœ ì§€)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'auto'
      };
    } catch (error) {
      console.error(`âŒ ìŠ¤í”„ë¼ì´íŠ¸ ì¸ë„¤ì¼ ìƒì„± ì‹¤íŒ¨:`, error);
      
      // ì„ì‹œ íŒŒì¼ë“¤ ì •ë¦¬
      if (tempImagePath) {
        try {
          await fs.unlink(tempImagePath);
        } catch {}
      }
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to generate thumbnail from sprite: ${error}`);
    }
  }

  /**
   * ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ì¸ë„¤ì¼ ì´ë¯¸ì§€ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤
   */
  static async processUserThumbnail(
    thumbnailImagePath: string,
    filename?: string
  ): Promise<ThumbnailResult> {
    await this.ensureThumbnailDir();

    const originalName = filename || path.basename(thumbnailImagePath, path.extname(thumbnailImagePath));
    const thumbnailFilename = `thumb_user_${originalName}_${Date.now()}.jpg`;
    const localThumbnailPath = path.join(this.THUMBNAIL_DIR, thumbnailFilename);

    try {
      console.log(`ğŸ” ì‚¬ìš©ì ì¸ë„¤ì¼ ì²˜ë¦¬ ì‹œë„:`, { thumbnailImagePath, thumbnailFilename });
      
      // ì›ë³¸ íŒŒì¼ ì¡´ì¬ í™•ì¸
      try {
        await fs.access(thumbnailImagePath);
      } catch (error) {
        throw new Error(`Thumbnail image not found: ${thumbnailImagePath}`);
      }

      // Temporary: ì›ë³¸ íŒŒì¼ì„ ë³µì‚¬í•´ì„œ ì¸ë„¤ì¼ë¡œ ì‚¬ìš© (Sharp ì—†ì´)
      // ì‹¤ì œë¡œëŠ” Sharpë¥¼ ì‚¬ìš©í•´ì„œ 300x300ìœ¼ë¡œ ë¦¬ì‚¬ì´ì§•í•´ì•¼ í•¨
      await fs.copyFile(thumbnailImagePath, localThumbnailPath);
      console.log(`âœ… ë¡œì»¬ ì‚¬ìš©ì ì¸ë„¤ì¼ ìƒì„± ì™„ë£Œ:`, localThumbnailPath);

      // Firebase Storageì— ì—…ë¡œë“œ
      const firebaseUrl = await this.uploadThumbnailToFirebase(localThumbnailPath, thumbnailFilename);
      console.log(`âœ… Firebase ì‚¬ìš©ì ì¸ë„¤ì¼ ì—…ë¡œë“œ ì™„ë£Œ:`, firebaseUrl);

      return {
        thumbnailPath: localThumbnailPath, // ë¡œì»¬ ê²½ë¡œ (í˜¸í™˜ì„± ìœ ì§€)
        thumbnailUrl: firebaseUrl, // Firebase Storage URL
        source: 'user'
      };
    } catch (error) {
      console.error(`âŒ ì‚¬ìš©ì ì¸ë„¤ì¼ ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
      
      // ì„ì‹œ íŒŒì¼ ì •ë¦¬
      try {
        await fs.unlink(localThumbnailPath);
      } catch {}
      
      throw new Error(`Failed to process user thumbnail: ${error}`);
    }
  }

  /**
   * ì¸ë„¤ì¼ íŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤
   */
  static async deleteThumbnail(thumbnailPath: string): Promise<void> {
    try {
      await fs.unlink(thumbnailPath);
    } catch (error) {
      console.warn(`Failed to delete thumbnail: ${thumbnailPath}`, error);
    }
  }

  /**
   * ì´ë¯¸ì§€ íŒŒì¼ì´ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤
   */
  static async validateImage(imagePath: string): Promise<boolean> {
    try {
      // Temporary: Skip sharp validation
      // const metadata = await sharp(imagePath).metadata();
      // return !!(metadata.width && metadata.height);
      return true; // Always return true for development
    } catch {
      return false;
    }
  }

  /**
   * ì¸ë„¤ì¼ í¬ê¸°ê°€ ì˜¬ë°”ë¥¸ì§€ ê²€ì¦í•©ë‹ˆë‹¤
   */
  static async validateThumbnailSize(imagePath: string): Promise<boolean> {
    try {
      // Temporary: Skip sharp validation
      // const { width, height } = await sharp(imagePath).metadata();
      // return width === this.THUMBNAIL_SIZE && height === this.THUMBNAIL_SIZE;
      return true; // Always return true for development
    } catch {
      return false;
    }
  }
}
</file>

<file path="src/index.ts">
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { connectDB } from './config/database';
import { corsOptions } from './config/cors';
import { setupSwagger } from './config/swagger';
import path from 'path';
import https from 'https';
import fs from 'fs';
import os from 'os';

import userRoutes from './routes/userRoutes';
import avatarRoutes from './routes/avatarRoutes';
import itemRoutes from './routes/itemRoutes';
import charactersRoutes from './routes/charactersRoutes';
import adminRoutes from './routes/adminRoutes';
import adminAvatarRoutes from './routes/adminAvatarRoutes';
import adminItemRoutes from './routes/adminItemRoutes';
import authRoutes from './routes/authRoutes';
import firebaseAuthRoutes from './routes/firebaseAuthRoutes';

// í™˜ê²½ì— ë”°ë¼ ë‹¤ë¥¸ env íŒŒì¼ ë¡œë”©
if (process.env.NODE_ENV === 'production') {
  dotenv.config(); // ë°°í¬ í™˜ê²½ì—ì„œëŠ” ê¸°ë³¸ .env ì‚¬ìš©
} else {
  dotenv.config({ path: '.env.local' }); // ê°œë°œ í™˜ê²½ì—ì„œëŠ” .env.local ì‚¬ìš©
}

const app = express();
const PORT = parseInt(process.env['PORT'] || '3000', 10);
const HTTPS_PORT = parseInt(process.env['HTTPS_PORT'] || '3443', 10);
const HOST = process.env['HOST'] || '0.0.0.0';
const ENABLE_HTTPS = process.env['ENABLE_HTTPS'] === 'true' && process.env.NODE_ENV !== 'production';

// ë¡œì»¬ IP ì£¼ì†Œ ì°¾ê¸°
function getLocalIpAddress(): string {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const networkInterface of interfaces[name]!) {
      const { address, family, internal } = networkInterface;
      if (family === 'IPv4' && !internal) {
        return address;
      }
    }
  }
  return '127.0.0.1';
}

app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use('/uploads', express.static('uploads'));
app.use('/uploads/thumbnails', express.static('uploads/thumbnails'));
app.use('/uploads/palettes', express.static('uploads/palettes'));

// ì •ì  íŒŒì¼ ì„œë¹™ (í…ŒìŠ¤íŠ¸ í˜ì´ì§€ìš©)
app.use('/public', express.static('public'));

// í…ŒìŠ¤íŠ¸ í˜ì´ì§€ ì§ì ‘ ì ‘ê·¼ ë¼ìš°íŠ¸
app.get('/test/avatar', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/avatar_new.html'));
});


app.get('/test/item', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/item.html'));
});

app.get('/test/user', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/user.html'));
});

app.get('/test/login', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/login.html'));
});

app.get('/test/customize', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/customize.html'));
});

app.get('/test/cors-test', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/cors-test.html'));
});

app.get('/test/customize/', (_req, res) => {
  res.sendFile(path.join(__dirname, '../public/test/customize.html'));
});

connectDB();

setupSwagger(app);

// ë‹¨ìˆœ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì—”ë“œí¬ì¸íŠ¸ (Firebase Storage ì‚¬ìš©)
import { upload, uploadToFirebaseStorage } from './middleware/upload';
app.post('/api/upload', upload.single('file'), async (req, res): Promise<void> => {
  if (!req.file) {
    res.status(400).json({ message: 'No file uploaded' });
    return;
  }
  
  try {
    const result = await uploadToFirebaseStorage(req.file, 'uploads/');
    res.json({ 
      url: result.url,
      filename: result.path 
    });
  } catch (error) {
    console.error('Upload failed:', error);
    res.status(500).json({ message: 'Upload failed', error: (error as Error).message });
  }
});

// Health ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ (CloudTypeìš©)
app.get(['/health', '/api/health', '/health2'], (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString(),
    server: 'AR Namecard API',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    cors: 'enabled',
    origin: req.headers.origin || 'no-origin',
    mongodb: 'connected',
    firebase: 'configured'
  });
});

app.use('/api/auth', authRoutes);
app.use('/api/auth/firebase', firebaseAuthRoutes);
app.use('/api/users', userRoutes);
app.use('/api/avatars', avatarRoutes);
app.use('/api/stickers', itemRoutes);
app.use('/api/characters', charactersRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/admin/characters', adminAvatarRoutes);
app.use('/api/admin/stickers', adminItemRoutes);

// ë£¨íŠ¸ ê²½ë¡œ ì ‘ê·¼ ì‹œ API ì •ë³´ ì œê³µ
app.get('/', (_req, res) => {
  res.json({
    message: 'AR Namecard API Server',
    version: '1.0.0',
    status: 'running',
    endpoints: {
      health: '/health',
      api: {
        auth: '/api/auth',
        users: '/api/users',
        avatars: '/api/avatars',
        stickers: '/api/stickers',
        characters: '/api/characters',
        admin: '/api/admin'
      },
      test: {
        avatar: '/test/avatar',
        item: '/test/item',
        user: '/test/user',
        login: '/test/login',
        customize: '/test/customize'
      },
      docs: '/api-docs'
    }
  });
});

app.use('*', (_req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// HTTP ì„œë²„ ì‹œì‘
app.listen(PORT, HOST, () => {
  const localIp = getLocalIpAddress();
  console.log(`ğŸš€ HTTP Server is running on:`);
  console.log(`   - Local:    http://localhost:${PORT}`);
  console.log(`   - Network:  http://${localIp}:${PORT}`);
  
  if (ENABLE_HTTPS) {
    console.log(`   - HTTPS:    https://localhost:${HTTPS_PORT}`);
    console.log(`   - Network:  https://${localIp}:${HTTPS_PORT}`);
  }
});

// HTTPS ì„œë²„ ì‹œì‘ (í™œì„±í™”ëœ ê²½ìš°)
if (ENABLE_HTTPS) {
  const keyPath = process.env['SSL_KEY_PATH'] || './ssl/server.key';
  const certPath = process.env['SSL_CERT_PATH'] || './ssl/server.crt';
  
  try {
    const privateKey = fs.readFileSync(keyPath, 'utf8');
    const certificate = fs.readFileSync(certPath, 'utf8');
    
    const httpsServer = https.createServer({
      key: privateKey,
      cert: certificate
    }, app);
    
    httpsServer.listen(HTTPS_PORT, HOST, () => {
      console.log(`ğŸ” HTTPS Server is running on port ${HTTPS_PORT}`);
      console.log(`ğŸ“± 8th Wall ì ‘ê·¼ ê°€ëŠ¥!`);
    });
  } catch (error) {
    console.error('âŒ HTTPS ì„œë²„ ì‹œì‘ ì‹¤íŒ¨:', error);
    console.log('ğŸ’¡ SSL ì¸ì¦ì„œ ìƒì„±: node scripts/generate-ssl-cert.js');
  }
}
</file>

<file path="ssl/server.crt">
-----BEGIN CERTIFICATE-----
MIIEjzCCAvegAwIBAgIRAL2IEOQlKBqv+/I+vjie5kQwDQYJKoZIhvcNAQELBQAw
gaExHjAcBgNVBAoTFW1rY2VydCBkZXZlbG9wbWVudCBDQTE7MDkGA1UECwwyamFu
Z2Jlb21zZW9rQEphbmctTWFjQm9va1Byby5sb2NhbCAoSmFuZyBCZW9tc2Vvaykx
QjBABgNVBAMMOW1rY2VydCBqYW5nYmVvbXNlb2tASmFuZy1NYWNCb29rUHJvLmxv
Y2FsIChKYW5nIEJlb21zZW9rKTAeFw0yNTA3MTgxMDQxNTVaFw0yNzEwMTgxMDQx
NTRaMGYxJzAlBgNVBAoTHm1rY2VydCBkZXZlbG9wbWVudCBjZXJ0aWZpY2F0ZTE7
MDkGA1UECwwyamFuZ2Jlb21zZW9rQEphbmctTWFjQm9va1Byby5sb2NhbCAoSmFu
ZyBCZW9tc2VvaykwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCy3O6t
VZMS3eBURm9iLvpY5Q+qq2c39o3bPGkwBQRT3SemoUdrUprZ3J+QVfGBi1OIFNvN
bXBMzh3i9FwAEve+vrNhuwlHh/vBaNutEEerrJ7UAp4h0QvMMsJzz1W/KT/LWBeo
ZqUVZcWF//BPqBSLDEt1V7R3DwFoQW/SgWk2oFzrwO1M+xqJJQBCVEIp4mk7+u5l
skYO9TsOlLMTNFoYuLbSnrDWKk0sqIgtHqV0ipngRZnp8cOK0R14kWFSUoyT9sY8
tKYvI9NHPp+q0ZDqb8+shNZcaSjad3DYmjS9Of0Y+GyKjDRojeiLnaLmOq3q+svf
MzC19p1msopqpa4tAgMBAAGjfDB6MA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAK
BggrBgEFBQcDATAfBgNVHSMEGDAWgBQKmNpkox2gG1RnWq2Xk0JpDdGlZzAyBgNV
HREEKzApgglsb2NhbGhvc3SHBH8AAAGHEAAAAAAAAAAAAAAAAAAAAAGHBMCoAhQw
DQYJKoZIhvcNAQELBQADggGBAAZHvURQqV5KxP+05Liq0MshitsizOK2gKH1AjfZ
egnPyPIajfd6AsuoMS83RsN/ikzyDvm6ZMHKz3STy8xM7iLztLFxjgPh52dFdheG
IluFn8E5BZabr8hd3pQnJQ/41WUrvvoSwN2tYbUa7B5CKzkjZ36BCGUvv0zmPhpG
eTQy2LW4/wldn0ctobYPXilnpvUDD5FG3APY+nH3qYUltmZrRMud8c91hBr0NEF0
tiYj/rIxn8oBU6pnKc5DPlTKbSaG5erUsR3Ayv2CqC1691iFqtz3AMBuDfiZJqvN
OmK5Fz5Ubh/8z3Ry3EF4k4FffbxpgacZKLWzBe95cdLXpp+Yo6ZG97l9f/CdlpZz
z/rEbPtr9oz9BDtjCnPNpffWbK/ZGOUNz2EApVLSPyqlgs2ae6nQbTXR4vCPL03z
eEfVsRKLbFAI47Eu3XynjjOqftD48s93NbUQWWkbVrImuwwID94hCQvw0TSPKPhN
F2VLo1i7dAOL/+1RZ8als/Y8wg==
-----END CERTIFICATE-----
</file>

<file path="ssl/server.crt.backup">
-----BEGIN CERTIFICATE-----
MIIDyjCCArKgAwIBAgIUVUcGe5bFx0iUQLk4fNbSzH03ov0wDQYJKoZIhvcNAQEL
BQAwWzELMAkGA1UEBhMCS1IxDjAMBgNVBAgMBVNlb3VsMQ4wDAYDVQQHDAVTZW91
bDEYMBYGA1UECgwPQVIgTmFtZWNhcmQgRGV2MRIwEAYDVQQDDAlsb2NhbGhvc3Qw
HhcNMjUwNzE4MDkxNjUxWhcNMjYwNzE4MDkxNjUxWjBbMQswCQYDVQQGEwJLUjEO
MAwGA1UECAwFU2VvdWwxDjAMBgNVBAcMBVNlb3VsMRgwFgYDVQQKDA9BUiBOYW1l
Y2FyZCBEZXYxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAJltBd0DPtIXYsdph1akEQVU7z8gaO1S5MnWcLsfyVZUfz9Z
ivrP3zMoeSkwfg+SaTlPTqyoGh5sn8ds9ut+jFVB8NMD7Dhb0tKInaO5UetuxEFC
wKyaAXiwImeZJThhF0LMil0aGgiry0FnKovCPg84x21C/em5nnfO2dkA8d/2VDZ4
bgAm8iWCDLTZnkBQNywl6dCS/SJycrNFWHCCM1caRIB+hqXfQxHTdiNdZmU/hVG1
NwHbT/eOUuQBiwBfU81hZbfnkOg5+IFTdEhTvsVv5iJ0kZvsjMzW3/vv9g5SI8d4
ZLtsx8143DXWtKCx9ummKO6lvA/gAVadpL5jND8CAwEAAaOBhTCBgjALBgNVHQ8E
BAMCBDAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwPwYDVR0RBDgwNoIJbG9jYWxob3N0
ggsqLmxvY2FsaG9zdIcEfwAAAYcQAAAAAAAAAAAAAAAAAAAAAYcEwKgCFDAdBgNV
HQ4EFgQUgCJFBAvGvVtuAkHyDzYcUpgwoM4wDQYJKoZIhvcNAQELBQADggEBAGD2
cMVnEs1skKQ3HrLUY4kJsK7W3i8n59ISDMApc30q6QyJmKwrV6fRJTfsQ62qkhqG
JPO8xIILk+7MuMFfuCsSBe010VvnNCtFJWWnk34zwnMuUjOiSgTCtBdhYzGWWaUO
K9ezc7THZoWLJxgHpLL9r+8PFJs7/2HBZziAT04eDs9LfDoKioveRxZ6fok+u0hh
ygL9yP9T/Gpzv6JgLNSF5PPW/7OmDy/rsUSCvCRyh/WxWEnhb6r9yrmPWb/7uEfA
6q5zkmIHc7LYxB8H225reR/zdBXnVHQ6R9/3a/CTEK6uhtnAAcwlMMPrVQPoInoc
w+wdK6tpHVk6OVFWoa0=
-----END CERTIFICATE-----
</file>

<file path=".gitignore">
*.json
**/*-firebase-adminsdk-*.json
*firebase-adminsdk*.json
**/*-firebase-adminsdk-*.json
</file>

<file path="backup.sh">
#!/bin/bash

# ==============================================
# AR Namecard API - Backup Script for Synology NAS
# ==============================================

set -e

# Configuration
NAS_IP="192.168.1.93"
NAS_USER="admin"
NAS_BASE_PATH="/volume1/docker/ar-namecard"
BACKUP_BASE="/volume1/docker/ar-namecard/backups"
SERVICE_NAME="ar-namecard"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Backup MongoDB data
backup_mongodb() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/mongodb/$timestamp"
    
    log "Backing up MongoDB data..."
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $NAS_BASE_PATH/app
        
        # Create backup directory
        mkdir -p $backup_dir
        
        # Get MongoDB connection details from environment
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Create MongoDB dump
        docker-compose exec -T mongodb mongodump \
            --host localhost:27017 \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --db \$MONGO_DB_NAME \
            --out /tmp/backup
        
        # Copy backup from container to host
        docker cp ar-namecard-mongodb:/tmp/backup/$MONGO_DB_NAME $backup_dir/
        
        # Compress backup
        cd $BACKUP_BASE/mongodb
        tar -czf ${timestamp}_mongodb.tar.gz $timestamp/
        rm -rf $timestamp/
        
        echo 'MongoDB backup completed: ${timestamp}_mongodb.tar.gz'
    "
    
    success "MongoDB backup completed."
}

# Backup uploaded files
backup_uploads() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/uploads"
    
    log "Backing up uploaded files..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH
        
        if [ -d uploads ] && [ \"\$(ls -A uploads 2>/dev/null)\" ]; then
            tar -czf $backup_dir/${timestamp}_uploads.tar.gz uploads/
            echo 'Uploads backup completed: ${timestamp}_uploads.tar.gz'
        else
            echo 'No files to backup in uploads directory.'
        fi
    "
    
    success "Uploads backup completed."
}

# Backup configuration files
backup_config() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/config"
    
    log "Backing up configuration files..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH/app
        
        # Backup configuration files
        tar -czf $backup_dir/${timestamp}_config.tar.gz \
            .env \
            docker-compose.yml \
            nas.env \
            firebase-service-account.json 2>/dev/null || \
        tar -czf $backup_dir/${timestamp}_config.tar.gz \
            .env \
            docker-compose.yml \
            nas.env
        
        echo 'Configuration backup completed: ${timestamp}_config.tar.gz'
    "
    
    success "Configuration backup completed."
}

# Backup SSL certificates
backup_ssl() {
    local timestamp="$1"
    local backup_dir="$BACKUP_BASE/ssl"
    
    log "Backing up SSL certificates..."
    
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $backup_dir
        cd $NAS_BASE_PATH
        
        if [ -d ssl ] && [ -f ssl/server.crt ] && [ -f ssl/server.key ]; then
            tar -czf $backup_dir/${timestamp}_ssl.tar.gz ssl/
            echo 'SSL backup completed: ${timestamp}_ssl.tar.gz'
        else
            echo 'No SSL certificates to backup.'
        fi
    "
    
    success "SSL backup completed."
}

# Create full backup
full_backup() {
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    
    log "Starting full backup with timestamp: $timestamp"
    
    # Create backup directories
    ssh "$NAS_USER@$NAS_IP" "
        mkdir -p $BACKUP_BASE/{mongodb,uploads,config,ssl,logs}
    "
    
    # Perform backups
    backup_mongodb "$timestamp"
    backup_uploads "$timestamp"
    backup_config "$timestamp"
    backup_ssl "$timestamp"
    
    # Create backup manifest
    ssh "$NAS_USER@$NAS_IP" "
        cat > $BACKUP_BASE/backup_${timestamp}.manifest << EOF
AR Namecard Backup Manifest
Timestamp: $timestamp
Date: \$(date)
NAS: $NAS_IP

Backup Contents:
- MongoDB: ${timestamp}_mongodb.tar.gz
- Uploads: ${timestamp}_uploads.tar.gz
- Config:  ${timestamp}_config.tar.gz
- SSL:     ${timestamp}_ssl.tar.gz

Backup Sizes:
\$(du -h $BACKUP_BASE/*/${timestamp}_*.tar.gz 2>/dev/null || echo 'No backup files found')

Total Backup Size: \$(du -sh $BACKUP_BASE | cut -f1)
EOF
    "
    
    success "Full backup completed with timestamp: $timestamp"
}

# Restore MongoDB data
restore_mongodb() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Restoring MongoDB from backup: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $NAS_BASE_PATH/app
        
        if [ ! -f $BACKUP_BASE/mongodb/${backup_file}_mongodb.tar.gz ]; then
            echo 'Backup file not found: ${backup_file}_mongodb.tar.gz'
            exit 1
        fi
        
        # Extract backup
        cd /tmp
        tar -xzf $BACKUP_BASE/mongodb/${backup_file}_mongodb.tar.gz
        
        # Get environment variables
        cd $NAS_BASE_PATH/app
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Stop API service temporarily
        docker-compose stop api
        
        # Drop existing database
        docker-compose exec -T mongodb mongosh \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --eval \"use \$MONGO_DB_NAME; db.dropDatabase();\"
        
        # Copy backup to container
        docker cp /tmp/$backup_file/ ar-namecard-mongodb:/tmp/restore/
        
        # Restore database
        docker-compose exec -T mongodb mongorestore \
            --username \$MONGO_ROOT_USERNAME \
            --password \$MONGO_ROOT_PASSWORD \
            --authenticationDatabase admin \
            --db \$MONGO_DB_NAME \
            /tmp/restore/
        
        # Restart API service
        docker-compose start api
        
        # Cleanup
        rm -rf /tmp/$backup_file/
        
        echo 'MongoDB restore completed.'
    "
    
    success "MongoDB restore completed."
}

# Restore uploaded files
restore_uploads() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Restoring uploads from backup: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ ! -f $BACKUP_BASE/uploads/${backup_file}_uploads.tar.gz ]; then
            echo 'Backup file not found: ${backup_file}_uploads.tar.gz'
            exit 1
        fi
        
        cd $NAS_BASE_PATH
        
        # Backup current uploads
        if [ -d uploads ]; then
            mv uploads uploads_backup_\$(date +%Y%m%d_%H%M%S)
        fi
        
        # Restore uploads
        tar -xzf $BACKUP_BASE/uploads/${backup_file}_uploads.tar.gz
        
        echo 'Uploads restore completed.'
    "
    
    success "Uploads restore completed."
}

# List available backups
list_backups() {
    log "Available backups:"
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ -d $BACKUP_BASE ]; then
            echo ''
            echo 'Backup Files:'
            find $BACKUP_BASE -name '*.tar.gz' -exec basename {} \; | sort -r | head -20
            
            echo ''
            echo 'Backup Manifests:'
            find $BACKUP_BASE -name '*.manifest' -exec basename {} \; | sort -r | head -10
            
            echo ''
            echo 'Backup Directory Size:'
            du -sh $BACKUP_BASE
        else
            echo 'No backup directory found.'
        fi
    "
}

# Cleanup old backups
cleanup_backups() {
    local retention_days="${1:-30}"
    
    log "Cleaning up backups older than $retention_days days..."
    
    ssh "$NAS_USER@$NAS_IP" "
        if [ -d $BACKUP_BASE ]; then
            # Remove backup files older than retention period
            find $BACKUP_BASE -name '*.tar.gz' -type f -mtime +$retention_days -delete
            find $BACKUP_BASE -name '*.manifest' -type f -mtime +$retention_days -delete
            
            # Remove empty directories
            find $BACKUP_BASE -type d -empty -delete
            
            echo 'Backup cleanup completed.'
            echo 'Remaining backup size: \$(du -sh $BACKUP_BASE | cut -f1)'
        else
            echo 'No backup directory found.'
        fi
    "
    
    success "Backup cleanup completed."
}

# Verify backup integrity
verify_backup() {
    local backup_file="$1"
    
    if [ -z "$backup_file" ]; then
        error "Please specify backup file name (without path and extension)"
    fi
    
    log "Verifying backup integrity: $backup_file"
    
    ssh "$NAS_USER@$NAS_IP" "
        cd $BACKUP_BASE
        
        echo 'Checking backup files...'
        
        # Check MongoDB backup
        if [ -f mongodb/${backup_file}_mongodb.tar.gz ]; then
            echo 'âœ“ MongoDB backup exists'
            if tar -tzf mongodb/${backup_file}_mongodb.tar.gz >/dev/null 2>&1; then
                echo 'âœ“ MongoDB backup is valid'
            else
                echo 'âœ— MongoDB backup is corrupted'
            fi
        else
            echo 'âœ— MongoDB backup missing'
        fi
        
        # Check uploads backup
        if [ -f uploads/${backup_file}_uploads.tar.gz ]; then
            echo 'âœ“ Uploads backup exists'
            if tar -tzf uploads/${backup_file}_uploads.tar.gz >/dev/null 2>&1; then
                echo 'âœ“ Uploads backup is valid'
            else
                echo 'âœ— Uploads backup is corrupted'
            fi
        else
            echo '- Uploads backup not found (may be empty)'
        fi
        
        # Check config backup
        if [ -f config/${backup_file}_config.tar.gz ]; then
            echo 'âœ“ Config backup exists'
            if tar -tzf config/${backup_file}_config.tar.gz >/dev/null 2>&1; then
                echo 'âœ“ Config backup is valid'
            else
                echo 'âœ— Config backup is corrupted'
            fi
        else
            echo 'âœ— Config backup missing'
        fi
        
        # Check SSL backup
        if [ -f ssl/${backup_file}_ssl.tar.gz ]; then
            echo 'âœ“ SSL backup exists'
            if tar -tzf ssl/${backup_file}_ssl.tar.gz >/dev/null 2>&1; then
                echo 'âœ“ SSL backup is valid'
            else
                echo 'âœ— SSL backup is corrupted'
            fi
        else
            echo '- SSL backup not found (may not exist)'
        fi
        
        # Check manifest
        if [ -f backup_${backup_file}.manifest ]; then
            echo 'âœ“ Backup manifest exists'
        else
            echo 'âœ— Backup manifest missing'
        fi
    "
    
    success "Backup verification completed."
}

# Main function
main() {
    case "${1:-backup}" in
        "backup"|"full")
            full_backup
            ;;
        "restore-db")
            restore_mongodb "$2"
            ;;
        "restore-uploads")
            restore_uploads "$2"
            ;;
        "list")
            list_backups
            ;;
        "cleanup")
            cleanup_backups "$2"
            ;;
        "verify")
            verify_backup "$2"
            ;;
        *)
            echo "Usage: $0 {backup|restore-db|restore-uploads|list|cleanup|verify}"
            echo ""
            echo "Commands:"
            echo "  backup           - Create full backup"
            echo "  restore-db <id>  - Restore MongoDB from backup"
            echo "  restore-uploads <id> - Restore uploads from backup"
            echo "  list             - List available backups"
            echo "  cleanup [days]   - Remove backups older than X days (default: 30)"
            echo "  verify <id>      - Verify backup integrity"
            echo ""
            echo "Examples:"
            echo "  $0 backup"
            echo "  $0 restore-db 20250121_143000"
            echo "  $0 cleanup 7"
            echo "  $0 verify 20250121_143000"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
</file>

<file path="CORS_SETUP.md">
# CORS ì„¤ì • ê°€ì´ë“œ

## ê°œë°œì ëª¨ë“œì—ì„œ ë‹¤ì¤‘ ë””ë°”ì´ìŠ¤ ì ‘ê·¼ ì„¤ì •

### ğŸ¯ ëª©ì 
- ë‹¤ë¥¸ PC/ëª¨ë°”ì¼ì—ì„œ HTTPë¡œ ì ‘ê·¼ ì‹œ CORS ì˜¤ë¥˜ í•´ê²°
- ê°œë°œ í™˜ê²½ì—ì„œ ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ í—ˆìš©
- 8th Wall ë° ë‹¤ì–‘í•œ ê°œë°œ ë„êµ¬ ì§€ì›

### ğŸš€ ë¹ ë¥¸ ì„¤ì •

#### 1. ëª¨ë“  Origin í—ˆìš© (ê°œë°œ ëª¨ë“œ)
`.env` íŒŒì¼ì— ì¶”ê°€:
```bash
CORS_ALLOW_ALL=true
```

#### 2. ì„œë²„ ì¬ì‹œì‘
ê¸°ì¡´ ì„œë²„ ì¢…ë£Œ í›„:
```bash
npm run dev
```

ì„œë²„ ì‹œì‘ ì‹œ ë‹¤ìŒ ë©”ì‹œì§€ í™•ì¸:
```
ğŸ”“ CORS: ê°œë°œì ëª¨ë“œ - ëª¨ë“  origin í—ˆìš©
```

### ğŸŒ ì§€ì›ë˜ëŠ” ì ‘ê·¼ í™˜ê²½

#### ìë™ í—ˆìš©ë˜ëŠ” ë„ë©”ì¸ë“¤:

**ë¡œì»¬ ê°œë°œ í™˜ê²½**
- `http://localhost:3000`
- `http://127.0.0.1:3000`
- `http://0.0.0.0:3000`
- `https://localhost:3443`

**ë¡œì»¬ ë„¤íŠ¸ì›Œí¬**
- `http://192.168.x.x:3000`
- `http://10.x.x.x:3000`
- `http://172.16-31.x.x:3000`
- `http://xxx.local:3000`
- `http://xxx.lan:3000`

**8th Wall í”Œë«í¼**
- `https://*.8thwall.com`
- `https://*.8thwall.app`

**ê°œë°œì ë„êµ¬**
- `null` origin (file:// í”„ë¡œí† ì½œ)
- Chrome DevTools
- Postman ë“±

### âš™ï¸ ì„¤ì • ì˜µì…˜

#### 1. ì™„ì „ ê°œë°© ëª¨ë“œ (ê¶Œì¥)
```bash
CORS_ALLOW_ALL=true
```
- ëª¨ë“  originì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
- ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì‘ë™
- ê°€ì¥ í¸ë¦¬í•œ ì„¤ì •

#### 2. ì œí•œì  ëª¨ë“œ
```bash
CORS_ALLOW_ALL=false
```
- ì‚¬ì „ ì •ì˜ëœ ë„ë©”ì¸ë§Œ í—ˆìš©
- ë” ì•ˆì „í•œ ê°œë°œ í™˜ê²½
- ì¼ë¶€ ë„¤íŠ¸ì›Œí¬ì—ì„œ ì œí•œ ê°€ëŠ¥

### ğŸ”§ í™˜ê²½ë³„ ì„¤ì •

#### ê°œë°œ í™˜ê²½ (NODE_ENV=development)
- ì¶”ê°€ ë¡œì»¬ í˜¸ìŠ¤íŠ¸ ë³€í˜• ì§€ì›
- ë” ë„“ì€ ë„¤íŠ¸ì›Œí¬ íŒ¨í„´ í—ˆìš©
- ê°œë°œì ë„êµ¬ ì¹œí™”ì 

#### í”„ë¡œë•ì…˜ í™˜ê²½ (NODE_ENV=production)
- `CORS_ALLOW_ALL` ë¬´ì‹œ
- ì‚¬ì „ ì •ì˜ëœ ë„ë©”ì¸ë§Œ í—ˆìš©
- ë³´ì•ˆ ê°•í™”

### ğŸ› ë¬¸ì œ í•´ê²°

#### 1. ì—¬ì „íˆ CORS ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°
```bash
# ì„œë²„ ë¡œê·¸ í™•ì¸
ğŸš« CORS: ì°¨ë‹¨ëœ origin - http://192.168.x.x:3000
```

**í•´ê²° ë°©ë²•:**
1. `.env` íŒŒì¼ì— `CORS_ALLOW_ALL=true` í™•ì¸
2. ì„œë²„ ì¬ì‹œì‘
3. ë¸Œë¼ìš°ì € ìºì‹œ í´ë¦¬ì–´

#### 2. ê°œë°œì ë„êµ¬ì—ì„œ ì ‘ê·¼ ë¶ˆê°€
- Chrome: ê°œë°œì ë„êµ¬ â†’ Network â†’ Disable cache
- ì‹œí¬ë¦¿ ëª¨ë“œë¡œ í…ŒìŠ¤íŠ¸
- ë‹¤ë¥¸ ë¸Œë¼ìš°ì €ë¡œ í…ŒìŠ¤íŠ¸

#### 3. ëª¨ë°”ì¼ì—ì„œ ì ‘ê·¼ ë¶ˆê°€
- ë°©í™”ë²½ ì„¤ì • í™•ì¸
- ê°™ì€ WiFi ë„¤íŠ¸ì›Œí¬ ì—°ê²° í™•ì¸
- IP ì£¼ì†Œ ì •í™•ì„± í™•ì¸

### ğŸ”’ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

#### ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì‚¬ìš©
- `CORS_ALLOW_ALL=true`ëŠ” ê°œë°œìš©
- í”„ë¡œë•ì…˜ì—ì„œëŠ” ìë™ ë¬´ì‹œ
- ë¯¼ê°í•œ ë°ì´í„° ë…¸ì¶œ ì£¼ì˜

#### í”„ë¡œë•ì…˜ ë°°í¬ ì‹œ
```bash
NODE_ENV=production
CORS_ALLOW_ALL=false  # ë˜ëŠ” ì œê±°
```

### ğŸ“± í…ŒìŠ¤íŠ¸ ë°©ë²•

#### 1. ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸
```bash
curl -H "Origin: http://test.com" http://localhost:3000/api/health
```

#### 2. ë‹¤ë¥¸ PCì—ì„œ í…ŒìŠ¤íŠ¸
ë¸Œë¼ìš°ì €ì—ì„œ `http://192.168.x.x:3000/api/health` ì ‘ì†

#### 3. ëª¨ë°”ì¼ì—ì„œ í…ŒìŠ¤íŠ¸
ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ì—ì„œ `http://192.168.x.x:3000/test/customize` ì ‘ì†

### ğŸ‰ ì„±ê³µ í™•ì¸

ì„œë²„ ë¡œê·¸ì—ì„œ ë‹¤ìŒ ë©”ì‹œì§€ í™•ì¸:
```
ğŸ”“ CORS: ê°œë°œì ëª¨ë“œ - ëª¨ë“  origin í—ˆìš©
ğŸš€ HTTP Server is running on:
   - Local:    http://localhost:3000
   - Network:  http://192.168.x.x:3000
```

ë¸Œë¼ìš°ì €ì—ì„œ CORS ì˜¤ë¥˜ ì—†ì´ API í˜¸ì¶œ ì„±ê³µ!
</file>

<file path="deploy.sh">
#!/bin/bash

# ==============================================
# AR Namecard API - Synology NAS Deployment Script
# ==============================================

set -e  # Exit on any error

# Configuration
NAS_IP="192.168.1.93"
NAS_USER="admin"
NAS_PASSWORD="hnine0426"
NAS_BASE_PATH="/volume1/docker/ar-namecard"
LOCAL_BUILD_PATH="./build"
SERVICE_NAME="ar-namecard"

# SSH function with password
ssh_nas() {
    expect -c "
        set timeout 30
        spawn ssh -o StrictHostKeyChecking=no $NAS_USER@$NAS_IP \"$1\"
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
}

# SCP function with password
scp_nas() {
    expect -c "
        set timeout 60
        spawn $1
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check if SSH key exists
    if [ ! -f ~/.ssh/id_rsa ]; then
        warning "SSH key not found. You may need to enter password multiple times."
    fi
    
    # Check if rsync is available
    if ! command -v rsync &> /dev/null; then
        error "rsync is required but not installed."
    fi
    
    # Check if Docker files exist
    if [ ! -f "./Dockerfile" ] || [ ! -f "./docker-compose.yml" ]; then
        error "Docker configuration files not found."
    fi
    
    success "Prerequisites check completed."
}

# Test NAS connection
test_connection() {
    log "Testing connection to NAS..."
    
    result=$(ssh_nas "echo 'connection_test_ok'")
    if echo "$result" | grep -q "connection_test_ok"; then
        success "SSH connection to NAS successful."
    else
        error "Cannot connect to NAS. Please check SSH configuration."
    fi
}

# Create directory structure on NAS
create_directories() {
    log "Creating directory structure on NAS..."
    
    ssh_nas "
        mkdir -p $NAS_BASE_PATH/{app,data/mongodb,data/mongodb-config,uploads,ssl,public,backups,logs}
        chmod -R 755 $NAS_BASE_PATH
    "
    
    success "Directory structure created."
}

# Build application locally
build_application() {
    log "Building application locally..."
    
    # Clean previous build
    rm -rf "$LOCAL_BUILD_PATH"
    mkdir -p "$LOCAL_BUILD_PATH"
    
    # Copy source files to build directory (Docker will handle the build)
    cp -r src package*.json tsconfig.json "$LOCAL_BUILD_PATH/"
    cp Dockerfile docker-compose.yml nas.env "$LOCAL_BUILD_PATH/"
    
    # Copy SSL certificates if they exist
    if [ -d "./ssl" ]; then
        cp -r ssl "$LOCAL_BUILD_PATH/"
    fi
    
    # Copy Firebase service account if it exists
    if [ -f "./firebase-service-account.json" ]; then
        cp firebase-service-account.json "$LOCAL_BUILD_PATH/"
    fi
    
    # Copy any additional files
    if [ -d "./scripts" ]; then
        cp -r scripts "$LOCAL_BUILD_PATH/"
    fi
    
    success "Application files prepared for Docker build."
}

# Transfer files to NAS
transfer_files() {
    log "Transferring files to NAS..."
    
    # Use expect for rsync with password
    expect -c "
        set timeout 300
        spawn rsync -avz --delete --exclude='node_modules/.cache' --exclude='*.log' $LOCAL_BUILD_PATH/ $NAS_USER@$NAS_IP:$NAS_BASE_PATH/app/
        expect \"password:\"
        send \"$NAS_PASSWORD\r\"
        expect eof
    "
    
    success "Files transferred successfully."
}

# Setup environment configuration
setup_environment() {
    log "Setting up environment configuration..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Copy nas.env to .env if .env doesn't exist
        if [ ! -f .env ]; then
            cp nas.env .env
            echo 'Environment file created from nas.env template.'
            echo 'Please edit .env file with your actual configuration.'
        fi
        
        # Generate JWT secret if needed
        if grep -q 'your-super-secure-jwt-secret' .env; then
            JWT_SECRET=\$(openssl rand -base64 32)
            sed -i \"s/your-super-secure-jwt-secret-for-production-use-minimum-32-characters/\$JWT_SECRET/g\" .env
            echo 'JWT secret generated automatically.'
        fi
    "
    
    success "Environment configuration completed."
}

# Generate SSL certificates
generate_ssl() {
    log "Generating SSL certificates..."
    
    ssh_nas "
        cd $NAS_BASE_PATH
        
        if [ ! -f ssl/server.crt ] || [ ! -f ssl/server.key ]; then
            openssl req -x509 -newkey rsa:4096 -keyout ssl/server.key -out ssl/server.crt -days 365 -nodes \
                -subj '/C=KR/ST=Seoul/L=Seoul/O=AR-Namecard/CN=$NAS_IP' \
                -addext 'subjectAltName=IP:$NAS_IP,IP:127.0.0.1,DNS:localhost,DNS:ar-namecard.local'
            
            chmod 600 ssl/server.key
            chmod 644 ssl/server.crt
            
            echo 'SSL certificates generated.'
        else
            echo 'SSL certificates already exist.'
        fi
    "
    
    success "SSL certificates ready."
}

# Deploy with Docker Compose
deploy_services() {
    log "Deploying services with Docker Compose..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Load environment variables
        export \$(cat .env | grep -v '^#' | xargs)
        
        # Stop existing services
        docker-compose down --remove-orphans
        
        # Pull latest images
        docker-compose pull
        
        # Build and start services
        docker-compose up -d --build
        
        # Wait for services to start
        sleep 30
        
        # Check service status
        docker-compose ps
    "
    
    success "Services deployed successfully."
}

# Verify deployment
verify_deployment() {
    log "Verifying deployment..."
    
    ssh_nas "
        cd $NAS_BASE_PATH/app
        
        # Check if containers are running
        if docker-compose ps | grep -q 'Up'; then
            echo 'Containers are running.'
        else
            echo 'Some containers are not running properly.'
            docker-compose logs --tail=20
            exit 1
        fi
        
        # Test API health endpoint
        sleep 10
        if curl -f http://localhost:3000/api/health &>/dev/null; then
            echo 'API health check passed.'
        else
            echo 'API health check failed.'
            exit 1
        fi
    "
    
    success "Deployment verification completed."
}

# Cleanup local build
cleanup() {
    log "Cleaning up local build files..."
    rm -rf "$LOCAL_BUILD_PATH"
    success "Cleanup completed."
}

# Show deployment information
show_info() {
    log "Deployment completed successfully!"
    echo ""
    echo "ğŸ“¡ Service URLs:"
    echo "   HTTP:  http://$NAS_IP:3000"
    echo "   HTTPS: https://$NAS_IP:3443"
    echo "   API Docs: http://$NAS_IP:3000/api-docs"
    echo ""
    echo "ğŸ›   Management Commands:"
    echo "   Check logs: ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose logs -f'"
    echo "   Restart:    ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose restart'"
    echo "   Stop:       ssh $NAS_USER@$NAS_IP 'cd $NAS_BASE_PATH/app && docker-compose down'"
    echo ""
    echo "âš™ï¸  Configuration:"
    echo "   Edit: ssh $NAS_USER@$NAS_IP 'nano $NAS_BASE_PATH/app/.env'"
    echo ""
}

# Main deployment process
main() {
    echo "ğŸš€ Starting AR Namecard API deployment to Synology NAS..."
    echo ""
    
    check_prerequisites
    test_connection
    create_directories
    build_application
    transfer_files
    setup_environment
    generate_ssl
    deploy_services
    verify_deployment
    cleanup
    show_info
}

# Handle script arguments
case "${1:-deploy}" in
    "deploy")
        main
        ;;
    "logs")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose logs -f"
        ;;
    "restart")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose restart"
        ;;
    "stop")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose down"
        ;;
    "status")
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose ps"
        ;;
    "update")
        log "Updating application..."
        build_application
        transfer_files
        ssh_nas "cd $NAS_BASE_PATH/app && docker-compose up -d --build"
        cleanup
        success "Application updated successfully."
        ;;
    *)
        echo "Usage: $0 {deploy|logs|restart|stop|status|update}"
        echo ""
        echo "Commands:"
        echo "  deploy  - Full deployment (default)"
        echo "  logs    - Show service logs"
        echo "  restart - Restart services"
        echo "  stop    - Stop services"
        echo "  status  - Show service status"
        echo "  update  - Update application only"
        exit 1
        ;;
esac
</file>

<file path="DEPLOYMENT_CHECKLIST.md">
# âœ… CloudType ë°°í¬ í›„ ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

## ğŸ¯ ë°°í¬ URL
ë°°í¬ ì™„ë£Œ í›„ CloudTypeì—ì„œ ì œê³µí•˜ëŠ” URLì„ ê¸°ë¡í•˜ì„¸ìš”:
```
Base URL: https://port-3000-ar-namecard-api-xxxxx.cloudtype.app
```

## ğŸ” Phase 1: ê¸°ë³¸ ì„œë¹„ìŠ¤ í™•ì¸

### 1.1 Health Check ì—”ë“œí¬ì¸íŠ¸
- [ ] **GET** `/health`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/health
  ```
  **Expected Response:**
  ```json
  {
    "status": "healthy",
    "timestamp": "2024-01-XX...",
    "server": "AR Namecard API",
    "version": "1.0.0",
    "environment": "production",
    "cors": "enabled",
    "mongodb": "connected",
    "firebase": "configured"
  }
  ```

- [ ] **GET** `/api/health`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/health
  ```

### 1.2 Swagger ë¬¸ì„œ ì ‘ê·¼
- [ ] **GET** `/api-docs`
  - ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
  - Swagger UI ì •ìƒ ë¡œë“œ
  - ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸ í‘œì‹œ

## ğŸ“‹ Phase 2: í…ŒìŠ¤íŠ¸ í˜ì´ì§€ í™•ì¸

### 2.1 ìºë¦­í„° ì˜µì…˜ ê´€ë¦¬ í…ŒìŠ¤íŠ¸
- [ ] **GET** `/test/avatar`
  - í˜ì´ì§€ ì •ìƒ ë¡œë“œ
  - ê´€ë¦¬ì í† í° ìƒì„± ë²„íŠ¼ ì‘ë™
  - ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë¡œë“œ ê°€ëŠ¥
  - ì˜µì…˜ ì¶”ê°€/ìˆ˜ì •/ì‚­ì œ UI í‘œì‹œ

### 2.2 ì‚¬ìš©ì ê´€ë¦¬ í…ŒìŠ¤íŠ¸
- [ ] **GET** `/test/user`
  - ì‚¬ìš©ì ëª©ë¡ í‘œì‹œ
  - ê²€ìƒ‰ ê¸°ëŠ¥ ì‘ë™
  - ì‚¬ìš©ì ìƒì„¸ ì •ë³´ í™•ì¸

### 2.3 ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸
- [ ] **GET** `/test/login`
  - ë¡œê·¸ì¸ í¼ í‘œì‹œ
  - Firebase ì¸ì¦ ì„¤ì • í™•ì¸
  - ë¡œê·¸ì¸ í”„ë¡œì„¸ìŠ¤ í…ŒìŠ¤íŠ¸

### 2.4 ì•„ì´í…œ ê´€ë¦¬ í…ŒìŠ¤íŠ¸
- [ ] **GET** `/test/item`
  - ìŠ¤í‹°ì»¤ ëª©ë¡ í‘œì‹œ
  - ê²€ìƒ‰/í•„í„° ê¸°ëŠ¥ ì‘ë™

### 2.5 ì»¤ìŠ¤í„°ë§ˆì´ì œì´ì…˜ í…ŒìŠ¤íŠ¸
- [ ] **GET** `/test/customize`
  - ìºë¦­í„° ì»¤ìŠ¤í„°ë§ˆì´ì œì´ì…˜ UI ë¡œë“œ
  - ì˜µì…˜ ì„ íƒ ê¸°ëŠ¥ ì‘ë™

## ğŸ”Œ Phase 3: API ì—”ë“œí¬ì¸íŠ¸ ê²€ì¦

### 3.1 Authentication API
- [ ] **GET** `/api/auth/test-token/001`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/auth/test-token/001
  ```
  **Expected:** ê´€ë¦¬ì í† í° ìƒì„±

### 3.2 Characters API
- [ ] **GET** `/api/characters`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/characters
  ```
  **Expected:** ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ëª©ë¡

### 3.3 Stickers API
- [ ] **GET** `/api/stickers`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/stickers
  ```
  **Expected:** ìŠ¤í‹°ì»¤ ëª©ë¡

### 3.4 Admin API (í† í° í•„ìš”)
- [ ] **GET** `/api/admin/characters/categories`
  ```bash
  curl -H "Authorization: Bearer [TOKEN]" \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/admin/characters/categories
  ```
  **Expected:** ê´€ë¦¬ì ì „ìš© ì¹´í…Œê³ ë¦¬ ëª©ë¡

## ğŸ—„ï¸ Phase 4: MongoDB Atlas ì—°ê²° ê²€ì¦

### 4.1 ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ
- [ ] Atlas ëŒ€ì‹œë³´ë“œì—ì„œ ì—°ê²° í™•ì¸
- [ ] Real-time íƒ­ì—ì„œ í™œì„± ì—°ê²° í™•ì¸
- [ ] Metricsì—ì„œ ì—°ê²° ì„±ëŠ¥ í™•ì¸

### 4.2 ì»¬ë ‰ì…˜ ìƒì„± í™•ì¸
- [ ] `users` ì»¬ë ‰ì…˜ ì¡´ì¬
- [ ] `avatarcategories` ì»¬ë ‰ì…˜ ì¡´ì¬
- [ ] `usercustomizations` ì»¬ë ‰ì…˜ ì¡´ì¬
- [ ] `items` ì»¬ë ‰ì…˜ ì¡´ì¬

### 4.3 ë°ì´í„° CRUD í…ŒìŠ¤íŠ¸
- [ ] ì‚¬ìš©ì ìƒì„± í…ŒìŠ¤íŠ¸ (íšŒì›ê°€ì…)
- [ ] ë°ì´í„° ì¡°íšŒ í…ŒìŠ¤íŠ¸
- [ ] ë°ì´í„° ìˆ˜ì • í…ŒìŠ¤íŠ¸
- [ ] ë°ì´í„° ì‚­ì œ í…ŒìŠ¤íŠ¸

## ğŸ”¥ Phase 5: Firebase ì—°ë™ ê²€ì¦

### 5.1 Firebase Authentication
- [ ] **POST** `/api/auth/firebase/verify`
  ```bash
  curl -X POST \
       -H "Content-Type: application/json" \
       -d '{"idToken": "TEST_TOKEN"}' \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/auth/firebase/verify
  ```

### 5.2 Firebase ì„¤ì • í™•ì¸
- [ ] í™˜ê²½ë³€ìˆ˜ FIREBASE_PROJECT_ID í™•ì¸
- [ ] FIREBASE_PRIVATE_KEY ì •ìƒ ì„¤ì • í™•ì¸
- [ ] FIREBASE_CLIENT_EMAIL ì •ìƒ ì„¤ì • í™•ì¸

## ğŸ“ Phase 6: íŒŒì¼ ì—…ë¡œë“œ ê¸°ëŠ¥ ê²€ì¦

### 6.1 ê¸°ë³¸ íŒŒì¼ ì—…ë¡œë“œ
- [ ] **POST** `/api/upload`
  ```bash
  curl -X POST \
       -F "file=@test-image.jpg" \
       https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/api/upload
  ```
  **Expected:** íŒŒì¼ ì—…ë¡œë“œ ì„±ê³µ ë° URL ë°˜í™˜

### 6.2 ì •ì  íŒŒì¼ ì„œë¹™
- [ ] `/uploads/` ê²½ë¡œ ì ‘ê·¼ ê°€ëŠ¥
- [ ] `/uploads/thumbnails/` ê²½ë¡œ ì ‘ê·¼ ê°€ëŠ¥
- [ ] `/uploads/palettes/` ê²½ë¡œ ì ‘ê·¼ ê°€ëŠ¥

### 6.3 ê´€ë¦¬ì ì˜µì…˜ ì—…ë¡œë“œ
- [ ] ìºë¦­í„° ì˜µì…˜ ì´ë¯¸ì§€ ì—…ë¡œë“œ
- [ ] ì¸ë„¤ì¼ ìë™ ìƒì„±
- [ ] íŒ”ë ˆíŠ¸ ì´ë¯¸ì§€ ì²˜ë¦¬
- [ ] Hair ì¹´í…Œê³ ë¦¬ íŠ¹ìˆ˜ ì²˜ë¦¬ (ì¤‘ê°„ë¨¸ë¦¬/ë’·ë¨¸ë¦¬)

## ğŸŒ Phase 7: CORS ë° ë„¤íŠ¸ì›Œí¬ ê²€ì¦

### 7.1 CORS í—¤ë” í™•ì¸
- [ ] í”„ë¦¬í”Œë¼ì´íŠ¸ ìš”ì²­ ì²˜ë¦¬
- [ ] Access-Control-Allow-Origin í—¤ë”
- [ ] Access-Control-Allow-Methods í—¤ë”
- [ ] Access-Control-Allow-Headers í—¤ë”

### 7.2 ë‹¤ì–‘í•œ ë„ë©”ì¸ì—ì„œ ì ‘ê·¼ í…ŒìŠ¤íŠ¸
- [ ] ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ì ‘ê·¼
- [ ] ë‹¤ë¥¸ ë„ë©”ì¸ì—ì„œ AJAX ìš”ì²­
- [ ] ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ê·¼

## ğŸš¨ Phase 8: ì˜¤ë¥˜ ì²˜ë¦¬ ê²€ì¦

### 8.1 404 ì—ëŸ¬ ì²˜ë¦¬
- [ ] **GET** `/nonexistent-endpoint`
  ```bash
  curl https://port-3000-ar-namecard-api-xxxxx.cloudtype.app/nonexistent-endpoint
  ```
  **Expected:** `{"error": "Route not found"}`

### 8.2 ì¸ì¦ ì˜¤ë¥˜ ì²˜ë¦¬
- [ ] í† í° ì—†ì´ ê´€ë¦¬ì API í˜¸ì¶œ
- [ ] ì˜ëª»ëœ í† í°ìœ¼ë¡œ API í˜¸ì¶œ
- [ ] ë§Œë£Œëœ í† í°ìœ¼ë¡œ API í˜¸ì¶œ

### 8.3 ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜
- [ ] ì˜ëª»ëœ ë°ì´í„°ë¡œ POST ìš”ì²­
- [ ] í•„ìˆ˜ í•„ë“œ ëˆ„ë½ìœ¼ë¡œ ìš”ì²­
- [ ] ì˜ëª»ëœ íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ì—…ë¡œë“œ

## ğŸ“Š Phase 9: ì„±ëŠ¥ ë° ëª¨ë‹ˆí„°ë§

### 9.1 ì‘ë‹µ ì‹œê°„ í™•ì¸
- [ ] Health Check ì‘ë‹µ ì‹œê°„ < 500ms
- [ ] API ì—”ë“œí¬ì¸íŠ¸ í‰ê·  ì‘ë‹µ ì‹œê°„ < 2ì´ˆ
- [ ] íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬ ì‹œê°„ í™•ì¸

### 9.2 CloudType ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰
- [ ] CPU ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
- [ ] ë„¤íŠ¸ì›Œí¬ íŠ¸ë˜í”½ í™•ì¸

### 9.3 ë¡œê·¸ ëª¨ë‹ˆí„°ë§
- [ ] ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸ ì •ìƒ ì¶œë ¥
- [ ] ì˜¤ë¥˜ ë¡œê·¸ ìˆ˜ì§‘ í™•ì¸
- [ ] ì ‘ê·¼ ë¡œê·¸ ê¸°ë¡ í™•ì¸

## ğŸ”„ Phase 10: ì§€ì†ì  ëª¨ë‹ˆí„°ë§

### 10.1 ì¼ì¼ ì²´í¬
- [ ] ì„œë¹„ìŠ¤ ê°€ìš©ì„± í™•ì¸
- [ ] ì˜¤ë¥˜ ë¡œê·¸ ê²€í† 
- [ ] ì„±ëŠ¥ ì§€í‘œ í™•ì¸

### 10.2 ì£¼ê°„ ì²´í¬
- [ ] MongoDB Atlas ìš©ëŸ‰ í™•ì¸
- [ ] ë³´ì•ˆ ì—…ë°ì´íŠ¸ ê²€í† 
- [ ] ë°±ì—… ìƒíƒœ í™•ì¸

### 10.3 ì›”ê°„ ì²´í¬
- [ ] SSL ì¸ì¦ì„œ ë§Œë£Œì¼ í™•ì¸
- [ ] ì˜ì¡´ì„± íŒ¨í‚¤ì§€ ì—…ë°ì´íŠ¸
- [ ] ì„±ëŠ¥ ìµœì í™” ê²€í† 

## âŒ ë¬¸ì œ í•´ê²° ê°€ì´ë“œ

### ì—°ê²° ë¬¸ì œ
1. **MongoDB ì—°ê²° ì‹¤íŒ¨**
   - Atlas IP í—ˆìš© ëª©ë¡ í™•ì¸
   - ì—°ê²° ë¬¸ìì—´ ê²€ì¦
   - ë„¤íŠ¸ì›Œí¬ ì„¤ì • ì¬í™•ì¸

2. **Firebase ì—°ê²° ì˜¤ë¥˜**
   - í™˜ê²½ë³€ìˆ˜ í˜•ì‹ í™•ì¸
   - Private Key ì¤„ë°”ê¿ˆ ë¬¸ì í™•ì¸
   - í”„ë¡œì íŠ¸ ID ì¼ì¹˜ ì—¬ë¶€ í™•ì¸

3. **CORS ì˜¤ë¥˜**
   - CloudType ë„ë©”ì¸ CORS í—ˆìš© ëª©ë¡ í™•ì¸
   - preflight ìš”ì²­ ì²˜ë¦¬ í™•ì¸

### ì„±ëŠ¥ ë¬¸ì œ
1. **ëŠë¦° ì‘ë‹µ**
   - ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ í™•ì¸
   - ì¿¼ë¦¬ ìµœì í™” í•„ìš”
   - ìºì‹± ì „ëµ ê²€í† 

2. **ë©”ëª¨ë¦¬ ë¶€ì¡±**
   - ì´ë¯¸ì§€ ì²˜ë¦¬ ìµœì í™”
   - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê²€ì‚¬
   - CloudType í”Œëœ ì—…ê·¸ë ˆì´ë“œ ê³ ë ¤

## âœ… ë°°í¬ ì™„ë£Œ í™•ì¸

ëª¨ë“  í•­ëª©ì´ ì²´í¬ë˜ë©´ ë°°í¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œëœ ê²ƒì…ë‹ˆë‹¤!

- [ ] **Phase 1-10 ëª¨ë“  í•­ëª© ì™„ë£Œ**
- [ ] **ë¬¸ì„œí™” ì—…ë°ì´íŠ¸ ì™„ë£Œ**
- [ ] **ëª¨ë‹ˆí„°ë§ ì„¤ì • ì™„ë£Œ**
- [ ] **íŒ€ ê³µìœ  ì™„ë£Œ**

---

**ë°°í¬ ì™„ë£Œì¼**: ___________  
**ë°°í¬ ë‹´ë‹¹ì**: ___________  
**CloudType URL**: ___________  
**MongoDB Atlas Cluster**: ___________
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # MongoDB Database
  mongodb:
    image: mongo:6.0
    container_name: ar-namecard-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD:-admin123}
      MONGO_INITDB_DATABASE: ${MONGO_DB_NAME:-ar_namecard}
    volumes:
      - mongodb_data:/data/db
      - mongodb_config:/data/configdb
      - ./mongodb-init:/docker-entrypoint-initdb.d:ro
    networks:
      - ar-namecard-network
    ports:
      - "127.0.0.1:27017:27017"  # Only accessible from localhost
    command: mongod --auth
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # AR Namecard API Server
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ar-namecard-api
    restart: unless-stopped
    depends_on:
      mongodb:
        condition: service_healthy
    environment:
      # Server Configuration
      NODE_ENV: production
      PORT: 3000
      HTTPS_PORT: 3443
      HOST: 0.0.0.0
      ENABLE_HTTPS: ${ENABLE_HTTPS:-false}
      
      # Database Configuration
      MONGODB_URI: mongodb://${MONGO_ROOT_USERNAME:-admin}:${MONGO_ROOT_PASSWORD:-admin123}@mongodb:27017/${MONGO_DB_NAME:-ar_namecard}?authSource=admin
      
      # JWT Configuration
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRES_IN: ${JWT_EXPIRES_IN:-24h}
      
      # File Upload Configuration
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10485760}
      UPLOAD_DIR: uploads
      
      # CORS Configuration
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      CORS_ALLOW_ALL: ${CORS_ALLOW_ALL:-false}
      
      # SSL Configuration
      SSL_KEY_PATH: ./ssl/server.key
      SSL_CERT_PATH: ./ssl/server.crt
      
      # Firebase Configuration
      FIREBASE_PROJECT_ID: ${FIREBASE_PROJECT_ID}
      FIREBASE_PRIVATE_KEY: ${FIREBASE_PRIVATE_KEY}
      FIREBASE_CLIENT_EMAIL: ${FIREBASE_CLIENT_EMAIL}
    volumes:
      - uploads_data:/app/uploads
      - ssl_certs:/app/ssl
      - public_files:/app/public
      - ./firebase-service-account.json:/app/firebase-service-account.json:ro
    networks:
      - ar-namecard-network
    ports:
      - "${API_HTTP_PORT:-3000}:3000"
      - "${API_HTTPS_PORT:-3443}:3443"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.ar-namecard.rule=Host(`${DOMAIN_NAME:-localhost}`)"
      - "traefik.http.routers.ar-namecard.tls=true"

  # Nginx Reverse Proxy (Optional)
  nginx:
    image: nginx:alpine
    container_name: ar-namecard-nginx
    restart: unless-stopped
    depends_on:
      api:
        condition: service_healthy
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ssl_certs:/etc/nginx/ssl:ro
      - uploads_data:/var/www/uploads:ro
    networks:
      - ar-namecard-network
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    profiles:
      - with-nginx

networks:
  ar-namecard-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  mongodb_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/data/mongodb
  mongodb_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/data/mongodb-config
  uploads_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/uploads
  ssl_certs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/ssl
  public_files:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /volume1/docker/ar-namecard/public
</file>

<file path="Dockerfile">
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including devDependencies for TypeScript)
RUN npm install

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# Create uploads directory
RUN mkdir -p uploads/thumbnails uploads/palettes

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })" || exit 1

# Start application
CMD ["npm", "start"]
</file>

<file path="HTTPS_SETUP.md">
# HTTPS ì„¤ì • ê°€ì´ë“œ

## 8th Wall ë° ë‹¤ì¤‘ ë””ë°”ì´ìŠ¤ ì ‘ê·¼ì„ ìœ„í•œ HTTPS ì„¤ì •

### ğŸ¯ ëª©ì 
- 8th Wall WebAR í”Œë«í¼ì—ì„œ ë°±ì—”ë“œ API ì ‘ê·¼
- ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ì˜ ë‹¤ë¥¸ PC/ëª¨ë°”ì¼ì—ì„œ ì ‘ê·¼
- Firebase ì¸ì¦ì„ í¬í•¨í•œ ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

### ğŸš€ ë¹ ë¥¸ ì‹œì‘

#### 1. SSL ì¸ì¦ì„œ ìƒì„±
```bash
npm run ssl:generate
```

#### 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
`.env` íŒŒì¼ì— ë‹¤ìŒ ì¶”ê°€:
```bash
ENABLE_HTTPS=true
HOST=0.0.0.0
```

#### 3. HTTPS ì„œë²„ ì‹¤í–‰
```bash
npm run https
```

### ğŸŒ ì ‘ê·¼ URL

#### ë¡œì»¬ ì ‘ê·¼
- HTTP: `http://localhost:3000`
- HTTPS: `https://localhost:3443`

#### ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ (ì˜ˆ: 192.168.2.20)
- HTTP: `http://192.168.2.20:3000`
- HTTPS: `https://192.168.2.20:3443`

### ğŸ” ë¸Œë¼ìš°ì € ë³´ì•ˆ ê²½ê³  í•´ê²°

#### Chrome
1. ë¸Œë¼ìš°ì €ì—ì„œ "ê³ ê¸‰" í´ë¦­
2. "localhost(ì•ˆì „í•˜ì§€ ì•ŠìŒ)ë¡œ ì´ë™" í´ë¦­

#### Firefox
1. ë¸Œë¼ìš°ì €ì—ì„œ "ê³ ê¸‰" í´ë¦­
2. "ìœ„í—˜ì„ ê°ìˆ˜í•˜ê³  ê³„ì†" í´ë¦­

#### Safari
1. "ìì„¸íˆ" í´ë¦­
2. "ì›¹ ì‚¬ì´íŠ¸ ë°©ë¬¸" í´ë¦­

### ğŸ“± Firebase ì„¤ì •

#### 1. Firebase Console ì„¤ì •
1. [Firebase Console](https://console.firebase.google.com/) ì ‘ì†
2. í”„ë¡œì íŠ¸ â†’ Authentication â†’ ì„¤ì • â†’ ìŠ¹ì¸ëœ ë„ë©”ì¸
3. ë‹¤ìŒ ë„ë©”ì¸ ì¶”ê°€:
   - `localhost`
   - `192.168.2.20` (ì‹¤ì œ IP ì£¼ì†Œ)
   - í•„ìš”ì‹œ ë‹¤ë¥¸ ë¡œì»¬ IP ì£¼ì†Œ

#### 2. 8th Wall í”„ë¡œì íŠ¸ ì„¤ì •
8th Wall í”„ë¡œì íŠ¸ì—ì„œ API í˜¸ì¶œ ì‹œ:
```javascript
// ë™ì  API ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •
const API_BASE_URL = window.location.hostname === 'localhost' 
  ? 'https://localhost:3443'
  : 'https://192.168.2.20:3443';

// API í˜¸ì¶œ ì˜ˆì‹œ
fetch(`${API_BASE_URL}/api/avatars/026`)
  .then(response => response.json())
  .then(data => console.log(data));
```

### ğŸ›¡ï¸ ë³´ì•ˆ ë° CORS ì„¤ì •

í˜„ì¬ í—ˆìš©ëœ ë„ë©”ì¸:
- `localhost` (HTTP/HTTPS)
- ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ IP (192.168.x.x, 10.x.x.x, 172.16-31.x.x)
- `*.8thwall.com`
- `*.8thwall.app`

### ğŸ”§ ê³ ê¸‰ ì„¤ì •

#### ì»¤ìŠ¤í…€ ì¸ì¦ì„œ ê²½ë¡œ
`.env` íŒŒì¼ì—ì„œ ì¸ì¦ì„œ ê²½ë¡œ ë³€ê²½:
```bash
SSL_KEY_PATH=./custom/path/server.key
SSL_CERT_PATH=./custom/path/server.crt
```

#### í¬íŠ¸ ë³€ê²½
```bash
PORT=3000
HTTPS_PORT=3443
```

### ğŸ› ë¬¸ì œ í•´ê²°

#### 1. "ERR_CERT_AUTHORITY_INVALID" ì˜¤ë¥˜
- ë¸Œë¼ìš°ì €ì—ì„œ "ê³ ê¸‰" â†’ "ê³„ì†" í´ë¦­
- ë˜ëŠ” ë¡œì»¬ CA ì„¤ì •ìœ¼ë¡œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì¸ì¦ì„œ ìƒì„±

#### 2. ë°©í™”ë²½ ë¬¸ì œ
macOS:
```bash
sudo pfctl -f /etc/pf.conf
```

Windows:
- Windows Defender ë°©í™”ë²½ì—ì„œ í¬íŠ¸ 3443 í—ˆìš©

#### 3. 8th Wallì—ì„œ ì ‘ê·¼ ë¶ˆê°€
- Mixed Content ì •ì±… í™•ì¸
- HTTPS ì‚¬ìš© ì—¬ë¶€ í™•ì¸
- Firebase ìŠ¹ì¸ëœ ë„ë©”ì¸ í™•ì¸

### ğŸ“š ì°¸ê³  ìë£Œ

- [8th Wall Documentation](https://www.8thwall.com/docs)
- [Firebase Authentication](https://firebase.google.com/docs/auth)
- [Node.js HTTPS](https://nodejs.org/api/https.html)

### ğŸ‰ í…ŒìŠ¤íŠ¸ í˜ì´ì§€

- **ì»¤ìŠ¤í„°ë§ˆì´ì§•**: `https://localhost:3443/test/customize`
- **Firebase ë¡œê·¸ì¸**: `https://localhost:3443/test/login`
- **API ë¬¸ì„œ**: `https://localhost:3443/api-docs`
</file>

<file path="Readme.md">
# AR Namecard Backend API

AR ëª…í•¨ ì„œë¹„ìŠ¤ë¥¼ ìœ„í•œ Node.js + TypeScript + MongoDB ë°±ì—”ë“œ API

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

### í•„ìš” í™˜ê²½
- Node.js 18+
- MongoDB ì‹¤í–‰ ì¤‘
- npm

### ì„¤ì¹˜ ë° ì‹¤í–‰

```bash
# ì˜ì¡´ì„± ì„¤ì¹˜
npm install

# ê°œë°œ ì„œë²„ ì‹¤í–‰
npm run dev

# ë¹Œë“œ
npm run build

# í”„ë¡œë•ì…˜ ì„œë²„ ì‹¤í–‰
npm start
```

## âš™ï¸ í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

`.env` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë‹¤ìŒ ë‚´ìš©ì„ ì¶”ê°€í•˜ì„¸ìš”:

```env
# ì„œë²„ ì„¤ì •
PORT=3000
HTTPS_PORT=3443
HOST=0.0.0.0
NODE_ENV=development
ENABLE_HTTPS=false

# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
MONGODB_URI=mongodb://localhost:27017/ar_namecard

# JWT ì„¤ì •
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=24h

# íŒŒì¼ ì—…ë¡œë“œ ì„¤ì •
MAX_FILE_SIZE=10485760
UPLOAD_DIR=uploads

# CORS ì„¤ì •
FRONTEND_URL=http://localhost:3000

# SSL ì„¤ì • (HTTPSìš©)
SSL_KEY_PATH=./ssl/server.key
SSL_CERT_PATH=./ssl/server.crt

# Firebase ì„¤ì • (ì„ íƒì‚¬í•­)
# FIREBASE_PROJECT_ID=your-firebase-project-id
# FIREBASE_PRIVATE_KEY=your-firebase-private-key
```

## ğŸŒ ë„¤íŠ¸ì›Œí¬ ë° HTTPS ì„¤ì •

### HTTP ì „ìš© ëª¨ë“œ (ê¸°ë³¸)
```bash
npm run dev
```

### HTTPS ëª¨ë“œ (8th Wall í˜¸í™˜)

#### 1. SSL ì¸ì¦ì„œ ìƒì„±
```bash
# ê¸°ë³¸ SSL ì¸ì¦ì„œ ìƒì„±
npm run ssl:generate

# ê°œì„ ëœ SSL ì¸ì¦ì„œ ìƒì„± (ê¶Œì¥)
npm run ssl:fix

# mkcert ì‚¬ìš© (ë¸Œë¼ìš°ì € ê²½ê³  ì—†ìŒ, ìµœê³  ê¶Œì¥)
npm run ssl:mkcert
```

#### 2. HTTPS ì„œë²„ ì‹¤í–‰
```bash
# í™˜ê²½ ë³€ìˆ˜ë¡œ ì‹¤í–‰
npm run https

# ë˜ëŠ” .envì— ENABLE_HTTPS=true ì„¤ì • í›„
npm run dev
```

### ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼

#### ì ‘ê·¼ URL
- **ë¡œì»¬**: `http://localhost:3000` / `https://localhost:3443`
- **ë„¤íŠ¸ì›Œí¬**: `http://[IP]:3000` / `https://[IP]:3443`

#### ë¸Œë¼ìš°ì € ë³´ì•ˆ ê²½ê³  í•´ê²°
- **Chrome**: "ê³ ê¸‰" â†’ "localhost(ì•ˆì „í•˜ì§€ ì•ŠìŒ)ë¡œ ì´ë™"
- **Firefox**: "ê³ ê¸‰" â†’ "ìœ„í—˜ì„ ê°ìˆ˜í•˜ê³  ê³„ì†"
- **Safari**: "ìì„¸íˆ" â†’ "ì›¹ì‚¬ì´íŠ¸ ë°©ë¬¸"

## ğŸ“š API ë¬¸ì„œ ë° í…ŒìŠ¤íŠ¸

### Swagger UI
ì„œë²„ ì‹¤í–‰ í›„ ë‹¤ìŒ URLì—ì„œ API ë¬¸ì„œë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
- **ë¡œì»¬**: `http://localhost:3000/api-docs`
- **ë„¤íŠ¸ì›Œí¬**: `http://[IP]:3000/api-docs`

### í…ŒìŠ¤íŠ¸ í˜ì´ì§€
ë‹¤ìŒ í…ŒìŠ¤íŠ¸ í˜ì´ì§€ë“¤ì´ ì œê³µë©ë‹ˆë‹¤:

| í˜ì´ì§€ | URL | ì„¤ëª… |
|--------|-----|------|
| ë¡œê·¸ì¸ í…ŒìŠ¤íŠ¸ | `/test/login` | Firebase ì¸ì¦ í…ŒìŠ¤íŠ¸ |
| ì‚¬ìš©ì ê´€ë¦¬ | `/test/user` | ì‚¬ìš©ì CRUD í…ŒìŠ¤íŠ¸ |
| ì•„ë°”íƒ€ ê´€ë¦¬ | `/test/avatar` | ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ë° ì˜µì…˜ ê´€ë¦¬ |
| ì•„ì´í…œ ê´€ë¦¬ | `/test/item` | ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ ë° ìŠ¤í”„ë¼ì´íŠ¸ ê´€ë¦¬ |
| CORS í…ŒìŠ¤íŠ¸ | `/test/cors-test` | ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ ë° CORS í…ŒìŠ¤íŠ¸ |

### CORS í…ŒìŠ¤íŠ¸
ë‹¤ë¥¸ PCì—ì„œ ì ‘ê·¼ í…ŒìŠ¤íŠ¸:
```
http://[ì„œë²„IP]:3000/test/cors-test
```

## ğŸ›  ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¤í¬ë¦½íŠ¸

```bash
# ê°œë°œ ë° ë¹Œë“œ
npm run dev          # ê°œë°œ ì„œë²„ (nodemon)
npm run build        # TypeScript ì»´íŒŒì¼
npm start            # í”„ë¡œë•ì…˜ ì„œë²„

# HTTPS ê´€ë ¨
npm run https        # HTTPS ê°œë°œ ì„œë²„
npm run http-only    # HTTP ì „ìš© ì„œë²„
npm run ssl:generate # ê¸°ë³¸ SSL ì¸ì¦ì„œ ìƒì„±
npm run ssl:fix      # ê°œì„ ëœ SSL ì¸ì¦ì„œ ìƒì„±
npm run ssl:mkcert   # mkcert ê¸°ë°˜ ì‹ ë¢° ì¸ì¦ì„œ ìƒì„±

# ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬
npm run migrate:firebase    # Firebase ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜
npm run create:admin       # ê´€ë¦¬ì ê³„ì • ìƒì„±
npm run update:admin       # ê´€ë¦¬ì ê¶Œí•œ ì—…ë°ì´íŠ¸
```

## ğŸ” ì¸ì¦ ì‹œìŠ¤í…œ

### JWT í† í° ì¸ì¦
ëŒ€ë¶€ë¶„ì˜ APIëŠ” JWT í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤:
```http
Authorization: Bearer <your-jwt-token>
```

### Firebase ì¸ì¦
Google OAuthë¥¼ í†µí•œ Firebase ì¸ì¦ë„ ì§€ì›í•©ë‹ˆë‹¤:
- Firebase Consoleì—ì„œ ìŠ¹ì¸ëœ ë„ë©”ì¸ì— ì„œë²„ IP ì¶”ê°€ í•„ìš”
- ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ ì‹œ `http://[IP]:3000` ë„ë©”ì¸ ì¶”ê°€

## ğŸ›  API ì—”ë“œí¬ì¸íŠ¸

### ì‚¬ìš©ì ê´€ë¦¬ (Users)
```http
GET    /api/users/:id        # ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
PUT    /api/users/:id        # ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •
POST   /api/users            # ì‚¬ìš©ì ìƒì„±
GET    /api/users            # ì‚¬ìš©ì ëª©ë¡ (ê´€ë¦¬ì)
```

### ì•„ë°”íƒ€ ê´€ë¦¬ (Avatars)
```http
GET    /api/avatars/:id                    # ì•„ë°”íƒ€ ì •ë³´ ì¡°íšŒ (ìƒì„¸)
PUT    /api/avatars/:id                    # ì•„ë°”íƒ€ ì •ë³´ ìˆ˜ì •
GET    /api/avatars/categories             # ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬ ëª©ë¡
GET    /api/avatars/categories/:id/options # ì¹´í…Œê³ ë¦¬ë³„ ì˜µì…˜ ëª©ë¡

# ê´€ë¦¬ì ì „ìš©
POST   /api/admin/avatars/categories       # ì¹´í…Œê³ ë¦¬ ìƒì„±
PUT    /api/admin/avatars/categories/:id   # ì¹´í…Œê³ ë¦¬ ìˆ˜ì •
DELETE /api/admin/avatars/categories/:id   # ì¹´í…Œê³ ë¦¬ ì‚­ì œ
POST   /api/admin/avatars/options          # ì˜µì…˜ ìƒì„± (ë‹¤ì¤‘ ì—…ë¡œë“œ ì§€ì›)
```

### ìŠ¤í‹°ì»¤ ê´€ë¦¬ (Stickers)
```http
GET    /api/stickers                  # ìŠ¤í‹°ì»¤ ëª©ë¡ ì¡°íšŒ
GET    /api/stickers/:id              # ìŠ¤í‹°ì»¤ ìƒì„¸ ì¡°íšŒ

# ê´€ë¦¬ì ì „ìš©
POST   /api/admin/stickers/categories # ì¹´í…Œê³ ë¦¬ ìƒì„±
POST   /api/admin/stickers           # ìŠ¤í‹°ì»¤ ìƒì„± (ìŠ¤í”„ë¼ì´íŠ¸ ì§€ì›)
```

### ìºë¦­í„° ê´€ë¦¬ (Characters)
```http
GET    /api/characters                # ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ëª©ë¡
GET    /api/characters/:id            # ìºë¦­í„° ì¹´í…Œê³ ë¦¬ ìƒì„¸ ì¡°íšŒ
```

### ê´€ë¦¬ì ê¸°ëŠ¥ (Admin)
```http
GET    /api/admin/users          # ì „ì²´ ì‚¬ìš©ì ëª©ë¡
PUT    /api/admin/users/:id      # ì‚¬ìš©ì ê¶Œí•œ ê´€ë¦¬
```

### í—¬ìŠ¤ ì²´í¬
```http
GET    /api/health               # ì„œë²„ ìƒíƒœ í™•ì¸
```

## ğŸ“Š ë°ì´í„° ëª¨ë¸

### User (ì‚¬ìš©ì)
```typescript
{
  id: string;           // ì‚¬ìš©ì ID
  nameEn?: string;      // ì˜ë¬¸ ì´ë¦„
  email: string;        // ì´ë©”ì¼ (í•„ìˆ˜, ê³ ìœ )
  nameKr: string;       // í•œê¸€ ì´ë¦„ (í•„ìˆ˜)
  role?: string;        // ì—­í•  (ê¸°ë³¸ê°’: 'User')
  part?: string;        // ì†Œì† ë¶€ì„œ
  phone: string;        // ì „í™”ë²ˆí˜¸ (í•„ìˆ˜)
  isNamecardActive: boolean; // ëª…í•¨ í™œì„±í™” ì—¬ë¶€
  arId: string;         // AR ëª…í•¨ ID (3ìë¦¬, ê³ ìœ )
  isAdmin: boolean;     // ê´€ë¦¬ì ì—¬ë¶€
}
```

### AvatarWithUser (ì•„ë°”íƒ€ + ì‚¬ìš©ì í†µí•©)
```typescript
{
  // ì‚¬ìš©ì ì •ë³´
  id: string;
  nameKr?: string;
  email?: string;
  arId?: string;
  
  // ì•„ë°”íƒ€ ì„ íƒ ì •ë³´ (ìƒì„¸)
  avatarSelections: {
    [category]: {
      id: string;
      name: string;
      imageUrl: string;
      thumbnailUrl: string;
    }
  };
  
  // ì—­í•  ë° ì•„ì´í…œ (ìƒì„¸)
  role?: { id, name, imageUrl, thumbnailUrl };
  item1?: { id, name, imageUrl, thumbnailUrl, category };
  item2?: { id, name, imageUrl, thumbnailUrl, category };
  item3?: { id, name, imageUrl, thumbnailUrl, category };
  
  avatarImgUrl?: string;
  message: string;
}
```

### AvatarCategory (ì•„ë°”íƒ€ ì¹´í…Œê³ ë¦¬)
```typescript
{
  name: string;         // ì¹´í…Œê³ ë¦¬ ì´ë¦„
  type: string;         // ì¹´í…Œê³ ë¦¬ íƒ€ì… (ê³ ìœ )
  options: [{           // ì•„ë°”íƒ€ ì˜µì…˜ ë°°ì—´
    name: string;
    imageUrl: string;
    thumbnailUrl: string;
    thumbnailSource: 'user' | 'auto';
    color?: string;
    order: number;
  }];
  order: number;        // ìˆœì„œ
}
```

### ItemCategory (ì•„ì´í…œ ì¹´í…Œê³ ë¦¬)
```typescript
{
  name: string;         // ì¹´í…Œê³ ë¦¬ ì´ë¦„
  type: string;         // ì¹´í…Œê³ ë¦¬ íƒ€ì… (ê³ ìœ )
  items: [{             // ì•„ì´í…œ ë°°ì—´
    name: string;
    imageUrl: string;
    thumbnailUrl: string;
    thumbnailSource: 'user' | 'auto';
    animation?: {       // ìŠ¤í”„ë¼ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜
      frames: number;   // í”„ë ˆì„ ìˆ˜
      columns: number;  // ì—´ ìˆ˜
      duration: number; // ì§€ì† ì‹œê°„
      type: string;     // ì• ë‹ˆë©”ì´ì…˜ íƒ€ì…
    };
    order: number;
  }];
  order: number;        // ìˆœì„œ
}
```

## ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ database.ts         # MongoDB ì—°ê²°
â”‚   â”‚   â”œâ”€â”€ cors.ts            # CORS ì„¤ì • (8th Wall ì§€ì›)
â”‚   â”‚   â””â”€â”€ swagger.ts         # Swagger ì„¤ì •
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ userController.ts
â”‚   â”‚   â”œâ”€â”€ avatarController.ts
â”‚   â”‚   â”œâ”€â”€ itemController.ts
â”‚   â”‚   â”œâ”€â”€ adminController.ts
â”‚   â”‚   â””â”€â”€ firebaseAuthController.ts
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.ts            # JWT ì¸ì¦
â”‚   â”‚   â””â”€â”€ upload.ts          # íŒŒì¼ ì—…ë¡œë“œ
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ User.ts
â”‚   â”‚   â”œâ”€â”€ UserCustomization.ts
â”‚   â”‚   â”œâ”€â”€ AvatarCategory.ts
â”‚   â”‚   â””â”€â”€ ItemCategory.ts
â”‚   â”œâ”€â”€ routes/                # API ë¼ìš°íŠ¸
â”‚   â”œâ”€â”€ scripts/               # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ thumbnailGenerator.ts # ì¸ë„¤ì¼ ìƒì„± (Sharp)
â”‚   â””â”€â”€ index.ts               # ì„œë²„ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸
â”œâ”€â”€ public/test/               # í…ŒìŠ¤íŠ¸ í˜ì´ì§€ë“¤
â”œâ”€â”€ uploads/                   # ì—…ë¡œë“œ íŒŒì¼
â”œâ”€â”€ ssl/                       # SSL ì¸ì¦ì„œ
â”œâ”€â”€ scripts/                   # SSL ìƒì„± ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ dist/                      # ë¹Œë“œ ê²°ê³¼
â”œâ”€â”€ .env                       # í™˜ê²½ ë³€ìˆ˜
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ HTTPS_SETUP.md            # HTTPS ì„¤ì • ê°€ì´ë“œ
â””â”€â”€ README.md
```

## ğŸ¯ íŠ¹ë³„ ê¸°ëŠ¥

### ì¸ë„¤ì¼ ìë™ ìƒì„±
- **Sharp ë¼ì´ë¸ŒëŸ¬ë¦¬** ì‚¬ìš©ìœ¼ë¡œ 300px ì¸ë„¤ì¼ ìë™ ìƒì„±
- **ìŠ¤í”„ë¼ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜** ì²« ë²ˆì§¸ í”„ë ˆì„ ì¶”ì¶œ
- ì‚¬ìš©ì ì—…ë¡œë“œ ì¸ë„¤ì¼ê³¼ ìë™ ìƒì„± ì¸ë„¤ì¼ ëª¨ë‘ ì§€ì›

### ë‹¤ì¤‘ íŒŒì¼ ì—…ë¡œë“œ
- ì•„ë°”íƒ€/ì•„ì´í…œ ì˜µì…˜ **ì—¬ëŸ¬ ê°œ ë™ì‹œ ì—…ë¡œë“œ**
- **ê°œë³„ ì„¤ì •**: ì´ë¦„, ìƒ‰ìƒ, ìˆœì„œ ê°œë³„ ì§€ì •
- **ì¼ê´„ ì„¤ì •**: ê³µí†µ ì†ì„± ìë™ ì ìš©
- **ë“œë˜ê·¸ ì•¤ ë“œë¡­** ì§€ì›

### íŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ
- ìˆ˜ì •/ì‚­ì œ ì‹œ **ê´€ë ¨ íŒŒì¼ ìë™ ì‚­ì œ**
- ì¸ë„¤ì¼ ì¬ìƒì„± ê¸°ëŠ¥
- íŒŒì¼ ê²½ë¡œ ìœ í‹¸ë¦¬í‹° ì œê³µ

### 8th Wall í˜¸í™˜
- **HTTPS í•„ìˆ˜** ì§€ì›
- **Mixed Content** ì •ì±… ì¤€ìˆ˜
- ëª¨ë“  8th Wall ë„ë©”ì¸ CORS í—ˆìš©

## ğŸ§ª í…ŒìŠ¤íŠ¸ ë°©ë²•

### 1. ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸
```bash
curl http://localhost:3000/api/health
```

### 2. Swagger UI í…ŒìŠ¤íŠ¸
1. ë¸Œë¼ìš°ì €ì—ì„œ `http://localhost:3000/api-docs` ì ‘ì†
2. **Avatars** ì„¹ì…˜ì´ ê¸°ë³¸ìœ¼ë¡œ í™•ì¥ë¨
3. ê° APIì˜ "Try it out" ë²„íŠ¼ìœ¼ë¡œ í…ŒìŠ¤íŠ¸

### 3. ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ í…ŒìŠ¤íŠ¸
1. ë‹¤ë¥¸ PCì—ì„œ `http://[ì„œë²„IP]:3000/test/cors-test` ì ‘ì†
2. ëª¨ë“  API í…ŒìŠ¤íŠ¸ ì‹¤í–‰
3. CORS í—ˆìš©/ì°¨ë‹¨ ìƒíƒœ ì‹¤ì‹œê°„ í™•ì¸

### 4. ê´€ë¦¬ì í˜ì´ì§€ í…ŒìŠ¤íŠ¸
- **ì‚¬ìš©ì ê´€ë¦¬**: `/test/user`
- **ì•„ë°”íƒ€ ê´€ë¦¬**: `/test/avatar` (ë‹¤ì¤‘ ì—…ë¡œë“œ, ì¸ë„¤ì¼ ìƒì„±)
- **ì•„ì´í…œ ê´€ë¦¬**: `/test/item` (ìŠ¤í”„ë¼ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜)

## ğŸ”§ ê°œë°œ ë„êµ¬

- **TypeScript**: ì •ì  íƒ€ì… ê²€ì‚¬
- **Express**: ì›¹ í”„ë ˆì„ì›Œí¬  
- **MongoDB + Mongoose**: ë°ì´í„°ë² ì´ìŠ¤
- **JWT**: ì¸ì¦
- **Firebase Admin**: Firebase ì¸ì¦
- **Multer**: íŒŒì¼ ì—…ë¡œë“œ
- **Sharp**: ì´ë¯¸ì§€ ì²˜ë¦¬ ë° ì¸ë„¤ì¼ ìƒì„±
- **Swagger**: API ë¬¸ì„œí™”
- **Express-validator**: ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
- **CORS**: í¬ë¡œìŠ¤ ì˜¤ë¦¬ì§„ ì„¤ì •

## ğŸš¨ ë¬¸ì œ í•´ê²°

### SSL ì¸ì¦ì„œ ì˜¤ë¥˜ (ERR_SSL_KEY_USAGE_INCOMPATIBLE)
```bash
# ê°œì„ ëœ ì¸ì¦ì„œ ìƒì„±
npm run ssl:fix

# ë˜ëŠ” mkcert ì‚¬ìš© (ê¶Œì¥)
brew install mkcert
npm run ssl:mkcert
```

### CORS ì˜¤ë¥˜
```bash
# ê°œë°œ ëª¨ë“œì—ì„œ ëª¨ë“  ë„ë©”ì¸ í—ˆìš©
echo "CORS_ALLOW_ALL=true" >> .env
```

### í¬íŠ¸ ì¶©ëŒ
```bash
# ì‚¬ìš© ì¤‘ì¸ í¬íŠ¸ í™•ì¸
lsof -i :3000

# í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
kill -9 [PID]
```

### MongoDB ì—°ê²° ì˜¤ë¥˜
```bash
# MongoDB ì‹¤í–‰ í™•ì¸
brew services start mongodb/brew/mongodb-community
```

## ğŸ“ ì§€ì›

ë¬¸ì œê°€ ë°œìƒí•˜ë©´ ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:
1. MongoDB ì‹¤í–‰ ìƒíƒœ
2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (.env íŒŒì¼)
3. í¬íŠ¸ ì‚¬ìš© ìƒíƒœ
4. ë„¤íŠ¸ì›Œí¬ ë°©í™”ë²½ ì„¤ì •
5. SSL ì¸ì¦ì„œ ìœ íš¨ì„±

---

**AR Namecard Backend API v1.0.0**  
Node.js + TypeScript + MongoDB ê¸°ë°˜ì˜ ì™„ì „í•œ AR ëª…í•¨ ë°±ì—”ë“œ ì†”ë£¨ì…˜
</file>

<file path="simple-compose.yml">
version: '3.8'

services:
  # MongoDB Database
  mongodb:
    image: mongo:6.0
    container_name: ar-namecard-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: hnine0426
      MONGO_INITDB_DATABASE: ar_namecard
    volumes:
      - /volume1/docker/ar-namecard/data/mongodb:/data/db
    networks:
      - ar-namecard-network
    ports:
      - "127.0.0.1:27017:27017"
    command: mongod --auth

  # AR Namecard API Server
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ar-namecard-api
    restart: unless-stopped
    depends_on:
      - mongodb
    environment:
      NODE_ENV: production
      PORT: 3000
      HTTPS_PORT: 3443
      HOST: 0.0.0.0
      ENABLE_HTTPS: false
      MONGODB_URI: mongodb://admin:hnine0426@mongodb:27017/ar_namecard?authSource=admin
      JWT_SECRET: super-secure-jwt-secret-for-production
      JWT_EXPIRES_IN: 24h
      MAX_FILE_SIZE: 10485760
      UPLOAD_DIR: uploads
      FRONTEND_URL: http://192.168.1.93:3000
      CORS_ALLOW_ALL: true
    volumes:
      - /volume1/docker/ar-namecard/uploads:/app/uploads
      - /volume1/docker/ar-namecard/ssl:/app/ssl
      - /volume1/docker/ar-namecard/public:/app/public
    networks:
      - ar-namecard-network
    ports:
      - "3000:3000"
      - "3443:3443"

networks:
  ar-namecard-network:
    driver: bridge
</file>

<file path="SYNOLOGY_DEPLOYMENT.md">
# ì‹œë†€ë¡œì§€ NAS ë°°í¬ ê°€ì´ë“œ

## ğŸ“‹ ê°œìš”

ì´ ê°€ì´ë“œëŠ” AR Namecard APIë¥¼ ì‹œë†€ë¡œì§€ NAS ì„œë²„ (192.168.1.93)ì— Dockerë¥¼ ì‚¬ìš©í•˜ì—¬ ë°°í¬í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## ğŸ¯ ë°°í¬ ëª©í‘œ

- **ê³ ê°€ìš©ì„±**: Docker Composeë¥¼ í†µí•œ ì„œë¹„ìŠ¤ ê´€ë¦¬
- **ë°ì´í„° ë³´í˜¸**: MongoDB ë°ì´í„° ì˜êµ¬ ì €ì¥
- **ë³´ì•ˆ**: HTTPS ì§€ì› ë° ë°©í™”ë²½ ì„¤ì •
- **ëª¨ë‹ˆí„°ë§**: ë¡œê¹… ë° í—¬ìŠ¤ì²´í¬
- **ë°±ì—…**: ìë™í™”ëœ ë°±ì—… ì‹œìŠ¤í…œ

## ğŸ›  ì‚¬ì „ ì¤€ë¹„

### 1. ì‹œë†€ë¡œì§€ NAS ì„¤ì •

#### Container Manager ì„¤ì¹˜
1. Package Centerì—ì„œ "Container Manager" ì„¤ì¹˜
2. Docker ì„œë¹„ìŠ¤ í™œì„±í™”

#### SSH ì ‘ê·¼ ì„¤ì •
1. ì œì–´íŒ > í„°ë¯¸ë„ ë° SNMP > SSH ì„œë¹„ìŠ¤ í™œì„±í™”
2. SSH í‚¤ ì„¤ì • (ê¶Œì¥)

```bash
# ë¡œì»¬ì—ì„œ SSH í‚¤ ìƒì„±
ssh-keygen -t rsa -b 4096 -C "your-email@example.com"

# ê³µê°œí‚¤ë¥¼ NASì— ë³µì‚¬
ssh-copy-id admin@192.168.1.93
```

### 2. ë„¤íŠ¸ì›Œí¬ ì„¤ì •

#### í¬íŠ¸ ê°œë°© (ì œì–´íŒ > ë³´ì•ˆ > ë°©í™”ë²½)
- **3000**: HTTP API
- **3443**: HTTPS API
- **80**: HTTP (Nginx, ì„ íƒì‚¬í•­)
- **443**: HTTPS (Nginx, ì„ íƒì‚¬í•­)

#### ë„ë©”ì¸ ì„¤ì • (ì„ íƒì‚¬í•­)
- DNSì— `ar-namecard.local` ì¶”ê°€
- ë˜ëŠ” `/etc/hosts`ì— `192.168.1.93 ar-namecard.local` ì¶”ê°€

## ğŸš€ ë°°í¬ ê³¼ì •

### 1. ì´ˆê¸° ë°°í¬

```bash
# ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
./deploy.sh

# ë˜ëŠ” ìˆ˜ë™ ë°°í¬
./deploy.sh deploy
```

ë°°í¬ ê³¼ì •:
1. âœ… ì‚¬ì „ ìš”êµ¬ì‚¬í•­ í™•ì¸
2. ğŸ”— NAS ì—°ê²° í…ŒìŠ¤íŠ¸
3. ğŸ“ ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±
4. ğŸ—ï¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ë¹Œë“œ
5. ğŸ“¤ íŒŒì¼ ì „ì†¡
6. âš™ï¸ í™˜ê²½ ì„¤ì •
7. ğŸ” SSL ì¸ì¦ì„œ ìƒì„±
8. ğŸ³ Docker ì„œë¹„ìŠ¤ ë°°í¬
9. âœ… ë°°í¬ ê²€ì¦

### 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

ë°°í¬ í›„ `.env` íŒŒì¼ì„ í¸ì§‘í•˜ì—¬ ì‹¤ì œ í™˜ê²½ì— ë§ê²Œ ì„¤ì •:

```bash
ssh admin@192.168.1.93
cd /volume1/docker/ar-namecard/app
nano .env
```

**í•„ìˆ˜ ë³€ê²½ ì‚¬í•­:**
- `JWT_SECRET`: ê°•ë ¥í•œ ë¹„ë°€í‚¤ë¡œ ë³€ê²½
- `MONGO_ROOT_PASSWORD`: MongoDB ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸
- `FIREBASE_*`: Firebase í”„ë¡œì íŠ¸ ì„¤ì •
- `FRONTEND_URL`: í”„ë¡ íŠ¸ì—”ë“œ ë„ë©”ì¸

### 3. Firebase ì„¤ì •

Firebase ì„œë¹„ìŠ¤ ê³„ì • í‚¤ íŒŒì¼ì„ NASì— ì—…ë¡œë“œ:

```bash
# ë¡œì»¬ì—ì„œ Firebase í‚¤ íŒŒì¼ ë³µì‚¬
scp firebase-service-account.json admin@192.168.1.93:/volume1/docker/ar-namecard/app/
```

## ğŸ“Š ì„œë¹„ìŠ¤ ê´€ë¦¬

### ìƒíƒœ í™•ì¸

```bash
# ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
./deploy.sh status

# ë¡œê·¸ í™•ì¸
./deploy.sh logs

# SSHë¡œ ì§ì ‘ í™•ì¸
ssh admin@192.168.1.93 'cd /volume1/docker/ar-namecard/app && docker-compose ps'
```

### ì„œë¹„ìŠ¤ ì œì–´

```bash
# ì„œë¹„ìŠ¤ ì¬ì‹œì‘
./deploy.sh restart

# ì„œë¹„ìŠ¤ ì¤‘ì§€
./deploy.sh stop

# ì• í”Œë¦¬ì¼€ì´ì…˜ë§Œ ì—…ë°ì´íŠ¸
./deploy.sh update
```

### ì§ì ‘ ê´€ë¦¬ (SSH)

```bash
ssh admin@192.168.1.93
cd /volume1/docker/ar-namecard/app

# ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
docker-compose ps

# ë¡œê·¸ ë³´ê¸° (ì‹¤ì‹œê°„)
docker-compose logs -f

# íŠ¹ì • ì„œë¹„ìŠ¤ ë¡œê·¸
docker-compose logs -f api
docker-compose logs -f mongodb

# ì„œë¹„ìŠ¤ ì¬ì‹œì‘
docker-compose restart

# ì„¤ì • ë³€ê²½ í›„ ì¬ë°°í¬
docker-compose up -d --build
```

## ğŸ’¾ ë°±ì—… ë° ë³µêµ¬

### ë°±ì—… ìƒì„±

```bash
# ì „ì²´ ë°±ì—…
./backup.sh backup

# ë°±ì—… ëª©ë¡ í™•ì¸
./backup.sh list
```

### ë°±ì—… ë³µêµ¬

```bash
# MongoDB ë³µêµ¬
./backup.sh restore-db 20250121_143000

# ì—…ë¡œë“œ íŒŒì¼ ë³µêµ¬
./backup.sh restore-uploads 20250121_143000

# ë°±ì—… ë¬´ê²°ì„± í™•ì¸
./backup.sh verify 20250121_143000
```

### ìë™ ë°±ì—… ì„¤ì •

crontabì— ìë™ ë°±ì—… ìŠ¤ì¼€ì¤„ ì¶”ê°€:

```bash
ssh admin@192.168.1.93
crontab -e

# ë§¤ì¼ ìƒˆë²½ 2ì‹œ ë°±ì—…
0 2 * * * /volume1/docker/ar-namecard/backup.sh backup

# ë§¤ì£¼ ì¼ìš”ì¼ ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ (30ì¼ ì´ìƒ)
0 3 * * 0 /volume1/docker/ar-namecard/backup.sh cleanup 30
```

## ğŸ”§ ë¬¸ì œ í•´ê²°

### ì¼ë°˜ì ì¸ ë¬¸ì œ

#### 1. ì»¨í…Œì´ë„ˆê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ

```bash
# ë¡œê·¸ í™•ì¸
docker-compose logs

# í¬íŠ¸ ì¶©ëŒ í™•ì¸
netstat -tlnp | grep :3000

# ë””ìŠ¤í¬ ê³µê°„ í™•ì¸
df -h
```

#### 2. MongoDB ì—°ê²° ì‹¤íŒ¨

```bash
# MongoDB ì»¨í…Œì´ë„ˆ ìƒíƒœ í™•ì¸
docker-compose logs mongodb

# MongoDB ì ‘ì† í…ŒìŠ¤íŠ¸
docker-compose exec mongodb mongosh -u admin -p
```

#### 3. SSL ì¸ì¦ì„œ ë¬¸ì œ

```bash
# ì¸ì¦ì„œ ì¬ìƒì„±
cd /volume1/docker/ar-namecard
openssl req -x509 -newkey rsa:4096 -keyout ssl/server.key -out ssl/server.crt -days 365 -nodes \
    -subj '/C=KR/ST=Seoul/L=Seoul/O=AR-Namecard/CN=192.168.1.93'
```

#### 4. íŒŒì¼ ê¶Œí•œ ë¬¸ì œ

```bash
# ê¶Œí•œ ìˆ˜ì •
sudo chown -R admin:administrators /volume1/docker/ar-namecard
sudo chmod -R 755 /volume1/docker/ar-namecard
```

### ì„±ëŠ¥ ìµœì í™”

#### MongoDB ìµœì í™”

```bash
# MongoDB ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì œí•œ (docker-compose.yml)
services:
  mongodb:
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
```

#### ë¡œê·¸ ë¡œí…Œì´ì…˜

```bash
# Docker ë¡œê·¸ ì œí•œ ì„¤ì •
services:
  api:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

## ğŸ“ˆ ëª¨ë‹ˆí„°ë§

### ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

```bash
# CPU ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
docker stats

# ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰
df -h /volume1/docker/ar-namecard

# ë„¤íŠ¸ì›Œí¬ ì—°ê²°
netstat -tlnp | grep :3000
```

### ì• í”Œë¦¬ì¼€ì´ì…˜ ëª¨ë‹ˆí„°ë§

```bash
# API í—¬ìŠ¤ì²´í¬
curl http://192.168.1.93:3000/api/health

# API ì‘ë‹µ ì‹œê°„ í…ŒìŠ¤íŠ¸
curl -w "@curl-format.txt" -o /dev/null -s http://192.168.1.93:3000/api/health
```

### ë¡œê·¸ ë¶„ì„

```bash
# ì˜¤ë¥˜ ë¡œê·¸ ê²€ìƒ‰
docker-compose logs | grep -i error

# íŠ¹ì • ì‹œê°„ëŒ€ ë¡œê·¸
docker-compose logs --since="2024-01-21T10:00:00"

# ë¡œê·¸ í†µê³„
docker-compose logs | grep "GET /api" | wc -l
```

## ğŸ”’ ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ

1. **ë°©í™”ë²½ ì„¤ì •**: í•„ìš”í•œ í¬íŠ¸ë§Œ ê°œë°©
2. **VPN ì ‘ê·¼**: ì™¸ë¶€ ì ‘ê·¼ ì‹œ VPN ì‚¬ìš© ê¶Œì¥
3. **SSL/TLS**: HTTPS ê°•ì œ ì‚¬ìš©

### ë°ì´í„° ë³´ì•ˆ

1. **ë°ì´í„°ë² ì´ìŠ¤ ì•”í˜¸í™”**: MongoDB ì•”í˜¸í™” í™œì„±í™”
2. **ë°±ì—… ì•”í˜¸í™”**: ì¤‘ìš” ë°ì´í„° ë°±ì—… ì‹œ ì•”í˜¸í™”
3. **ì ‘ê·¼ ì œì–´**: ìµœì†Œ ê¶Œí•œ ì›ì¹™ ì ìš©

### ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´ì•ˆ

1. **í™˜ê²½ë³€ìˆ˜**: ì¤‘ìš” ì •ë³´ëŠ” í™˜ê²½ë³€ìˆ˜ë¡œ ê´€ë¦¬
2. **JWT ë³´ì•ˆ**: ê°•ë ¥í•œ JWT ì‹œí¬ë¦¿ ì‚¬ìš©
3. **CORS ì„¤ì •**: í—ˆìš©ëœ ë„ë©”ì¸ë§Œ ì ‘ê·¼ í—ˆìš©

## ğŸ“š ì¶”ê°€ ìë£Œ

### ìœ ìš©í•œ ëª…ë ¹ì–´

```bash
# ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸
./deploy.sh status && ./backup.sh list

# ì™„ì „í•œ ì¬ë°°í¬
./deploy.sh stop && ./deploy.sh deploy

# ê°œë°œ ëª¨ë“œë¡œ ë¡œì»¬ í…ŒìŠ¤íŠ¸
npm run dev

# í”„ë¡œë•ì…˜ ë¹Œë“œ í…ŒìŠ¤íŠ¸
npm run build && npm start
```

### ë””ë ‰í† ë¦¬ êµ¬ì¡°

```
/volume1/docker/ar-namecard/
â”œâ”€â”€ app/                        # ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ
â”‚   â”œâ”€â”€ dist/                   # ì»´íŒŒì¼ëœ TypeScript
â”‚   â”œâ”€â”€ node_modules/           # Node.js ì˜ì¡´ì„±
â”‚   â”œâ”€â”€ .env                    # í™˜ê²½ ë³€ìˆ˜
â”‚   â”œâ”€â”€ docker-compose.yml      # Docker êµ¬ì„±
â”‚   â””â”€â”€ firebase-service-account.json
â”œâ”€â”€ data/                       # ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼
â”‚   â”œâ”€â”€ mongodb/                # MongoDB ë°ì´í„°
â”‚   â””â”€â”€ mongodb-config/         # MongoDB ì„¤ì •
â”œâ”€â”€ uploads/                    # ì—…ë¡œë“œëœ íŒŒì¼
â”œâ”€â”€ ssl/                        # SSL ì¸ì¦ì„œ
â”œâ”€â”€ public/                     # ì •ì  íŒŒì¼
â”œâ”€â”€ backups/                    # ë°±ì—… íŒŒì¼
â”‚   â”œâ”€â”€ mongodb/                # DB ë°±ì—…
â”‚   â”œâ”€â”€ uploads/                # íŒŒì¼ ë°±ì—…
â”‚   â”œâ”€â”€ config/                 # ì„¤ì • ë°±ì—…
â”‚   â””â”€â”€ ssl/                    # SSL ë°±ì—…
â””â”€â”€ logs/                       # ë¡œê·¸ íŒŒì¼
```

### ì—°ë½ì²˜ ë° ì§€ì›

ë¬¸ì œ ë°œìƒ ì‹œ:
1. ë¡œê·¸ í™•ì¸ í›„ ë¬¸ì œ ë¶„ì„
2. ê³µì‹ ë¬¸ì„œ ì°¸ì¡°
3. ê°œë°œíŒ€ ë¬¸ì˜

---

**ë°°í¬ ì™„ë£Œ í›„ í™•ì¸ì‚¬í•­:**
- âœ… API ì—”ë“œí¬ì¸íŠ¸ ì •ìƒ ì‘ë™: `http://192.168.1.93:3000/api/health`
- âœ… HTTPS ì ‘ê·¼ ê°€ëŠ¥: `https://192.168.1.93:3443/api/health`
- âœ… Swagger ë¬¸ì„œ ì ‘ê·¼: `http://192.168.1.93:3000/api-docs`
- âœ… MongoDB ì—°ê²° ì •ìƒ
- âœ… íŒŒì¼ ì—…ë¡œë“œ ê¸°ëŠ¥ ì •ìƒ
- âœ… ë°±ì—… ì‹œìŠ¤í…œ ë™ì‘
</file>

<file path="test-firebase-upload.js">
const fs = require('fs');
const path = require('path');

// Create a simple test image file
const testImagePath = path.join(__dirname, 'test-image.txt');
const testContent = 'This is a test file for Firebase Storage upload';

fs.writeFileSync(testImagePath, testContent);

console.log('Test file created:', testImagePath);
console.log('File content:', fs.readFileSync(testImagePath, 'utf8'));

// Test if all required environment variables are available
const requiredEnvVars = [
  'FIREBASE_PROJECT_ID',
  'FIREBASE_CLIENT_EMAIL', 
  'FIREBASE_PRIVATE_KEY',
  'FIREBASE_STORAGE_BUCKET'
];

console.log('\nğŸ“‹ Environment Variables Check:');
requiredEnvVars.forEach(varName => {
  const value = process.env[varName];
  if (value) {
    console.log(`âœ… ${varName}: ${varName === 'FIREBASE_PRIVATE_KEY' ? '[REDACTED]' : value}`);
  } else {
    console.log(`âŒ ${varName}: NOT SET`);
  }
});

console.log('\nğŸ”— Testing MongoDB connection and Firebase configuration...');
console.log('Server should be running on: http://localhost:3002');
console.log('MongoDB URI:', process.env.MONGODB_URI || 'NOT SET');
</file>

<file path="test-image.txt">
This is a test file for Firebase Storage upload
</file>

<file path="test-upload.js">
const FormData = require('form-data');
const fs = require('fs');
const axios = require('axios').default;
const path = require('path');

// ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ íŒŒì¼ ìƒì„± (1px íˆ¬ëª… PNG)
const createTestImage = () => {
  const pngData = Buffer.from([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
    0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
    0x0B, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0x63, 0x60, 0x00, 0x02, 0x00,
    0x00, 0x05, 0x00, 0x01, 0xE2, 0x26, 0x05, 0x9B, 0x00, 0x00, 0x00, 0x00,
    0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
  ]);
  
  const testImagePath = path.join(__dirname, 'test-image.png');
  fs.writeFileSync(testImagePath, pngData);
  return testImagePath;
};

async function testUpload() {
  try {
    console.log('ğŸ” Firebase Storage ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸ ì‹œì‘...');
    
    // í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ìƒì„±
    const testImagePath = createTestImage();
    console.log('âœ… í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ:', testImagePath);
    
    // FormData ì¤€ë¹„
    const form = new FormData();
    form.append('file', fs.createReadStream(testImagePath), {
      filename: 'test-image.png',
      contentType: 'image/png'
    });
    
    console.log('ğŸ“¤ ì—…ë¡œë“œ ìš”ì²­ ì „ì†¡ ì¤‘...');
    
    const response = await axios.post('http://localhost:3002/api/upload', form, {
      headers: {
        ...form.getHeaders(),
        'Content-Type': 'multipart/form-data'
      },
      timeout: 30000
    });
    
    if (response.status === 200) {
      console.log('ğŸ‰ ì—…ë¡œë“œ ì„±ê³µ!');
      console.log('ğŸ“‹ ì‘ë‹µ ë°ì´í„°:', response.data);
      console.log('ğŸ”— Firebase Storage URL:', response.data.url);
    } else {
      console.log('âŒ ì—…ë¡œë“œ ì‹¤íŒ¨:', response.status, response.statusText);
    }
    
    // í…ŒìŠ¤íŠ¸ íŒŒì¼ ì •ë¦¬
    fs.unlinkSync(testImagePath);
    console.log('ğŸ§¹ í…ŒìŠ¤íŠ¸ íŒŒì¼ ì •ë¦¬ ì™„ë£Œ');
    
  } catch (error) {
    console.error('ğŸ’¥ ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error.response?.data || error.message);
    
    // ìƒì„¸ ì—ëŸ¬ ì •ë³´
    if (error.response) {
      console.error('ğŸ“Š ì—ëŸ¬ ìƒíƒœ:', error.response.status);
      console.error('ğŸ“‹ ì—ëŸ¬ ë°ì´í„°:', error.response.data);
    }
  }
}

testUpload();
</file>

<file path="test.txt">
Firebase Storage upload test file
</file>

</files>
